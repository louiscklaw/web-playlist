/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(8);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

var Readable = __webpack_require__(22);
var Writable = __webpack_require__(14);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
exports.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var R = (typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {

  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }var doError = type === 'error';

  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  checkListener(listener);

  events = this._events;
  if (events === undefined) return this;

  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }

    if (list.length === 1) events[type] = list[0];

    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;

  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined) return [];

  var evlistener = events[type];
  if (evlistener === undefined) return [];

  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12).Buffer))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(33);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(34);

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(12);
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(4);
var getBigInt_1 = __webpack_require__(30);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK;
/**
 * Statistics about a file/directory, like `fs.Stats`.
 */
var Stats = /** @class */function () {
    function Stats() {}
    Stats.build = function (node, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var stats = new Stats();
        var uid = node.uid,
            gid = node.gid,
            atime = node.atime,
            mtime = node.mtime,
            ctime = node.ctime;
        var getStatNumber = !bigint ? function (number) {
            return number;
        } : getBigInt_1.default;
        // Copy all values on Stats from Node, so that if Node values
        // change, values on Stats would still be the old ones,
        // just like in Node fs.
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
    };
    Stats.prototype._checkModeProperty = function (property) {
        return (Number(this.mode) & S_IFMT) === property;
    };
    Stats.prototype.isDirectory = function () {
        return this._checkModeProperty(S_IFDIR);
    };
    Stats.prototype.isFile = function () {
        return this._checkModeProperty(S_IFREG);
    };
    Stats.prototype.isBlockDevice = function () {
        return this._checkModeProperty(S_IFBLK);
    };
    Stats.prototype.isCharacterDevice = function () {
        return this._checkModeProperty(S_IFCHR);
    };
    Stats.prototype.isSymbolicLink = function () {
        return this._checkModeProperty(S_IFLNK);
    };
    Stats.prototype.isFIFO = function () {
        return this._checkModeProperty(S_IFIFO);
    };
    Stats.prototype.isSocket = function () {
        return this._checkModeProperty(S_IFSOCK);
    };
    return Stats;
}();
exports.Stats = Stats;
exports.default = Stats;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(12);
exports.Buffer = buffer_1.Buffer;
function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArrays([void 0, arg0], args)))();
}
var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
exports.bufferAllocUnsafe = bufferAllocUnsafe;
var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
exports.bufferFrom = bufferFrom;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(31);
var ieee754 = __webpack_require__(32);
var isArray = __webpack_require__(17);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = __webpack_require__(22);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(14);
exports.Duplex = __webpack_require__(2);
exports.Transform = __webpack_require__(26);
exports.PassThrough = __webpack_require__(47);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(8);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(46)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(23);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(9).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(24);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(2);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(2);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(21).setImmediate, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(4);
var encoding_1 = __webpack_require__(16);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK;
/**
 * A directory entry, like `fs.Dirent`.
 */
var Dirent = /** @class */function () {
    function Dirent() {
        this.name = '';
        this.mode = 0;
    }
    Dirent.build = function (link, encoding) {
        var dirent = new Dirent();
        var mode = link.getNode().mode;
        dirent.name = encoding_1.strToEncoding(link.getName(), encoding);
        dirent.mode = mode;
        return dirent;
    };
    Dirent.prototype._checkModeProperty = function (property) {
        return (this.mode & S_IFMT) === property;
    };
    Dirent.prototype.isDirectory = function () {
        return this._checkModeProperty(S_IFDIR);
    };
    Dirent.prototype.isFile = function () {
        return this._checkModeProperty(S_IFREG);
    };
    Dirent.prototype.isBlockDevice = function () {
        return this._checkModeProperty(S_IFBLK);
    };
    Dirent.prototype.isCharacterDevice = function () {
        return this._checkModeProperty(S_IFCHR);
    };
    Dirent.prototype.isSymbolicLink = function () {
        return this._checkModeProperty(S_IFLNK);
    };
    Dirent.prototype.isFIFO = function () {
        return this._checkModeProperty(S_IFIFO);
    };
    Dirent.prototype.isSocket = function () {
        return this._checkModeProperty(S_IFSOCK);
    };
    return Dirent;
}();
exports.Dirent = Dirent;
exports.default = Dirent;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(11);
var errors = __webpack_require__(18);
exports.ENCODING_UTF8 = 'utf8';
function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);
}
exports.assertEncoding = assertEncoding;
function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports.ENCODING_UTF8) return str; // UTF-8
    if (encoding === 'buffer') return new buffer_1.Buffer(str); // `buffer` encoding
    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
}
exports.strToEncoding = strToEncoding;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var kCode = typeof Symbol === 'undefined' ? '_kCode' : Symbol('code');
var messages = {}; // new Map();
// Lazily loaded
var assert = null;
var util = null;
function makeNodeError(Base) {
    return (/** @class */function (_super) {
            __extends(NodeError, _super);
            function NodeError(key) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _this = _super.call(this, message(key, args)) || this;
                _this.code = key;
                _this[kCode] = key;
                _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
                return _this;
            }
            return NodeError;
        }(Base)
    );
}
var AssertionError = /** @class */function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(options) {
        var _this = this;
        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || options === null) {
            throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');
        }
        if (options.message) {
            _this = _super.call(this, options.message) || this;
        } else {
            if (util === null) {
                util = __webpack_require__(7);
            }
            _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = 'AssertionError [ERR_ASSERTION]';
        _this.code = 'ERR_ASSERTION';
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
    }
    return AssertionError;
}(global.Error);
exports.AssertionError = AssertionError;
function message(key, args) {
    if (assert === null) {
        assert = __webpack_require__(35);
    }
    assert.strictEqual(typeof key === "undefined" ? "undefined" : _typeof(key), 'string');
    // const msg = messages.get(key);
    var msg = messages[key];
    assert(msg, "An invalid error message key was used: " + key + ".");
    var fmt;
    if (typeof msg === 'function') {
        fmt = msg;
    } else {
        if (util === null) {
            util = __webpack_require__(7);
        }
        fmt = util.format;
        if (args === undefined || args.length === 0) return msg;
        args.unshift(msg);
    }
    return String(fmt.apply(null, args));
}
exports.message = message;
// Utility function for registering the error codes. Only used here. Exported
// *only* to allow for testing.
function E(sym, val) {
    messages[sym] = typeof val === 'function' ? val : String(val);
}
exports.E = E;
exports.Error = makeNodeError(global.Error);
exports.TypeError = makeNodeError(global.TypeError);
exports.RangeError = makeNodeError(global.RangeError);
// To declare an error message, use the E(sym, val) function above. The sym
// must be an upper case string. The val can be either a function or a string.
// The return value of the function must be a string.
// Examples:
// E('EXAMPLE_KEY1', 'This is the error value');
// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);
//
// Once an error code has been assigned, the code itself MUST NOT change and
// any given error code must never be reused to identify a different error.
//
// Any error code added here should also be added to the documentation
//
// Note: Please try to keep these in alphabetical order
E('ERR_ARG_NOT_ITERABLE', '%s must be iterable');
E('ERR_ASSERTION', '%s');
E('ERR_BUFFER_OUT_OF_BOUNDS', bufferOutOfBounds);
E('ERR_CHILD_CLOSED_BEFORE_REPLY', 'Child closed before reply received');
E('ERR_CONSOLE_WRITABLE_STREAM', 'Console expects a writable stream instance for %s');
E('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s');
E('ERR_DNS_SET_SERVERS_FAILED', function (err, servers) {
    return "c-ares failed to set servers: \"" + err + "\" [" + servers + "]";
});
E('ERR_FALSY_VALUE_REJECTION', 'Promise was rejected with falsy value');
E('ERR_ENCODING_NOT_SUPPORTED', function (enc) {
    return "The \"" + enc + "\" encoding is not supported";
});
E('ERR_ENCODING_INVALID_ENCODED_DATA', function (enc) {
    return "The encoded data was not valid for encoding " + enc;
});
E('ERR_HTTP_HEADERS_SENT', 'Cannot render headers after they are sent to the client');
E('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s');
E('ERR_HTTP_TRAILER_INVALID', 'Trailers are invalid with this transfer encoding');
E('ERR_INDEX_OUT_OF_RANGE', 'Index out of range');
E('ERR_INVALID_ARG_TYPE', invalidArgType);
E('ERR_INVALID_ARRAY_LENGTH', function (name, len, actual) {
    assert.strictEqual(typeof actual === "undefined" ? "undefined" : _typeof(actual), 'number');
    return "The array \"" + name + "\" (length " + actual + ") must be of length " + len + ".";
});
E('ERR_INVALID_BUFFER_SIZE', 'Buffer size must be a multiple of %s');
E('ERR_INVALID_CALLBACK', 'Callback must be a function');
E('ERR_INVALID_CHAR', 'Invalid character in %s');
E('ERR_INVALID_CURSOR_POS', 'Cannot set cursor row without setting its column');
E('ERR_INVALID_FD', '"fd" must be a positive integer: %s');
E('ERR_INVALID_FILE_URL_HOST', 'File URL host must be "localhost" or empty on %s');
E('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');
E('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');
E('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s');
E('ERR_INVALID_OPT_VALUE', function (name, value) {
    return "The value \"" + String(value) + "\" is invalid for option \"" + name + "\"";
});
E('ERR_INVALID_OPT_VALUE_ENCODING', function (value) {
    return "The value \"" + String(value) + "\" is invalid for option \"encoding\"";
});
E('ERR_INVALID_REPL_EVAL_CONFIG', 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
E('ERR_INVALID_SYNC_FORK_INPUT', 'Asynchronous forks do not support Buffer, Uint8Array or string input: %s');
E('ERR_INVALID_THIS', 'Value of "this" must be of type %s');
E('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');
E('ERR_INVALID_URL', 'Invalid URL: %s');
E('ERR_INVALID_URL_SCHEME', function (expected) {
    return "The URL must be " + oneOf(expected, 'scheme');
});
E('ERR_IPC_CHANNEL_CLOSED', 'Channel closed');
E('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');
E('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');
E('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');
E('ERR_MISSING_ARGS', missingArgs);
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
E('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function');
E('ERR_NAPI_CONS_PROTOTYPE_OBJECT', 'Constructor.prototype must be an object');
E('ERR_NO_CRYPTO', 'Node.js is not compiled with OpenSSL crypto support');
E('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported');
E('ERR_PARSE_HISTORY_DATA', 'Could not parse history data in %s');
E('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');
E('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');
E('ERR_SOCKET_BAD_TYPE', 'Bad socket type specified. Valid types are: udp4, udp6');
E('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');
E('ERR_SOCKET_CLOSED', 'Socket is closed');
E('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');
E('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');
E('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');
E('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode');
E('ERR_TLS_CERT_ALTNAME_INVALID', "Hostname/IP does not match certificate's altnames: %s");
E('ERR_TLS_DH_PARAM_SIZE', function (size) {
    return "DH parameter size " + size + " is less than 2048";
});
E('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout');
E('ERR_TLS_RENEGOTIATION_FAILED', 'Failed to renegotiate');
E('ERR_TLS_REQUIRED_SERVER_NAME', '"servername" is required parameter for Server.addContext');
E('ERR_TLS_SESSION_ATTACK', 'TSL session renegotiation attack detected');
E('ERR_TRANSFORM_ALREADY_TRANSFORMING', 'Calling transform done when still transforming');
E('ERR_TRANSFORM_WITH_LENGTH_0', 'Calling transform done when writableState.length != 0');
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s');
E('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s');
E('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');
E('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');
E('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' + 'See https://github.com/nodejs/node/wiki/Intl');
function invalidArgType(name, expected, actual) {
    assert(name, 'name is required');
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (expected.includes('not ')) {
        determiner = 'must not be';
        expected = expected.split('not ')[1];
    } else {
        determiner = 'must be';
    }
    var msg;
    if (Array.isArray(name)) {
        var names = name.map(function (val) {
            return "\"" + val + "\"";
        }).join(', ');
        msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, 'type');
    } else if (name.includes(' argument')) {
        // for the case like 'first argument'
        msg = "The " + name + " " + determiner + " " + oneOf(expected, 'type');
    } else {
        var type = name.includes('.') ? 'property' : 'argument';
        msg = "The \"" + name + "\" " + type + " " + determiner + " " + oneOf(expected, 'type');
    }
    // if actual value received, output it
    if (arguments.length >= 3) {
        msg += ". Received type " + (actual !== null ? typeof actual === "undefined" ? "undefined" : _typeof(actual) : 'null');
    }
    return msg;
}
function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    assert(args.length > 0, 'At least one arg needs to be specified');
    var msg = 'The ';
    var len = args.length;
    args = args.map(function (a) {
        return "\"" + a + "\"";
    });
    switch (len) {
        case 1:
            msg += args[0] + " argument";
            break;
        case 2:
            msg += args[0] + " and " + args[1] + " arguments";
            break;
        default:
            msg += args.slice(0, len - 1).join(', ');
            msg += ", and " + args[len - 1] + " arguments";
            break;
    }
    return msg + " must be specified";
}
function oneOf(expected, thing) {
    assert(expected, 'expected is required');
    assert(typeof thing === 'string', 'thing is required');
    if (Array.isArray(expected)) {
        var len = expected.length;
        assert(len > 0, 'At least one expected value needs to be specified');
        // tslint:disable-next-line
        expected = expected.map(function (i) {
            return String(i);
        });
        if (len > 2) {
            return "one of " + thing + " " + expected.slice(0, len - 1).join(', ') + ", or " + expected[len - 1];
        } else if (len === 2) {
            return "one of " + thing + " " + expected[0] + " or " + expected[1];
        } else {
            return "of " + thing + " " + expected[0];
        }
    } else {
        return "of " + thing + " " + String(expected);
    }
}
function bufferOutOfBounds(name, isWriting) {
    if (isWriting) {
        return 'Attempt to write outside buffer bounds';
    } else {
        return "\"" + name + "\" is outside of buffer bounds";
    }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
// Here we mock the global `process` variable in case we are not in Node's environment.

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Looks to return a `process` object, if one is available.
 *
 * The global `process` is returned if defined;
 * otherwise `require('process')` is attempted.
 *
 * If that fails, `undefined` is returned.
 *
 * @return {IProcess | undefined}
 */
var maybeReturnProcess = function maybeReturnProcess() {
    if (typeof process !== 'undefined') {
        return process;
    }
    try {
        return __webpack_require__(1);
    } catch (_a) {
        return undefined;
    }
};
function createProcess() {
    var p = maybeReturnProcess() || {};
    if (!p.getuid) p.getuid = function () {
        return 0;
    };
    if (!p.getgid) p.getgid = function () {
        return 0;
    };
    if (!p.cwd) p.cwd = function () {
        return '/';
    };
    if (!p.nextTick) p.nextTick = __webpack_require__(20).default;
    if (!p.emitWarning) p.emitWarning = function (message, type) {
        // tslint:disable-next-line:no-console
        console.warn("" + type + (type ? ': ' : '') + message);
    };
    if (!p.env) p.env = {};
    return p;
}
exports.createProcess = createProcess;
exports.default = createProcess();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

Object.defineProperty(exports, "__esModule", { value: true });
var _setImmediate;
if (typeof setImmediate === 'function') _setImmediate = setImmediate.bind(global);else _setImmediate = setTimeout.bind(global);
exports.default = _setImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).setImmediate, __webpack_require__(0)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(40);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(8);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(17);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(5).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(23);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(9).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(43);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(44);
var destroyImpl = __webpack_require__(24);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(2);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(25).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(2);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(25).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(5).EventEmitter;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(8);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(9).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(2);

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 27 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _fs = __webpack_require__(29);

(0, _fs.writeFileSync)('/text.txt', 'Hello world!');
console.log((0, _fs.readFileSync)('/text.txt', 'utf8'));
console.log(_fs.vol.toJSON());

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Stats_1 = __webpack_require__(10);
var Dirent_1 = __webpack_require__(15);
var volume_1 = __webpack_require__(37);
var _a = __webpack_require__(62),
    fsSyncMethods = _a.fsSyncMethods,
    fsAsyncMethods = _a.fsAsyncMethods;
var constants_1 = __webpack_require__(4);
var F_OK = constants_1.constants.F_OK,
    R_OK = constants_1.constants.R_OK,
    W_OK = constants_1.constants.W_OK,
    X_OK = constants_1.constants.X_OK;
exports.Volume = volume_1.Volume;
// Default volume.
exports.vol = new volume_1.Volume();
function createFsFromVolume(vol) {
    var fs = { F_OK: F_OK, R_OK: R_OK, W_OK: W_OK, X_OK: X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
    // Bind FS methods.
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
    }
    for (var _a = 0, fsAsyncMethods_1 = fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
        var method = fsAsyncMethods_1[_a];
        if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
    }
    fs.StatWatcher = vol.StatWatcher;
    fs.FSWatcher = vol.FSWatcher;
    fs.WriteStream = vol.WriteStream;
    fs.ReadStream = vol.ReadStream;
    fs.promises = vol.promises;
    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs;
}
exports.createFsFromVolume = createFsFromVolume;
exports.fs = createFsFromVolume(exports.vol);
module.exports = __assign(__assign({}, module.exports), exports.fs);
module.exports.semantic = true;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof BigInt === 'function') exports.default = BigInt;else exports.default = function BigIntNotSupported() {
  throw new Error('BigInt is not supported in this environment.');
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function isBuffer(arg) {
  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var objectAssign = __webpack_require__(36);

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(7);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

    // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

    // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) {
    return strict ? actual === expected : actual == expected;

    // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

    // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var pathModule = __webpack_require__(38);
var node_1 = __webpack_require__(39);
var Stats_1 = __webpack_require__(10);
var Dirent_1 = __webpack_require__(15);
var buffer_1 = __webpack_require__(11);
var setImmediate_1 = __webpack_require__(20);
var process_1 = __webpack_require__(19);
var setTimeoutUnref_1 = __webpack_require__(41);
var stream_1 = __webpack_require__(42);
var constants_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var encoding_1 = __webpack_require__(16);
var errors = __webpack_require__(18);
var extend = __webpack_require__(52);
var util = __webpack_require__(7);
var promises_1 = __webpack_require__(53);
var resolveCrossPlatform = pathModule.resolve;
var O_RDONLY = constants_1.constants.O_RDONLY,
    O_WRONLY = constants_1.constants.O_WRONLY,
    O_RDWR = constants_1.constants.O_RDWR,
    O_CREAT = constants_1.constants.O_CREAT,
    O_EXCL = constants_1.constants.O_EXCL,
    O_TRUNC = constants_1.constants.O_TRUNC,
    O_APPEND = constants_1.constants.O_APPEND,
    O_SYNC = constants_1.constants.O_SYNC,
    F_OK = constants_1.constants.F_OK,
    COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL,
    COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
var sep;
var relative;
if (pathModule.posix) {
    var posix = pathModule.posix;
    sep = posix.sep;
    relative = posix.relative;
} else {
    sep = pathModule.sep;
    relative = pathModule.relative;
}
var isWin = process_1.default.platform === 'win32';
var kMinPoolSpace = 128;
// const kMaxLength = require('buffer').kMaxLength;
// ---------------------------------------- Error messages
// TODO: Use `internal/errors.js` in the future.
var ERRSTR = {
    PATH_STR: 'path must be a string or Buffer',
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: 'fd must be a file descriptor',
    MODE_INT: 'mode must be an int',
    CB: 'callback must be a function',
    UID: 'uid must be an unsigned int',
    GID: 'gid must be an unsigned int',
    LEN: 'len must be an integer',
    ATIME: 'atime must be an integer',
    MTIME: 'mtime must be an integer',
    PREFIX: 'filename prefix is required',
    BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',
    OFFSET: 'offset must be an integer',
    LENGTH: 'length must be an integer',
    POSITION: 'position must be an integer'
};
var ERRSTR_OPTS = function ERRSTR_OPTS(tipeof) {
    return "Expected options to be either an object or a string, but got " + tipeof + " instead";
};
// const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;
var ENOENT = 'ENOENT';
var EBADF = 'EBADF';
var EINVAL = 'EINVAL';
var EPERM = 'EPERM';
var EPROTO = 'EPROTO';
var EEXIST = 'EEXIST';
var ENOTDIR = 'ENOTDIR';
var EMFILE = 'EMFILE';
var EACCES = 'EACCES';
var EISDIR = 'EISDIR';
var ENOTEMPTY = 'ENOTEMPTY';
var ENOSYS = 'ENOSYS';
function formatError(errorCode, func, path, path2) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    var pathFormatted = '';
    if (path) pathFormatted = " '" + path + "'";
    if (path2) pathFormatted += " -> '" + path2 + "'";
    switch (errorCode) {
        case ENOENT:
            return "ENOENT: no such file or directory, " + func + pathFormatted;
        case EBADF:
            return "EBADF: bad file descriptor, " + func + pathFormatted;
        case EINVAL:
            return "EINVAL: invalid argument, " + func + pathFormatted;
        case EPERM:
            return "EPERM: operation not permitted, " + func + pathFormatted;
        case EPROTO:
            return "EPROTO: protocol error, " + func + pathFormatted;
        case EEXIST:
            return "EEXIST: file already exists, " + func + pathFormatted;
        case ENOTDIR:
            return "ENOTDIR: not a directory, " + func + pathFormatted;
        case EISDIR:
            return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
        case EACCES:
            return "EACCES: permission denied, " + func + pathFormatted;
        case ENOTEMPTY:
            return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
        case EMFILE:
            return "EMFILE: too many open files, " + func + pathFormatted;
        case ENOSYS:
            return "ENOSYS: function not implemented, " + func + pathFormatted;
        default:
            return errorCode + ": error occurred, " + func + pathFormatted;
    }
}
function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    if (Constructor === void 0) {
        Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    return error;
}
function throwError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    if (Constructor === void 0) {
        Constructor = Error;
    }
    throw createError(errorCode, func, path, path2, Constructor);
}
// ---------------------------------------- Flags
// List of file `flags` as defined by Node.
var FLAGS;
(function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r"] = O_RDONLY] = "r";
    // Open file for reading and writing. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r+"] = O_RDWR] = "r+";
    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.
    FLAGS[FLAGS["rs"] = O_RDONLY | O_SYNC] = "rs";
    FLAGS[FLAGS["sr"] = FLAGS.rs] = "sr";
    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.
    FLAGS[FLAGS["rs+"] = O_RDWR | O_SYNC] = "rs+";
    FLAGS[FLAGS["sr+"] = FLAGS['rs+']] = "sr+";
    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
    // Like 'w' but fails if path exists.
    FLAGS[FLAGS["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
    FLAGS[FLAGS["xw"] = FLAGS.wx] = "xw";
    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
    // Like 'w+' but fails if path exists.
    FLAGS[FLAGS["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
    FLAGS[FLAGS["xw+"] = FLAGS['wx+']] = "xw+";
    // Open file for appending. The file is created if it does not exist.
    FLAGS[FLAGS["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
    // Like 'a' but fails if path exists.
    FLAGS[FLAGS["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
    FLAGS[FLAGS["xa"] = FLAGS.ax] = "xa";
    // Open file for reading and appending. The file is created if it does not exist.
    FLAGS[FLAGS["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
    // Like 'a+' but fails if path exists.
    FLAGS[FLAGS["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
    FLAGS[FLAGS["xa+"] = FLAGS['ax+']] = "xa+";
})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
function flagsToNumber(flags) {
    if (typeof flags === 'number') return flags;
    if (typeof flags === 'string') {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== 'undefined') return flagsNum;
    }
    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));
    throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);
}
exports.flagsToNumber = flagsToNumber;
// ---------------------------------------- Options
function getOptions(defaults, options) {
    var opts;
    if (!options) return defaults;else {
        var tipeof = typeof options === "undefined" ? "undefined" : _typeof(options);
        switch (tipeof) {
            case 'string':
                opts = extend({}, defaults, { encoding: options });
                break;
            case 'object':
                opts = extend({}, defaults, options);
                break;
            default:
                throw TypeError(ERRSTR_OPTS(tipeof));
        }
    }
    if (opts.encoding !== 'buffer') encoding_1.assertEncoding(opts.encoding);
    return opts;
}
function optsGenerator(defaults) {
    return function (options) {
        return getOptions(defaults, options);
    };
}
function validateCallback(callback) {
    if (typeof callback !== 'function') throw TypeError(ERRSTR.CB);
    return callback;
}
function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
        return typeof options === 'function' ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
}
var optsDefaults = {
    encoding: 'utf8'
};
var getDefaultOpts = optsGenerator(optsDefaults);
var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
var readFileOptsDefaults = {
    flag: 'r'
};
var getReadFileOptions = optsGenerator(readFileOptsDefaults);
var writeFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* DEFAULT */
    , flag: FLAGS[FLAGS.w]
};
var getWriteFileOptions = optsGenerator(writeFileDefaults);
var appendFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* DEFAULT */
    , flag: FLAGS[FLAGS.a]
};
var getAppendFileOpts = optsGenerator(appendFileDefaults);
var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
var realpathDefaults = optsDefaults;
var getRealpathOptions = optsGenerator(realpathDefaults);
var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
var mkdirDefaults = {
    mode: 511 /* DIR */
    , recursive: false
};
var getMkdirOptions = function getMkdirOptions(options) {
    if (typeof options === 'number') return extend({}, mkdirDefaults, { mode: options });
    return extend({}, mkdirDefaults, options);
};
var readdirDefaults = {
    encoding: 'utf8',
    withFileTypes: false
};
var getReaddirOptions = optsGenerator(readdirDefaults);
var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
var statDefaults = {
    bigint: false
};
var getStatOptions = function getStatOptions(options) {
    if (options === void 0) {
        options = {};
    }
    return extend({}, statDefaults, options);
};
var getStatOptsAndCb = function getStatOptsAndCb(options, callback) {
    return typeof options === 'function' ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
};
// ---------------------------------------- Utility functions
function getPathFromURLPosix(url) {
    if (url.hostname !== '') {
        throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === '%') {
            var third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === '2' && third === 102) {
                throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');
            }
        }
    }
    return decodeURIComponent(pathname);
}
function pathToFilename(path) {
    if (typeof path !== 'string' && !buffer_1.Buffer.isBuffer(path)) {
        try {
            if (!(path instanceof __webpack_require__(54).URL)) throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
            throw new TypeError(ERRSTR.PATH_STR);
        }
        path = getPathFromURLPosix(path);
    }
    var pathString = String(path);
    nullCheck(pathString);
    // return slash(pathString);
    return pathString;
}
exports.pathToFilename = pathToFilename;
var resolve = function resolve(filename, base) {
    if (base === void 0) {
        base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
};
if (isWin) {
    var _resolve_1 = resolve;
    var unixify_1 = __webpack_require__(61).unixify;
    resolve = function resolve(filename, base) {
        return unixify_1(_resolve_1(filename, base));
    };
}
function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep);
}
exports.filenameToSteps = filenameToSteps;
function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
}
exports.pathToSteps = pathToSteps;
function dataToStr(data, encoding) {
    if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return buffer_1.bufferFrom(data).toString(encoding);else return String(data);
}
exports.dataToStr = dataToStr;
function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return buffer_1.bufferFrom(data);else return buffer_1.bufferFrom(String(data), encoding);
}
exports.dataToBuffer = dataToBuffer;
function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === 'buffer') return buffer;else return buffer.toString(encoding);
}
exports.bufferToEncoding = bufferToEncoding;
function nullCheck(path, callback) {
    if (('' + path).indexOf("\0") !== -1) {
        var er = new Error('Path must be a string without null bytes');
        er.code = ENOENT;
        if (typeof callback !== 'function') throw er;
        process_1.default.nextTick(callback, er);
        return false;
    }
    return true;
}
function _modeToNumber(mode, def) {
    if (typeof mode === 'number') return mode;
    if (typeof mode === 'string') return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return undefined;
}
function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== 'number' || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
}
function isFd(path) {
    return path >>> 0 === path;
}
function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
}
// converts Date or number to a fractional UNIX timestamp
function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === 'string' && +time == time) {
        return +time;
    }
    if (time instanceof Date) {
        return time.getTime() / 1000;
    }
    if (isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        return time;
    }
    throw new Error('Cannot parse time: ' + time);
}
exports.toUnixTimestamp = toUnixTimestamp;
/**
 * Returns optional argument and callback
 * @param arg Argument or callback value
 * @param callback Callback or undefined
 * @param def Default argument value
 */
function getArgAndCb(arg, callback, def) {
    return typeof arg === 'function' ? [def, arg] : [arg, callback];
}
function validateUid(uid) {
    if (typeof uid !== 'number') throw TypeError(ERRSTR.UID);
}
function validateGid(gid) {
    if (typeof gid !== 'number') throw TypeError(ERRSTR.GID);
}
/**
 * `Volume` represents a file system.
 */
var Volume = /** @class */function () {
    function Volume(props) {
        if (props === void 0) {
            props = {};
        }
        // I-node number counter.
        this.ino = 0;
        // A mapping for i-node numbers to i-nodes (`Node`);
        this.inodes = {};
        // List of released i-node numbers, for reuse.
        this.releasedInos = [];
        // A mapping for file descriptors to `File`s.
        this.fds = {};
        // A list of reusable (opened and closed) file descriptors, that should be
        // used first before creating a new file descriptor.
        this.releasedFds = [];
        // Max number of open files.
        this.maxFiles = 10000;
        // Current number of open files.
        this.openFiles = 0;
        this.promisesApi = promises_1.default(this);
        this.statWatchers = {};
        this.props = extend({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self = this; // tslint:disable-line no-this-assignment
        this.StatWatcher = /** @class */function (_super) {
            __extends(StatWatcher, _super);
            function StatWatcher() {
                return _super.call(this, self) || this;
            }
            return StatWatcher;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = /** @class */function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spreadArrays([self], args)) || this;
            }
            return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = /** @class */function (_super) {
            __extends(class_2, _super);
            function class_2() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spreadArrays([self], args)) || this;
            }
            return class_2;
        }(_WriteStream);
        this.FSWatcher = /** @class */function (_super) {
            __extends(FSWatcher, _super);
            function FSWatcher() {
                return _super.call(this, self) || this;
            }
            return FSWatcher;
        }(FSWatcher);
        // root.setChild('.', root);
        // root.getNode().nlink++;
        // root.setChild('..', root);
        // root.getNode().nlink++;
        this.root = root;
    }
    Volume.fromJSON = function (json, cwd) {
        var vol = new Volume();
        vol.fromJSON(json, cwd);
        return vol;
    };
    Object.defineProperty(Volume.prototype, "promises", {
        get: function get() {
            if (this.promisesApi === null) throw new Error('Promise is not supported in this environment.');
            return this.promisesApi;
        },
        enumerable: true,
        configurable: true
    });
    Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
        if (isDirectory === void 0) {
            isDirectory = false;
        }
        return parent ? parent.createChild(name, this.createNode(isDirectory, perm)) : new this.props.Link(this, null, '');
    };
    Volume.prototype.deleteLink = function (link) {
        var parent = link.parent;
        if (parent) {
            parent.deleteChild(link);
            link.vol = null;
            link.parent = null;
            return true;
        }
        return false;
    };
    Volume.prototype.newInoNumber = function () {
        if (this.releasedInos.length) return this.releasedInos.pop();else {
            this.ino = (this.ino + 1) % 0xffffffff;
            return this.ino;
        }
    };
    Volume.prototype.newFdNumber = function () {
        return this.releasedFds.length ? this.releasedFds.pop() : Volume.fd--;
    };
    Volume.prototype.createNode = function (isDirectory, perm) {
        if (isDirectory === void 0) {
            isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory) node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
    };
    Volume.prototype.getNode = function (ino) {
        return this.inodes[ino];
    };
    Volume.prototype.deleteNode = function (node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
    };
    // Generates 6 character long random string, used by `mkdtemp`.
    Volume.prototype.genRndStr = function () {
        var str = (Math.random() + 1).toString(36).substr(2, 6);
        if (str.length === 6) return str;else return this.genRndStr();
    };
    // Returns a `Link` (hard link) referenced by path "split" into steps.
    Volume.prototype.getLink = function (steps) {
        return this.root.walk(steps);
    };
    // Just link `getLink`, but throws a correct user error, if link to found.
    Volume.prototype.getLinkOrThrow = function (filename, funcName) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link) throwError(ENOENT, funcName, filename);
        return link;
    };
    // Just like `getLink`, but also dereference/resolves symbolic links.
    Volume.prototype.getResolvedLink = function (filenameOrSteps) {
        var steps = typeof filenameOrSteps === 'string' ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link = this.root;
        var i = 0;
        while (i < steps.length) {
            var step = steps[i];
            link = link.getChild(step);
            if (!link) return null;
            var node = link.getNode();
            if (node.isSymlink()) {
                steps = node.symlink.concat(steps.slice(i + 1));
                link = this.root;
                i = 0;
                continue;
            }
            i++;
        }
        return link;
    };
    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
    Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
        var link = this.getResolvedLink(filename);
        if (!link) throwError(ENOENT, funcName, filename);
        return link;
    };
    Volume.prototype.resolveSymlinks = function (link) {
        // let node: Node = link.getNode();
        // while(link && node.isSymlink()) {
        //     link = this.getLink(node.symlink);
        //     if(!link) return null;
        //     node = link.getNode();
        // }
        // return link;
        return this.getResolvedLink(link.steps.slice(1));
    };
    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
    Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
        var link = this.getLinkOrThrow(filename, funcName);
        if (!link.getNode().isDirectory()) throwError(ENOTDIR, funcName, filename);
        return link;
    };
    // Get the immediate parent directory of the link.
    Volume.prototype.getLinkParent = function (steps) {
        return this.root.walk(steps, steps.length - 1);
    };
    Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link = this.getLinkParent(steps);
        if (!link) throwError(ENOENT, funcName, sep + steps.join(sep));
        if (!link.getNode().isDirectory()) throwError(ENOTDIR, funcName, sep + steps.join(sep));
        return link;
    };
    Volume.prototype.getFileByFd = function (fd) {
        return this.fds[String(fd)];
    };
    Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
        if (!isFd(fd)) throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file) throwError(EBADF, funcName);
        return file;
    };
    Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
        if (typeof id === 'number') {
            var file = this.getFileByFd(id);
            if (!file) throw Error('File nto found');
            return file.node;
        } else {
            var steps = pathToSteps(id);
            var link = this.getLink(steps);
            if (link) return link.getNode();
            // Try creating a node if not found.
            if (flags & O_CREAT) {
                var dirLink = this.getLinkParent(steps);
                if (dirLink) {
                    var name_1 = steps[steps.length - 1];
                    link = this.createLink(dirLink, name_1, false, perm);
                    return link.getNode();
                }
            }
            throwError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
        }
    };
    Volume.prototype.wrapAsync = function (method, args, callback) {
        var _this = this;
        validateCallback(callback);
        setImmediate_1.default(function () {
            try {
                callback(null, method.apply(_this, args));
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype._toJSON = function (link, json, path) {
        var _a;
        if (link === void 0) {
            link = this.root;
        }
        if (json === void 0) {
            json = {};
        }
        var isEmpty = true;
        var children = link.children;
        if (link.getNode().isFile()) {
            children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
            link = link.parent;
        }
        for (var name_2 in children) {
            isEmpty = false;
            var child = link.getChild(name_2);
            var node = child.getNode();
            if (node.isFile()) {
                var filename = child.getPath();
                if (path) filename = relative(path, filename);
                json[filename] = node.getString();
            } else if (node.isDirectory()) {
                this._toJSON(child, json, path);
            }
        }
        var dirPath = link.getPath();
        if (path) dirPath = relative(path, dirPath);
        if (dirPath && isEmpty) {
            json[dirPath] = null;
        }
        return json;
    };
    Volume.prototype.toJSON = function (paths, json, isRelative) {
        if (json === void 0) {
            json = {};
        }
        if (isRelative === void 0) {
            isRelative = false;
        }
        var links = [];
        if (paths) {
            if (!(paths instanceof Array)) paths = [paths];
            for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
                var path = paths_1[_i];
                var filename = pathToFilename(path);
                var link = this.getResolvedLink(filename);
                if (!link) continue;
                links.push(link);
            }
        } else {
            links.push(this.root);
        }
        if (!links.length) return json;
        for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
            var link = links_1[_a];
            this._toJSON(link, json, isRelative ? link.getPath() : '');
        }
        return json;
    };
    // fromJSON(json: {[filename: string]: string}, cwd: string = '/') {
    Volume.prototype.fromJSON = function (json, cwd) {
        if (cwd === void 0) {
            cwd = process_1.default.cwd();
        }
        for (var filename in json) {
            var data = json[filename];
            if (typeof data === 'string') {
                filename = resolve(filename, cwd);
                var steps = filenameToSteps(filename);
                if (steps.length > 1) {
                    var dirname = sep + steps.slice(0, steps.length - 1).join(sep);
                    this.mkdirpBase(dirname, 511 /* DIR */);
                }
                this.writeFileSync(filename, data);
            } else {
                this.mkdirpBase(filename, 511 /* DIR */);
            }
        }
    };
    Volume.prototype.reset = function () {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
    };
    // Legacy interface
    Volume.prototype.mountSync = function (mountpoint, json) {
        this.fromJSON(json, mountpoint);
    };
    Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
            // Too many open files.
            throw createError(EMFILE, 'open', link.getPath());
        }
        // Resolve symlinks.
        var realLink = link;
        if (resolveSymlinks) realLink = this.resolveSymlinks(link);
        if (!realLink) throwError(ENOENT, 'open', link.getPath());
        var node = realLink.getNode();
        if (node.isDirectory() && flagsNum !== FLAGS.r) throwError(EISDIR, 'open', link.getPath());
        // Check node permissions
        if (!(flagsNum & O_WRONLY)) {
            if (!node.canRead()) {
                throwError(EACCES, 'open', link.getPath());
            }
        }
        if (flagsNum & O_RDWR) {}
        var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC) file.truncate();
        return file;
    };
    Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        // Try creating a new file, if it does not exist.
        if (!link && flagsNum & O_CREAT) {
            // const dirLink: Link = this.getLinkParent(steps);
            var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
            // if(!dirLink) throwError(ENOENT, 'open', filename);
            if (!dirLink) throwError(ENOENT, 'open', sep + steps.join(sep));
            if (flagsNum & O_CREAT && typeof modeNum === 'number') {
                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
            }
        }
        if (link) return this.openLink(link, flagsNum, resolveSymlinks);
        throwError(ENOENT, 'open', filename);
    };
    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file) throwError(ENOENT, 'open', filename);
        return file.fd;
    };
    Volume.prototype.openSync = function (path, flags, mode) {
        if (mode === void 0) {
            mode = 438 /* DEFAULT */;
        }
        // Validate (1) mode; (2) path; (3) flags - in that order.
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume.prototype.open = function (path, flags, a, b) {
        var mode = a;
        var callback = b;
        if (typeof a === 'function') {
            mode = 438 /* DEFAULT */;
            callback = a;
        }
        mode = mode || 438 /* DEFAULT */;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume.prototype.closeFile = function (file) {
        if (!this.fds[file.fd]) return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
    };
    Volume.prototype.closeSync = function (fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, 'close');
        this.closeFile(file);
    };
    Volume.prototype.close = function (fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
        if (typeof id === 'number') {
            var file = this.fds[id];
            if (!file) throw createError(ENOENT);
            return file;
        } else {
            return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
    };
    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer, Number(offset), Number(length), position);
    };
    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer, offset, length, position);
    };
    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        // This `if` branch is from Node.js
        if (length === 0) {
            return process_1.default.nextTick(function () {
                if (callback) callback(null, 0, buffer);
            });
        }
        setImmediate_1.default(function () {
            try {
                var bytes = _this.readBase(fd, buffer, offset, length, position);
                callback(null, bytes, buffer);
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === 'number';
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd) fd = id;else {
            var filename = pathToFilename(id);
            var steps = filenameToSteps(filename);
            var link = this.getResolvedLink(steps);
            if (link) {
                var node = link.getNode();
                if (node.isDirectory()) throwError(EISDIR, 'open', link.getPath());
            }
            fd = this.openSync(id, flagsNum);
        }
        try {
            result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
            if (!userOwnsFd) {
                this.closeSync(fd);
            }
        }
        return result;
    };
    Volume.prototype.readFileSync = function (file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume.prototype.readFile = function (id, a, b) {
        var _a = optsAndCbGenerator(getReadFileOptions)(a, b),
            opts = _a[0],
            callback = _a[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, 'write');
        return file.write(buf, offset, length, position);
    };
    Volume.prototype.writeSync = function (fd, a, b, c, d) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer = typeof a !== 'string';
        if (isBuffer) {
            offset = b | 0;
            length = c;
            position = d;
        } else {
            position = b;
            encoding = c;
        }
        var buf = dataToBuffer(a, encoding);
        if (isBuffer) {
            if (typeof length === 'undefined') {
                length = buf.length;
            }
        } else {
            offset = 0;
            length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
    };
    Volume.prototype.write = function (fd, a, b, c, d, e) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a === "undefined" ? "undefined" : _typeof(a);
        var tipb = typeof b === "undefined" ? "undefined" : _typeof(b);
        var tipc = typeof c === "undefined" ? "undefined" : _typeof(c);
        var tipd = typeof d === "undefined" ? "undefined" : _typeof(d);
        if (tipa !== 'string') {
            if (tipb === 'function') {
                callback = b;
            } else if (tipc === 'function') {
                offset = b | 0;
                callback = c;
            } else if (tipd === 'function') {
                offset = b | 0;
                length = c;
                callback = d;
            } else {
                offset = b | 0;
                length = c;
                position = d;
                callback = e;
            }
        } else {
            if (tipb === 'function') {
                callback = b;
            } else if (tipc === 'function') {
                position = b;
                callback = c;
            } else if (tipd === 'function') {
                position = b;
                encoding = c;
                callback = d;
            }
        }
        var buf = dataToBuffer(a, encoding);
        if (tipa !== 'string') {
            if (typeof length === 'undefined') length = buf.length;
        } else {
            offset = 0;
            length = buf.length;
        }
        validateCallback(callback);
        setImmediate_1.default(function () {
            try {
                var bytes = _this.writeBase(fd, buf, offset, length, position);
                if (tipa !== 'string') {
                    callback(null, bytes, buf);
                } else {
                    callback(null, bytes, a);
                }
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
        // console.log('writeFileBase', id, buf, flagsNum, modeNum);
        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
        // node.setBuffer(buf);
        var isUserFd = typeof id === 'number';
        var fd;
        if (isUserFd) fd = id;else {
            fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
            // fd = this.openSync(id as TFilePath, flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? null : 0;
        try {
            while (length > 0) {
                var written = this.writeSync(fd, buf, offset, length, position);
                offset += written;
                length -= written;
                if (position !== null) position += written;
            }
        } finally {
            if (!isUserFd) this.closeSync(fd);
        }
    };
    Volume.prototype.writeFileSync = function (id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume.prototype.writeFile = function (id, data, a, b) {
        var options = a;
        var callback = b;
        if (typeof a === 'function') {
            options = writeFileDefaults;
            callback = a;
        }
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], callback);
    };
    Volume.prototype.linkBase = function (filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1) throwError(ENOENT, 'link', filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        // Check new link directory exists.
        var dir2 = this.getLinkParent(steps2);
        if (!dir2) throwError(ENOENT, 'link', filename1, filename2);
        var name = steps2[steps2.length - 1];
        // Check if new file already exists.
        if (dir2.getChild(name)) throwError(EEXIST, 'link', filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name, node);
    };
    Volume.prototype.copyFileBase = function (src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
                throwError(EEXIST, 'copyFile', src, dest);
            }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
            throwError(ENOSYS, 'copyFile', src, dest);
        }
        this.writeFileBase(dest, buf, FLAGS.w, 438 /* DEFAULT */);
    };
    Volume.prototype.copyFileSync = function (src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, flags | 0);
    };
    Volume.prototype.copyFile = function (src, dest, a, b) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a === 'function') {
            flags = 0;
            callback = a;
        } else {
            flags = a;
            callback = b;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume.prototype.linkSync = function (existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume.prototype.link = function (existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume.prototype.unlinkBase = function (filename) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link) throwError(ENOENT, 'unlink', filename);
        // TODO: Check if it is file, dir, other...
        if (link.length) throw Error('Dir not empty...');
        this.deleteLink(link);
        var node = link.getNode();
        node.nlink--;
        // When all hard links to i-node are deleted, remove the i-node, too.
        if (node.nlink <= 0) {
            this.deleteNode(node);
        }
    };
    Volume.prototype.unlinkSync = function (path) {
        var filename = pathToFilename(path);
        this.unlinkBase(filename);
    };
    Volume.prototype.unlink = function (path, callback) {
        var filename = pathToFilename(path);
        this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        // Check if directory exists, where we about to create a symlink.
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink) throwError(ENOENT, 'symlink', targetFilename, pathFilename);
        var name = pathSteps[pathSteps.length - 1];
        // Check if new file already exists.
        if (dirLink.getChild(name)) throwError(EEXIST, 'symlink', targetFilename, pathFilename);
        // Create symlink.
        var symlink = dirLink.createChild(name);
        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink;
    };
    // `type` argument works only on Windows.
    Volume.prototype.symlinkSync = function (target, path, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.symlinkBase(targetFilename, pathFilename);
    };
    Volume.prototype.symlink = function (target, path, a, b) {
        var _a = getArgAndCb(a, b),
            type = _a[0],
            callback = _a[1];
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume.prototype.realpathBase = function (filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink) throwError(ENOENT, 'realpath', filename);
        return encoding_1.strToEncoding(realLink.getPath(), encoding);
    };
    Volume.prototype.realpathSync = function (path, options) {
        return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };
    Volume.prototype.realpath = function (path, a, b) {
        var _a = getRealpathOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume.prototype.lstatBase = function (filename, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var link = this.getLink(filenameToSteps(filename));
        if (!link) throwError(ENOENT, 'lstat', filename);
        return Stats_1.default.build(link.getNode(), bigint);
    };
    Volume.prototype.lstatSync = function (path, options) {
        return this.lstatBase(pathToFilename(path), getStatOptions(options).bigint);
    };
    Volume.prototype.lstat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path), opts.bigint], callback);
    };
    Volume.prototype.statBase = function (filename, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var link = this.getResolvedLink(filenameToSteps(filename));
        if (!link) throwError(ENOENT, 'stat', filename);
        return Stats_1.default.build(link.getNode(), bigint);
    };
    Volume.prototype.statSync = function (path, options) {
        return this.statBase(pathToFilename(path), getStatOptions(options).bigint);
    };
    Volume.prototype.stat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.statBase, [pathToFilename(path), opts.bigint], callback);
    };
    Volume.prototype.fstatBase = function (fd, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file) throwError(EBADF, 'fstat');
        return Stats_1.default.build(file.node, bigint);
    };
    Volume.prototype.fstatSync = function (fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume.prototype.fstat = function (fd, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
        var link = this.getLink(filenameToSteps(oldPathFilename));
        if (!link) throwError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Check if it is directory, if non-empty, we cannot move it, right?
        var newPathSteps = filenameToSteps(newPathFilename);
        // Check directory exists for the new location.
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink) throwError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Also treat cases with directories and symbolic links.
        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
        // Remove hard link from old folder.
        var oldLinkParent = link.parent;
        if (oldLinkParent) {
            oldLinkParent.deleteChild(link);
        }
        // Rename should overwrite the new path, if that exists.
        var name = newPathSteps[newPathSteps.length - 1];
        link.steps = __spreadArrays(newPathDirLink.steps, [name]);
        newPathDirLink.setChild(link.getName(), link);
    };
    Volume.prototype.renameSync = function (oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume.prototype.rename = function (oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume.prototype.existsBase = function (filename) {
        return !!this.statBase(filename);
    };
    Volume.prototype.existsSync = function (path) {
        try {
            return this.existsBase(pathToFilename(path));
        } catch (err) {
            return false;
        }
    };
    Volume.prototype.exists = function (path, callback) {
        var _this = this;
        var filename = pathToFilename(path);
        if (typeof callback !== 'function') throw Error(ERRSTR.CB);
        setImmediate_1.default(function () {
            try {
                callback(_this.existsBase(filename));
            } catch (err) {
                callback(false);
            }
        });
    };
    Volume.prototype.accessBase = function (filename, mode) {
        var link = this.getLinkOrThrow(filename, 'access');
        // TODO: Verify permissions
    };
    Volume.prototype.accessSync = function (path, mode) {
        if (mode === void 0) {
            mode = F_OK;
        }
        var filename = pathToFilename(path);
        mode = mode | 0;
        this.accessBase(filename, mode);
    };
    Volume.prototype.access = function (path, a, b) {
        var mode = a;
        var callback = b;
        if (typeof mode === 'function') {
            mode = F_OK;
            callback = a;
        }
        var filename = pathToFilename(path);
        mode = mode | 0;
        this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume.prototype.appendFileSync = function (id, data, options) {
        if (options === void 0) {
            options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id)) opts.flag = 'a';
        this.writeFileSync(id, data, opts);
    };
    Volume.prototype.appendFile = function (id, data, a, b) {
        var _a = getAppendFileOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id)) opts.flag = 'a';
        this.writeFile(id, data, opts, callback);
    };
    Volume.prototype.readdirBase = function (filename, options) {
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);
        if (!link) throwError(ENOENT, 'readdir', filename);
        var node = link.getNode();
        if (!node.isDirectory()) throwError(ENOTDIR, 'scandir', filename);
        if (options.withFileTypes) {
            var list_1 = [];
            for (var name_3 in link.children) {
                list_1.push(Dirent_1.default.build(link.children[name_3], options.encoding));
            }
            if (!isWin && options.encoding !== 'buffer') list_1.sort(function (a, b) {
                if (a.name < b.name) return -1;
                if (a.name > b.name) return 1;
                return 0;
            });
            return list_1;
        }
        var list = [];
        for (var name_4 in link.children) {
            list.push(encoding_1.strToEncoding(name_4, options.encoding));
        }
        if (!isWin && options.encoding !== 'buffer') list.sort();
        return list;
    };
    Volume.prototype.readdirSync = function (path, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path);
        return this.readdirBase(filename, opts);
    };
    Volume.prototype.readdir = function (path, a, b) {
        var _a = getReaddirOptsAndCb(a, b),
            options = _a[0],
            callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume.prototype.readlinkBase = function (filename, encoding) {
        var link = this.getLinkOrThrow(filename, 'readlink');
        var node = link.getNode();
        if (!node.isSymlink()) throwError(EINVAL, 'readlink', filename);
        var str = sep + node.symlink.join(sep);
        return encoding_1.strToEncoding(str, encoding);
    };
    Volume.prototype.readlinkSync = function (path, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path);
        return this.readlinkBase(filename, opts.encoding);
    };
    Volume.prototype.readlink = function (path, a, b) {
        var _a = getDefaultOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume.prototype.fsyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fsync');
    };
    Volume.prototype.fsyncSync = function (fd) {
        this.fsyncBase(fd);
    };
    Volume.prototype.fsync = function (fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume.prototype.fdatasyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fdatasync');
    };
    Volume.prototype.fdatasyncSync = function (fd) {
        this.fdatasyncBase(fd);
    };
    Volume.prototype.fdatasync = function (fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume.prototype.ftruncateBase = function (fd, len) {
        var file = this.getFileByFdOrThrow(fd, 'ftruncate');
        file.truncate(len);
    };
    Volume.prototype.ftruncateSync = function (fd, len) {
        this.ftruncateBase(fd, len);
    };
    Volume.prototype.ftruncate = function (fd, a, b) {
        var _a = getArgAndCb(a, b),
            len = _a[0],
            callback = _a[1];
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume.prototype.truncateBase = function (path, len) {
        var fd = this.openSync(path, 'r+');
        try {
            this.ftruncateSync(fd, len);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.truncateSync = function (id, len) {
        if (isFd(id)) return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
    };
    Volume.prototype.truncate = function (id, a, b) {
        if (isFd(id)) return this.ftruncate(id, a, b);
        var _a = getArgAndCb(a, b, 0),
            len = _a[0],
            callback = _a[1];
        this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume.prototype.futimesBase = function (fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, 'futimes');
        var node = file.node;
        node.atime = new Date(atime * 1000);
        node.mtime = new Date(mtime * 1000);
    };
    Volume.prototype.futimesSync = function (fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.utimesBase = function (filename, atime, mtime) {
        var fd = this.openSync(filename, 'r+');
        try {
            this.futimesBase(fd, atime, mtime);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.utimesSync = function (path, atime, mtime) {
        this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.utimes = function (path, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.mkdirBase = function (filename, modeNum) {
        var steps = filenameToSteps(filename);
        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.
        if (!steps.length) {
            throwError(EISDIR, 'mkdir', filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir');
        // Check path already exists.
        var name = steps[steps.length - 1];
        if (dir.getChild(name)) throwError(EEXIST, 'mkdir', filename);
        dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */
    Volume.prototype.mkdirpBase = function (filename, modeNum) {
        var steps = filenameToSteps(filename);
        var link = this.root;
        for (var i = 0; i < steps.length; i++) {
            var step = steps[i];
            if (!link.getNode().isDirectory()) throwError(ENOTDIR, 'mkdir', link.getPath());
            var child = link.getChild(step);
            if (child) {
                if (child.getNode().isDirectory()) link = child;else throwError(ENOTDIR, 'mkdir', child.getPath());
            } else {
                link = link.createChild(step, this.createNode(true, modeNum));
            }
        }
    };
    Volume.prototype.mkdirSync = function (path, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
    };
    Volume.prototype.mkdir = function (path, a, b) {
        var _a = getArgAndCb(a, b),
            options = _a[0],
            callback = _a[1];
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    // legacy interface
    Volume.prototype.mkdirpSync = function (path, mode) {
        this.mkdirSync(path, { mode: mode, recursive: true });
    };
    Volume.prototype.mkdirp = function (path, a, b) {
        var _a = getArgAndCb(a, b),
            mode = _a[0],
            callback = _a[1];
        this.mkdir(path, { mode: mode, recursive: true }, callback);
    };
    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
        if (retry === void 0) {
            retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
            this.mkdirBase(filename, 511 /* DIR */);
            return encoding_1.strToEncoding(filename, encoding);
        } catch (err) {
            if (err.code === EEXIST) {
                if (retry > 1) this.mkdtempBase(prefix, encoding, retry - 1);else throw Error('Could not create temp dir.');
            } else throw err;
        }
    };
    Volume.prototype.mkdtempSync = function (prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
        if (!nullCheck(prefix)) return;
        return this.mkdtempBase(prefix, encoding);
    };
    Volume.prototype.mkdtemp = function (prefix, a, b) {
        var _a = getDefaultOptsAndCb(a, b),
            encoding = _a[0].encoding,
            callback = _a[1];
        if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
        if (!nullCheck(prefix)) return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume.prototype.rmdirBase = function (filename) {
        var link = this.getLinkAsDirOrThrow(filename, 'rmdir');
        // Check directory is empty.
        if (link.length) throwError(ENOTEMPTY, 'rmdir', filename);
        this.deleteLink(link);
    };
    Volume.prototype.rmdirSync = function (path) {
        this.rmdirBase(pathToFilename(path));
    };
    Volume.prototype.rmdir = function (path, callback) {
        this.wrapAsync(this.rmdirBase, [pathToFilename(path)], callback);
    };
    Volume.prototype.fchmodBase = function (fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, 'fchmod');
        file.chmod(modeNum);
    };
    Volume.prototype.fchmodSync = function (fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume.prototype.fchmod = function (fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume.prototype.chmodBase = function (filename, modeNum) {
        var fd = this.openSync(filename, 'r+');
        try {
            this.fchmodBase(fd, modeNum);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.chmodSync = function (path, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.chmodBase(filename, modeNum);
    };
    Volume.prototype.chmod = function (path, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume.prototype.lchmodBase = function (filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
            this.fchmodBase(fd, modeNum);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.lchmodSync = function (path, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.lchmodBase(filename, modeNum);
    };
    Volume.prototype.lchmod = function (path, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume.prototype.fchownBase = function (fd, uid, gid) {
        this.getFileByFdOrThrow(fd, 'fchown').chown(uid, gid);
    };
    Volume.prototype.fchownSync = function (fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
    };
    Volume.prototype.fchown = function (fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume.prototype.chownBase = function (filename, uid, gid) {
        var link = this.getResolvedLinkOrThrow(filename, 'chown');
        var node = link.getNode();
        node.chown(uid, gid);
        // if(node.isFile() || node.isSymlink()) {
        //
        // } else if(node.isDirectory()) {
        //
        // } else {
        // TODO: What do we do here?
        // }
    };
    Volume.prototype.chownSync = function (path, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path), uid, gid);
    };
    Volume.prototype.chown = function (path, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);
    };
    Volume.prototype.lchownBase = function (filename, uid, gid) {
        this.getLinkOrThrow(filename, 'lchown').getNode().chown(uid, gid);
    };
    Volume.prototype.lchownSync = function (path, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path), uid, gid);
    };
    Volume.prototype.lchown = function (path, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);
    };
    Volume.prototype.watchFile = function (path, a, b) {
        var filename = pathToFilename(path);
        var options = a;
        var listener = b;
        if (typeof options === 'function') {
            listener = a;
            options = null;
        }
        if (typeof listener !== 'function') {
            throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && (typeof options === "undefined" ? "undefined" : _typeof(options)) === 'object') {
            if (typeof options.interval === 'number') interval = options.interval;
            if (typeof options.persistent === 'boolean') persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
            watcher = new this.StatWatcher();
            watcher.start(filename, persistent, interval);
            this.statWatchers[filename] = watcher;
        }
        watcher.addListener('change', listener);
        return watcher;
    };
    Volume.prototype.unwatchFile = function (path, listener) {
        var filename = pathToFilename(path);
        var watcher = this.statWatchers[filename];
        if (!watcher) return;
        if (typeof listener === 'function') {
            watcher.removeListener('change', listener);
        } else {
            watcher.removeAllListeners('change');
        }
        if (watcher.listenerCount('change') === 0) {
            watcher.stop();
            delete this.statWatchers[filename];
        }
    };
    Volume.prototype.createReadStream = function (path, options) {
        return new this.ReadStream(path, options);
    };
    Volume.prototype.createWriteStream = function (path, options) {
        return new this.WriteStream(path, options);
    };
    // watch(path: TFilePath): FSWatcher;
    // watch(path: TFilePath, options?: IWatchOptions | string): FSWatcher;
    Volume.prototype.watch = function (path, options, listener) {
        var filename = pathToFilename(path);
        if (typeof options === 'function') {
            listener = options;
            options = null;
        }
        // tslint:disable-next-line prefer-const
        var _a = getDefaultOpts(options),
            persistent = _a.persistent,
            recursive = _a.recursive,
            encoding = _a.encoding;
        if (persistent === undefined) persistent = true;
        if (recursive === undefined) recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
            watcher.addListener('change', listener);
        }
        return watcher;
    };
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big number and descrease
     * the file descriptor of every new opened file.
     * @type {number}
     * @todo This should not be static, right?
     */
    Volume.fd = 0x7fffffff;
    return Volume;
}();
exports.Volume = Volume;
function emitStop(self) {
    self.emit('stop');
}
var StatWatcher = /** @class */function (_super) {
    __extends(StatWatcher, _super);
    function StatWatcher(vol) {
        var _this = _super.call(this) || this;
        _this.vol = null;
        _this.timeoutRef = null;
        _this.prev = null;
        _this.onInterval = function () {
            try {
                var stats = _this.vol.statSync(_this.filename);
                if (_this.hasChanged(stats)) {
                    _this.emit('change', stats, _this.prev);
                    _this.prev = stats;
                }
            } finally {
                _this.loop();
            }
        };
        _this.vol = vol;
        return _this;
    }
    StatWatcher.prototype.loop = function () {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher.prototype.hasChanged = function (stats) {
        // if(!this.prev) return false;
        if (stats.mtimeMs > this.prev.mtimeMs) return true;
        if (stats.nlink !== this.prev.nlink) return true;
        return false;
    };
    StatWatcher.prototype.start = function (path, persistent, interval) {
        if (persistent === void 0) {
            persistent = true;
        }
        if (interval === void 0) {
            interval = 5007;
        }
        this.filename = pathToFilename(path);
        this.setTimeout = persistent ? setTimeout : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
    };
    StatWatcher.prototype.stop = function () {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher;
}(events_1.EventEmitter);
exports.StatWatcher = StatWatcher;
var pool;
function allocNewPool(poolSize) {
    pool = buffer_1.bufferAllocUnsafe(poolSize);
    pool.used = 0;
}
util.inherits(FsReadStream, stream_1.Readable);
exports.ReadStream = FsReadStream;
function FsReadStream(vol, path, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol, path, options);
    this._vol = vol;
    // a little bit bigger buffer and water marks by default
    options = extend({}, getOptions(options, {}));
    if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? 'r' : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
    this.pos = undefined;
    this.bytesRead = 0;
    if (this.start !== undefined) {
        if (typeof this.start !== 'number') {
            throw new TypeError('"start" option must be a Number');
        }
        if (this.end === undefined) {
            this.end = Infinity;
        } else if (typeof this.end !== 'number') {
            throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
            throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
    }
    if (typeof this.fd !== 'number') this.open();
    this.on('end', function () {
        if (this.autoClose) {
            if (this.destroy) this.destroy();
        }
    });
}
FsReadStream.prototype.open = function () {
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
        if (er) {
            if (self.autoClose) {
                if (self.destroy) self.destroy();
            }
            self.emit('error', er);
            return;
        }
        self.fd = fd;
        self.emit('open', fd);
        // start the flow of data.
        self.read();
    });
};
FsReadStream.prototype._read = function (n) {
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._read(n);
        });
    }
    if (this.destroyed) return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
        // discard the old pool.
        allocNewPool(this._readableState.highWaterMark);
    }
    // Grab another reference to the pool in the case that while we're
    // in the thread pool another read() finishes up the pool, and
    // allocates a new one.
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead);
    // already read everything we were supposed to read!
    // treat as EOF.
    if (toRead <= 0) return this.push(null);
    // the actual read.
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    // move the pool positions, and internal position for reading.
    if (this.pos !== undefined) this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
        if (er) {
            if (self.autoClose && self.destroy) {
                self.destroy();
            }
            self.emit('error', er);
        } else {
            var b = null;
            if (bytesRead > 0) {
                self.bytesRead += bytesRead;
                b = thisPool.slice(start, start + bytesRead);
            }
            self.push(b);
        }
    }
};
FsReadStream.prototype._destroy = function (err, cb) {
    this.close(function (err2) {
        cb(err || err2);
    });
};
FsReadStream.prototype.close = function (cb) {
    var _this = this;
    if (cb) this.once('close', cb);
    if (this.closed || typeof this.fd !== 'number') {
        if (typeof this.fd !== 'number') {
            this.once('open', closeOnOpen);
            return;
        }
        return process_1.default.nextTick(function () {
            return _this.emit('close');
        });
    }
    this.closed = true;
    this._vol.close(this.fd, function (er) {
        if (er) _this.emit('error', er);else _this.emit('close');
    });
    this.fd = null;
};
// needed because as it will be called with arguments
// that does not match this.close() signature
function closeOnOpen(fd) {
    this.close();
}
util.inherits(FsWriteStream, stream_1.Writable);
exports.WriteStream = FsWriteStream;
function FsWriteStream(vol, path, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol, path, options);
    this._vol = vol;
    options = extend({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? 'w' : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
    this.pos = undefined;
    this.bytesWritten = 0;
    if (this.start !== undefined) {
        if (typeof this.start !== 'number') {
            throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
            throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
    }
    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== 'number') this.open();
    // dispose on finish.
    this.once('finish', function () {
        if (this.autoClose) {
            this.close();
        }
    });
}
FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
        if (er) {
            if (this.autoClose && this.destroy) {
                this.destroy();
            }
            this.emit('error', er);
            return;
        }
        this.fd = fd;
        this.emit('open', fd);
    }.bind(this));
};
FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer)) return this.emit('error', new Error('Invalid data'));
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._write(data, encoding, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.autoClose && self.destroy) {
                self.destroy();
            }
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) this.pos += data.length;
};
FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._writev(data, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i = 0; i < len; i++) {
        var chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.destroy) self.destroy();
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) this.pos += size;
};
FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
FsWriteStream.prototype.close = FsReadStream.prototype.close;
// There is no shutdown() for files.
FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
// ---------------------------------------- FSWatcher
var FSWatcher = /** @class */function (_super) {
    __extends(FSWatcher, _super);
    function FSWatcher(vol) {
        var _this = _super.call(this) || this;
        _this._filename = '';
        _this._steps = null;
        _this._filenameEncoded = '';
        // _persistent: boolean = true;
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._link = null;
        _this._onNodeChange = function () {
            _this._emit('change');
        };
        _this._onParentChild = function (link) {
            if (link.getName() === _this._getName()) {
                _this._emit('rename');
            }
        };
        _this._emit = function (type) {
            _this.emit('change', type, _this._filenameEncoded);
        };
        _this._persist = function () {
            _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol;
        return _this;
        // TODO: Emit "error" messages when watching.
        // this._handle.onchange = function(status, eventType, filename) {
        //     if (status < 0) {
        //         self._handle.close();
        //         const error = !filename ?
        //             errnoException(status, 'Error watching file for changes:') :
        //             errnoException(status, `Error watching file ${filename} for changes:`);
        //         error.filename = filename;
        //         self.emit('error', error);
        //     } else {
        //         self.emit('change', eventType, filename);
        //     }
        // };
    }
    FSWatcher.prototype._getName = function () {
        return this._steps[this._steps.length - 1];
    };
    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
        if (persistent === void 0) {
            persistent = true;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        if (encoding === void 0) {
            encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = encoding_1.strToEncoding(this._filename);
        // this._persistent = persistent;
        this._recursive = recursive;
        this._encoding = encoding;
        try {
            this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');
        } catch (err) {
            var error = new Error("watch " + this._filename + " " + err.code);
            error.code = err.code;
            error.errno = err.code;
            throw error;
        }
        this._link.getNode().on('change', this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
            // parent.on('child:add', this._onParentChild);
            parent.on('child:delete', this._onParentChild);
        }
        if (persistent) this._persist();
    };
    FSWatcher.prototype.close = function () {
        clearTimeout(this._timer);
        this._link.getNode().removeListener('change', this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
            // parent.removeListener('child:add', this._onParentChild);
            parent.removeListener('child:delete', this._onParentChild);
        }
    };
    return FSWatcher;
}(events_1.EventEmitter);
exports.FSWatcher = FSWatcher;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};

// path.relative(from, to)
// posix version
exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
  // We saw a non-dot character immediately before the dot
  preDotState === 0 ||
  // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var process_1 = __webpack_require__(19);
var buffer_1 = __webpack_require__(11);
var constants_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var Stats_1 = __webpack_require__(10);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK,
    O_APPEND = constants_1.constants.O_APPEND;
exports.SEP = '/';
/**
 * Node in a file system (like i-node, v-node).
 */
var Node = /** @class */function (_super) {
    __extends(Node, _super);
    function Node(ino, perm) {
        if (perm === void 0) {
            perm = 438;
        }
        var _this = _super.call(this) || this;
        // User ID and group ID.
        _this.uid = process_1.default.getuid();
        _this.gid = process_1.default.getgid();
        _this.atime = new Date();
        _this.mtime = new Date();
        _this.ctime = new Date();
        // data: string = '';
        _this.buf = null;
        _this.perm = 438; // Permissions `chmod`, `fchmod`
        _this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
        // Number of hard links pointing at this Node.
        _this.nlink = 1;
        // Steps to another node, if this node is a symlink.
        _this.symlink = null;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
    }
    Node.prototype.getString = function (encoding) {
        if (encoding === void 0) {
            encoding = 'utf8';
        }
        return this.getBuffer().toString(encoding);
    };
    Node.prototype.setString = function (str) {
        // this.setBuffer(bufferFrom(str, 'utf8'));
        this.buf = buffer_1.bufferFrom(str, 'utf8');
        this.touch();
    };
    Node.prototype.getBuffer = function () {
        if (!this.buf) this.setBuffer(buffer_1.bufferAllocUnsafe(0));
        return buffer_1.bufferFrom(this.buf); // Return a copy.
    };
    Node.prototype.setBuffer = function (buf) {
        this.buf = buffer_1.bufferFrom(buf); // Creates a copy of data.
        this.touch();
    };
    Node.prototype.getSize = function () {
        return this.buf ? this.buf.length : 0;
    };
    Node.prototype.setModeProperty = function (property) {
        this.mode = this.mode & ~S_IFMT | property;
    };
    Node.prototype.setIsFile = function () {
        this.setModeProperty(S_IFREG);
    };
    Node.prototype.setIsDirectory = function () {
        this.setModeProperty(S_IFDIR);
    };
    Node.prototype.setIsSymlink = function () {
        this.setModeProperty(S_IFLNK);
    };
    Node.prototype.isFile = function () {
        return (this.mode & S_IFMT) === S_IFREG;
    };
    Node.prototype.isDirectory = function () {
        return (this.mode & S_IFMT) === S_IFDIR;
    };
    Node.prototype.isSymlink = function () {
        // return !!this.symlink;
        return (this.mode & S_IFMT) === S_IFLNK;
    };
    Node.prototype.makeSymlink = function (steps) {
        this.symlink = steps;
        this.setIsSymlink();
    };
    Node.prototype.write = function (buf, off, len, pos) {
        if (off === void 0) {
            off = 0;
        }
        if (len === void 0) {
            len = buf.length;
        }
        if (pos === void 0) {
            pos = 0;
        }
        if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
        if (pos + len > this.buf.length) {
            var newBuf = buffer_1.bufferAllocUnsafe(pos + len);
            this.buf.copy(newBuf, 0, 0, this.buf.length);
            this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off, off + len);
        this.touch();
        return len;
    };
    // Returns the number of bytes read.
    Node.prototype.read = function (buf, off, len, pos) {
        if (off === void 0) {
            off = 0;
        }
        if (len === void 0) {
            len = buf.byteLength;
        }
        if (pos === void 0) {
            pos = 0;
        }
        if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
            actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
            actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off, pos, pos + actualLen);
        return actualLen;
    };
    Node.prototype.truncate = function (len) {
        if (len === void 0) {
            len = 0;
        }
        if (!len) this.buf = buffer_1.bufferAllocUnsafe(0);else {
            if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
            if (len <= this.buf.length) {
                this.buf = this.buf.slice(0, len);
            } else {
                var buf = buffer_1.bufferAllocUnsafe(0);
                this.buf.copy(buf);
                buf.fill(0, len);
            }
        }
        this.touch();
    };
    Node.prototype.chmod = function (perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
    };
    Node.prototype.chown = function (uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
    };
    Node.prototype.touch = function () {
        this.mtime = new Date();
        this.emit('change', this);
    };
    Node.prototype.canRead = function (uid, gid) {
        if (uid === void 0) {
            uid = process_1.default.getuid();
        }
        if (gid === void 0) {
            gid = process_1.default.getgid();
        }
        if (this.perm & 4 /* IROTH */) {
                return true;
            }
        if (gid === this.gid) {
            if (this.perm & 32 /* IRGRP */) {
                    return true;
                }
        }
        if (uid === this.uid) {
            if (this.perm & 256 /* IRUSR */) {
                    return true;
                }
        }
        return false;
    };
    Node.prototype.canWrite = function (uid, gid) {
        if (uid === void 0) {
            uid = process_1.default.getuid();
        }
        if (gid === void 0) {
            gid = process_1.default.getgid();
        }
        if (this.perm & 2 /* IWOTH */) {
                return true;
            }
        if (gid === this.gid) {
            if (this.perm & 16 /* IWGRP */) {
                    return true;
                }
        }
        if (uid === this.uid) {
            if (this.perm & 128 /* IWUSR */) {
                    return true;
                }
        }
        return false;
    };
    Node.prototype.del = function () {
        this.emit('delete', this);
    };
    Node.prototype.toJSON = function () {
        return {
            ino: this.ino,
            uid: this.uid,
            gid: this.gid,
            atime: this.atime.getTime(),
            mtime: this.mtime.getTime(),
            ctime: this.ctime.getTime(),
            perm: this.perm,
            mode: this.mode,
            nlink: this.nlink,
            symlink: this.symlink,
            data: this.getString()
        };
    };
    return Node;
}(events_1.EventEmitter);
exports.Node = Node;
/**
 * Represents a hard link that points to an i-node `node`.
 */
var Link = /** @class */function (_super) {
    __extends(Link, _super);
    function Link(vol, parent, name) {
        var _this = _super.call(this) || this;
        _this.parent = null;
        _this.children = {};
        // Path to this node as Array: ['usr', 'bin', 'node'].
        _this.steps = [];
        // "i-node" of this hard link.
        _this.node = null;
        // "i-node" number of the node.
        _this.ino = 0;
        // Number of children.
        _this.length = 0;
        _this.vol = vol;
        _this.parent = parent;
        _this.steps = parent ? parent.steps.concat([name]) : [name];
        return _this;
    }
    Link.prototype.setNode = function (node) {
        this.node = node;
        this.ino = node.ino;
    };
    Link.prototype.getNode = function () {
        return this.node;
    };
    Link.prototype.createChild = function (name, node) {
        if (node === void 0) {
            node = this.vol.createNode();
        }
        var link = new Link(this.vol, this, name);
        link.setNode(node);
        if (node.isDirectory()) {
            // link.setChild('.', link);
            // link.getNode().nlink++;
            // link.setChild('..', this);
            // this.getNode().nlink++;
        }
        this.setChild(name, link);
        return link;
    };
    Link.prototype.setChild = function (name, link) {
        if (link === void 0) {
            link = new Link(this.vol, this, name);
        }
        this.children[name] = link;
        link.parent = this;
        this.length++;
        this.emit('child:add', link, this);
        return link;
    };
    Link.prototype.deleteChild = function (link) {
        delete this.children[link.getName()];
        this.length--;
        this.emit('child:delete', link, this);
    };
    Link.prototype.getChild = function (name) {
        if (Object.hasOwnProperty.call(this.children, name)) {
            return this.children[name];
        }
    };
    Link.prototype.getPath = function () {
        return this.steps.join(exports.SEP);
    };
    Link.prototype.getName = function () {
        return this.steps[this.steps.length - 1];
    };
    // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }
    /**
     * Walk the tree path and return the `Link` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the `steps` array.
     * @returns {any}
     */
    Link.prototype.walk = function (steps, stop, i) {
        if (stop === void 0) {
            stop = steps.length;
        }
        if (i === void 0) {
            i = 0;
        }
        if (i >= steps.length) return this;
        if (i >= stop) return this;
        var step = steps[i];
        var link = this.getChild(step);
        if (!link) return null;
        return link.walk(steps, stop, i + 1);
    };
    Link.prototype.toJSON = function () {
        return {
            steps: this.steps,
            ino: this.ino,
            children: Object.keys(this.children)
        };
    };
    return Link;
}(events_1.EventEmitter);
exports.Link = Link;
/**
 * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.
 */
var File = /** @class */function () {
    /**
     * Open a Link-Node pair. `node` is provided separately as that might be a different node
     * rather the one `link` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    function File(link, node, flags, fd) {
        /**
         * Hard link that this file opened.
         * @type {any}
         */
        this.link = null;
        /**
         * Reference to a `Node`.
         * @type {Node}
         */
        this.node = null;
        /**
         * A cursor/offset position in a file, where data will be written on write.
         * User can "seek" this position.
         */
        this.position = 0;
        this.link = link;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
    }
    File.prototype.getString = function (encoding) {
        if (encoding === void 0) {
            encoding = 'utf8';
        }
        return this.node.getString();
    };
    File.prototype.setString = function (str) {
        this.node.setString(str);
    };
    File.prototype.getBuffer = function () {
        return this.node.getBuffer();
    };
    File.prototype.setBuffer = function (buf) {
        this.node.setBuffer(buf);
    };
    File.prototype.getSize = function () {
        return this.node.getSize();
    };
    File.prototype.truncate = function (len) {
        this.node.truncate(len);
    };
    File.prototype.seekTo = function (position) {
        this.position = position;
    };
    File.prototype.stats = function () {
        return Stats_1.default.build(this.node);
    };
    File.prototype.write = function (buf, offset, length, position) {
        if (offset === void 0) {
            offset = 0;
        }
        if (length === void 0) {
            length = buf.length;
        }
        if (typeof position !== 'number') position = this.position;
        if (this.flags & O_APPEND) position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
    };
    File.prototype.read = function (buf, offset, length, position) {
        if (offset === void 0) {
            offset = 0;
        }
        if (length === void 0) {
            length = buf.byteLength;
        }
        if (typeof position !== 'number') position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
    };
    File.prototype.chmod = function (perm) {
        this.node.chmod(perm);
    };
    File.prototype.chown = function (uid, gid) {
        this.node.chown(uid, gid);
    };
    return File;
}();
exports.File = File;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `setTimeoutUnref` is just like `setTimeout`,
 * only in Node's environment it will "unref" its macro task.
 */
function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(null, arguments);
    if (ref && (typeof ref === "undefined" ? "undefined" : _typeof(ref)) === 'object' && typeof ref.unref === 'function') ref.unref();
    return ref;
}
exports.default = setTimeoutUnref;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(5).EventEmitter;
var inherits = __webpack_require__(3);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(13);
Stream.Writable = __webpack_require__(48);
Stream.Duplex = __webpack_require__(49);
Stream.Transform = __webpack_require__(50);
Stream.PassThrough = __webpack_require__(51);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

/***/ }),
/* 43 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(9).Buffer;
var util = __webpack_require__(45);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(26);

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(14);

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(13).Transform;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(13).PassThrough;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;

function extend(a, b) {
    for (var key in b) {
        a[key] = b[key];
    }return arguments.length < 3 ? a : extend.apply(null, [a].concat(slice.call(arguments, 2)));
}

module.exports = extend;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
function promisify(vol, fn, getResult) {
    if (getResult === void 0) {
        getResult = function getResult(input) {
            return input;
        };
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            vol[fn].bind(vol).apply(void 0, __spreadArrays(args, [function (error, result) {
                if (error) return reject(error);
                return resolve(getResult(result));
            }]));
        });
    };
}
var FileHandle = /** @class */function () {
    function FileHandle(vol, fd) {
        this.vol = vol;
        this.fd = fd;
    }
    FileHandle.prototype.appendFile = function (data, options) {
        return promisify(this.vol, 'appendFile')(this.fd, data, options);
    };
    FileHandle.prototype.chmod = function (mode) {
        return promisify(this.vol, 'fchmod')(this.fd, mode);
    };
    FileHandle.prototype.chown = function (uid, gid) {
        return promisify(this.vol, 'fchown')(this.fd, uid, gid);
    };
    FileHandle.prototype.close = function () {
        return promisify(this.vol, 'close')(this.fd);
    };
    FileHandle.prototype.datasync = function () {
        return promisify(this.vol, 'fdatasync')(this.fd);
    };
    FileHandle.prototype.read = function (buffer, offset, length, position) {
        return promisify(this.vol, 'read', function (bytesRead) {
            return { bytesRead: bytesRead, buffer: buffer };
        })(this.fd, buffer, offset, length, position);
    };
    FileHandle.prototype.readFile = function (options) {
        return promisify(this.vol, 'readFile')(this.fd, options);
    };
    FileHandle.prototype.stat = function (options) {
        return promisify(this.vol, 'fstat')(this.fd, options);
    };
    FileHandle.prototype.sync = function () {
        return promisify(this.vol, 'fsync')(this.fd);
    };
    FileHandle.prototype.truncate = function (len) {
        return promisify(this.vol, 'ftruncate')(this.fd, len);
    };
    FileHandle.prototype.utimes = function (atime, mtime) {
        return promisify(this.vol, 'futimes')(this.fd, atime, mtime);
    };
    FileHandle.prototype.write = function (buffer, offset, length, position) {
        return promisify(this.vol, 'write', function (bytesWritten) {
            return { bytesWritten: bytesWritten, buffer: buffer };
        })(this.fd, buffer, offset, length, position);
    };
    FileHandle.prototype.writeFile = function (data, options) {
        return promisify(this.vol, 'writeFile')(this.fd, data, options);
    };
    return FileHandle;
}();
exports.FileHandle = FileHandle;
function createPromisesApi(vol) {
    if (typeof Promise === 'undefined') return null;
    return {
        FileHandle: FileHandle,
        access: function access(path, mode) {
            return promisify(vol, 'access')(path, mode);
        },
        appendFile: function appendFile(path, data, options) {
            return promisify(vol, 'appendFile')(path instanceof FileHandle ? path.fd : path, data, options);
        },
        chmod: function chmod(path, mode) {
            return promisify(vol, 'chmod')(path, mode);
        },
        chown: function chown(path, uid, gid) {
            return promisify(vol, 'chown')(path, uid, gid);
        },
        copyFile: function copyFile(src, dest, flags) {
            return promisify(vol, 'copyFile')(src, dest, flags);
        },
        lchmod: function lchmod(path, mode) {
            return promisify(vol, 'lchmod')(path, mode);
        },
        lchown: function lchown(path, uid, gid) {
            return promisify(vol, 'lchown')(path, uid, gid);
        },
        link: function link(existingPath, newPath) {
            return promisify(vol, 'link')(existingPath, newPath);
        },
        lstat: function lstat(path, options) {
            return promisify(vol, 'lstat')(path, options);
        },
        mkdir: function mkdir(path, options) {
            return promisify(vol, 'mkdir')(path, options);
        },
        mkdtemp: function mkdtemp(prefix, options) {
            return promisify(vol, 'mkdtemp')(prefix, options);
        },
        open: function open(path, flags, mode) {
            return promisify(vol, 'open', function (fd) {
                return new FileHandle(vol, fd);
            })(path, flags, mode);
        },
        readdir: function readdir(path, options) {
            return promisify(vol, 'readdir')(path, options);
        },
        readFile: function readFile(id, options) {
            return promisify(vol, 'readFile')(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function readlink(path, options) {
            return promisify(vol, 'readlink')(path, options);
        },
        realpath: function realpath(path, options) {
            return promisify(vol, 'realpath')(path, options);
        },
        rename: function rename(oldPath, newPath) {
            return promisify(vol, 'rename')(oldPath, newPath);
        },
        rmdir: function rmdir(path) {
            return promisify(vol, 'rmdir')(path);
        },
        stat: function stat(path, options) {
            return promisify(vol, 'stat')(path, options);
        },
        symlink: function symlink(target, path, type) {
            return promisify(vol, 'symlink')(target, path, type);
        },
        truncate: function truncate(path, len) {
            return promisify(vol, 'truncate')(path, len);
        },
        unlink: function unlink(path) {
            return promisify(vol, 'unlink')(path);
        },
        utimes: function utimes(path, atime, mtime) {
            return promisify(vol, 'utimes')(path, atime, mtime);
        },
        writeFile: function writeFile(id, data, options) {
            return promisify(vol, 'writeFile')(id instanceof FileHandle ? id.fd : id, data, options);
        }
    };
}
exports.default = createPromisesApi;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var punycode = __webpack_require__(55);
var util = __webpack_require__(57);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(58);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) {}
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(27)) == 'object' && __webpack_require__(27)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(56)(module), __webpack_require__(0)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(59);
exports.encode = exports.stringify = __webpack_require__(60);

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unixify = unixify;
exports.correctPath = correctPath;
var isWin = process.platform === 'win32';

function removeTrailingSeparator(str) {
  var i = str.length - 1;
  if (i < 2) {
    return str;
  }
  while (isSeparator(str, i)) {
    i--;
  }
  return str.substr(0, i + 1);
}

function isSeparator(str, i) {
  var char = str[i];
  return i > 0 && (char === '/' || isWin && char === '\\');
}

function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }
  return str;
}

function unixify(filepath) {
  var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (isWin) {
    filepath = normalizePath(filepath, stripTrailing);
    return filepath.replace(/^([a-zA-Z]+:|\.\/)/, '');
  }
  return filepath;
}

function correctPath(filepath) {
  return unixify(filepath.replace(/^\\\\\?\\.:\\/, '\\'));
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var fsProps = exports.fsProps = ['constants', 'F_OK', 'R_OK', 'W_OK', 'X_OK', 'Stats'];

var fsSyncMethods = exports.fsSyncMethods = ['renameSync', 'ftruncateSync', 'truncateSync', 'chownSync', 'fchownSync', 'lchownSync', 'chmodSync', 'fchmodSync', 'lchmodSync', 'statSync', 'lstatSync', 'fstatSync', 'linkSync', 'symlinkSync', 'readlinkSync', 'realpathSync', 'unlinkSync', 'rmdirSync', 'mkdirSync', 'mkdirpSync', 'readdirSync', 'closeSync', 'openSync', 'utimesSync', 'futimesSync', 'fsyncSync', 'writeSync', 'readSync', 'readFileSync', 'writeFileSync', 'appendFileSync', 'existsSync', 'accessSync', 'fdatasyncSync', 'mkdtempSync', 'copyFileSync', 'createReadStream', 'createWriteStream'];

var fsAsyncMethods = exports.fsAsyncMethods = ['rename', 'ftruncate', 'truncate', 'chown', 'fchown', 'lchown', 'chmod', 'fchmod', 'lchmod', 'stat', 'lstat', 'fstat', 'link', 'symlink', 'readlink', 'realpath', 'unlink', 'rmdir', 'mkdir', 'mkdirp', 'readdir', 'close', 'open', 'utimes', 'futimes', 'fsync', 'write', 'read', 'readFile', 'writeFile', 'appendFile', 'exists', 'access', 'fdatasync', 'mkdtemp', 'copyFile', 'watchFile', 'unwatchFile', 'watch'];

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmI4ZjhiN2YxZWVjZGFmZGU3NGEiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvU3RhdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9pbnRlcm5hbC9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL0RpcmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2VuY29kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW50ZXJuYWwvZXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvcHJvY2Vzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9nZXRCaWdJbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3ZvbHVtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3NldFRpbWVvdXRVbnJlZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL3V0aWwgKGlnbm9yZWQpIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/ODQ0MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZXh0ZW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcy1tb25rZXkvbGliL2NvcnJlY3RQYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mcy1tb25rZXkvbGliL3V0aWwvbGlzdHMuanMiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJtb2R1bGUiLCJleHBvcnRzIiwicHJvY2VzcyIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiRXJyb3IiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwicG5hIiwicmVxdWlyZSIsIm9iamVjdEtleXMiLCJPYmplY3QiLCJrZXlzIiwib2JqIiwia2V5IiwiRHVwbGV4IiwidXRpbCIsImNyZWF0ZSIsImluaGVyaXRzIiwiUmVhZGFibGUiLCJXcml0YWJsZSIsInYiLCJtZXRob2QiLCJvcHRpb25zIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmVuZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl93cml0YWJsZVN0YXRlIiwiaGlnaFdhdGVyTWFyayIsImVuZGVkIiwib25FbmROVCIsInNlbGYiLCJlbmQiLCJfcmVhZGFibGVTdGF0ZSIsInVuZGVmaW5lZCIsImRlc3Ryb3llZCIsInNldCIsInZhbHVlIiwiX2Rlc3Ryb3kiLCJlcnIiLCJjYiIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJjb25zdHJ1Y3RvciIsImNvbmZpZ3VyYWJsZSIsIlRlbXBDdG9yIiwiY29uc3RhbnRzIiwiT19SRE9OTFkiLCJPX1dST05MWSIsIk9fUkRXUiIsIlNfSUZNVCIsIlNfSUZSRUciLCJTX0lGRElSIiwiU19JRkNIUiIsIlNfSUZCTEsiLCJTX0lGSUZPIiwiU19JRkxOSyIsIlNfSUZTT0NLIiwiT19DUkVBVCIsIk9fRVhDTCIsIk9fTk9DVFRZIiwiT19UUlVOQyIsIk9fQVBQRU5EIiwiT19ESVJFQ1RPUlkiLCJPX05PQVRJTUUiLCJPX05PRk9MTE9XIiwiT19TWU5DIiwiT19ESVJFQ1QiLCJPX05PTkJMT0NLIiwiU19JUldYVSIsIlNfSVJVU1IiLCJTX0lXVVNSIiwiU19JWFVTUiIsIlNfSVJXWEciLCJTX0lSR1JQIiwiU19JV0dSUCIsIlNfSVhHUlAiLCJTX0lSV1hPIiwiU19JUk9USCIsIlNfSVdPVEgiLCJTX0lYT1RIIiwiRl9PSyIsIlJfT0siLCJXX09LIiwiWF9PSyIsIlVWX0ZTX1NZTUxJTktfRElSIiwiVVZfRlNfU1lNTElOS19KVU5DVElPTiIsIlVWX0ZTX0NPUFlGSUxFX0VYQ0wiLCJVVl9GU19DT1BZRklMRV9GSUNMT05FIiwiVVZfRlNfQ09QWUZJTEVfRklDTE9ORV9GT1JDRSIsIkNPUFlGSUxFX0VYQ0wiLCJDT1BZRklMRV9GSUNMT05FIiwiQ09QWUZJTEVfRklDTE9ORV9GT1JDRSIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwidGFyZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJOdW1iZXIiLCJpc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJUeXBlRXJyb3IiLCJhcmciLCJSYW5nZUVycm9yIiwiZ2V0UHJvdG90eXBlT2YiLCJzZXRNYXhMaXN0ZW5lcnMiLCJuIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJ0eXBlIiwiZG9FcnJvciIsImV2ZW50cyIsImVycm9yIiwiZXIiLCJtZXNzYWdlIiwiY29udGV4dCIsImhhbmRsZXIiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsIm0iLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJTdHJpbmciLCJlbWl0dGVyIiwiY291bnQiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwiYmluZCIsImxpc3QiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzaGlmdCIsInNwbGljZU9uZSIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJhcnIiLCJjb3B5IiwiaW5kZXgiLCJwb3AiLCJyZXQiLCJpc0FycmF5Iiwib2JqZWN0VG9TdHJpbmciLCJpc0Jvb2xlYW4iLCJpc051bGwiLCJpc051bGxPclVuZGVmaW5lZCIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiaXNSZWdFeHAiLCJyZSIsImlzT2JqZWN0IiwiaXNEYXRlIiwiZCIsImlzRXJyb3IiLCJpc0Z1bmN0aW9uIiwiaXNQcmltaXRpdmUiLCJpc0J1ZmZlciIsIkJ1ZmZlciIsIm8iLCJ0b1N0cmluZyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImZvcm1hdFJlZ0V4cCIsImZvcm1hdCIsImYiLCJvYmplY3RzIiwiaW5zcGVjdCIsImpvaW4iLCJzdHIiLCJyZXBsYWNlIiwieCIsIkpTT04iLCJzdHJpbmdpZnkiLCJfIiwiZGVwcmVjYXRlIiwiZm4iLCJtc2ciLCJub0RlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZCIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwidHJhY2UiLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJkZWJ1Z2xvZyIsIk5PREVfREVCVUciLCJ0b1VwcGVyQ2FzZSIsIlJlZ0V4cCIsInRlc3QiLCJwaWQiLCJvcHRzIiwiY3R4Iiwic2VlbiIsInN0eWxpemUiLCJzdHlsaXplTm9Db2xvciIsImRlcHRoIiwiY29sb3JzIiwic2hvd0hpZGRlbiIsIl9leHRlbmQiLCJjdXN0b21JbnNwZWN0Iiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJmb3JFYWNoIiwidmFsIiwiaWR4IiwicmVjdXJzZVRpbWVzIiwicHJpbWl0aXZlIiwiZm9ybWF0UHJpbWl0aXZlIiwidmlzaWJsZUtleXMiLCJpbmRleE9mIiwiZm9ybWF0RXJyb3IiLCJEYXRlIiwiYmFzZSIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJtYXAiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwibCIsImhhc093blByb3BlcnR5IiwibWF0Y2giLCJkZXNjIiwic3BsaXQiLCJsaW5lIiwic3Vic3RyIiwibnVtTGluZXNFc3QiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyIiwiYXIiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJ0aW1lIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsImxvZyIsIm9yaWdpbiIsImFkZCIsInByb3AiLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lUHJvcGVydGllcyIsImN1c3RvbSIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsInJlYXNvbiIsIm5ld1JlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsIm1heWJlQ2IiLCJ0aGVuIiwicmVqIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYWZ0ZXJUaWNrT25lIiwiYWZ0ZXJUaWNrVHdvIiwiYWZ0ZXJUaWNrVGhyZWUiLCJhZnRlclRpY2siLCJidWZmZXIiLCJjb3B5UHJvcHMiLCJzcmMiLCJkc3QiLCJmcm9tIiwiYWxsb2MiLCJhbGxvY1Vuc2FmZSIsImFsbG9jVW5zYWZlU2xvdyIsIlNhZmVCdWZmZXIiLCJlbmNvZGluZ09yT2Zmc2V0Iiwic2l6ZSIsImZpbGwiLCJlbmNvZGluZyIsImJ1ZiIsIlNsb3dCdWZmZXIiLCJjb25zdGFudHNfMSIsImdldEJpZ0ludF8xIiwiU3RhdHMiLCJidWlsZCIsIm5vZGUiLCJiaWdpbnQiLCJzdGF0cyIsInVpZCIsImdpZCIsImF0aW1lIiwibXRpbWUiLCJjdGltZSIsImdldFN0YXROdW1iZXIiLCJudW1iZXIiLCJkZWZhdWx0IiwicmRldiIsImJsa3NpemUiLCJpbm8iLCJnZXRTaXplIiwiYmxvY2tzIiwiYmlydGh0aW1lIiwiYXRpbWVNcyIsImdldFRpbWUiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiZGV2IiwibW9kZSIsIm5saW5rIiwiX2NoZWNrTW9kZVByb3BlcnR5IiwicHJvcGVydHkiLCJpc0RpcmVjdG9yeSIsImlzRmlsZSIsImlzQmxvY2tEZXZpY2UiLCJpc0NoYXJhY3RlckRldmljZSIsImlzU3ltYm9saWNMaW5rIiwiaXNGSUZPIiwiaXNTb2NrZXQiLCJfX3NwcmVhZEFycmF5cyIsInMiLCJpbCIsInIiLCJrIiwiYSIsImoiLCJqbCIsImJ1ZmZlcl8xIiwiYnVmZmVyVjBQMTJQb255ZmlsbCIsImFyZzAiLCJfaSIsImJ1ZmZlckFsbG9jVW5zYWZlIiwiYnVmZmVyRnJvbSIsImJhc2U2NCIsImllZWU3NTQiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJVaW50OEFycmF5IiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJieXRlTGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwicG9vbFNpemUiLCJfYXVnbWVudCIsIkFycmF5QnVmZmVyIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImNoZWNrZWQiLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwid3JpdGUiLCJzbGljZSIsImZyb21BcnJheUxpa2UiLCJieXRlT2Zmc2V0IiwiaXNuYW4iLCJkYXRhIiwiYiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJ5IiwiTWF0aCIsIm1pbiIsInRvTG93ZXJDYXNlIiwicG9zIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJzdGFydCIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwibWF4IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwibGFzdEluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50IiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInRyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImMiLCJoaSIsImxvIiwidG9CeXRlQXJyYXkiLCJTdHJlYW0iLCJUcmFuc2Zvcm0iLCJQYXNzVGhyb3VnaCIsIldyaXRlUmVxIiwiY2h1bmsiLCJjYWxsYmFjayIsIm5leHQiLCJDb3JrZWRSZXF1ZXN0IiwiX3RoaXMiLCJlbnRyeSIsImZpbmlzaCIsIm9uQ29ya2VkRmluaXNoIiwiYXN5bmNXcml0ZSIsInNldEltbWVkaWF0ZSIsIldyaXRhYmxlU3RhdGUiLCJpbnRlcm5hbFV0aWwiLCJPdXJVaW50OEFycmF5IiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZXN0cm95SW1wbCIsIm5vcCIsInN0cmVhbSIsImlzRHVwbGV4Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsImh3bSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZGVmYXVsdEh3bSIsImZpbmFsQ2FsbGVkIiwibmVlZERyYWluIiwiZW5kaW5nIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJ3cml0aW5nIiwiY29ya2VkIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwid3JpdGVjYiIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJjdXJyZW50IiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJfd3JpdGUiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZGVzdHJveSIsImZpbmFsIiwiX2ZpbmFsIiwicGlwZSIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwidmFsaWQiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwibGFzdCIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwicHJlZmluaXNoIiwibmVlZCIsImNvcmtSZXEiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95IiwiZW5jb2RpbmdfMSIsIkRpcmVudCIsImxpbmsiLCJkaXJlbnQiLCJnZXROb2RlIiwic3RyVG9FbmNvZGluZyIsImdldE5hbWUiLCJlcnJvcnMiLCJFTkNPRElOR19VVEY4IiwiYXNzZXJ0RW5jb2RpbmciLCJfX2V4dGVuZHMiLCJleHRlbmRTdGF0aWNzIiwicCIsIl9fIiwia0NvZGUiLCJtZXNzYWdlcyIsImFzc2VydCIsIm1ha2VOb2RlRXJyb3IiLCJCYXNlIiwiX3N1cGVyIiwiTm9kZUVycm9yIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcGVyYXRvciIsImV4cGVjdGVkIiwiZ2VuZXJhdGVkTWVzc2FnZSIsImNhcHR1cmVTdGFja1RyYWNlIiwic3RhY2tTdGFydEZ1bmN0aW9uIiwic3RyaWN0RXF1YWwiLCJmbXQiLCJFIiwic3ltIiwiYnVmZmVyT3V0T2ZCb3VuZHMiLCJzZXJ2ZXJzIiwiZW5jIiwiaW52YWxpZEFyZ1R5cGUiLCJvbmVPZiIsIm1pc3NpbmdBcmdzIiwiZGV0ZXJtaW5lciIsIm5hbWVzIiwidGhpbmciLCJpc1dyaXRpbmciLCJtYXliZVJldHVyblByb2Nlc3MiLCJfYSIsImNyZWF0ZVByb2Nlc3MiLCJnZXR1aWQiLCJnZXRnaWQiLCJlbWl0V2FybmluZyIsIl9zZXRJbW1lZGlhdGUiLCJzY29wZSIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImlkIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJpdGVtIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsImNsZWFySW1tZWRpYXRlIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRUVsaXN0ZW5lckNvdW50IiwiZGVidWdVdGlsIiwiZGVidWciLCJCdWZmZXJMaXN0IiwiU3RyaW5nRGVjb2RlciIsImtQcm94eUV2ZW50cyIsImV2ZW50IiwicmVhZGFibGVPYmplY3RNb2RlIiwicmVhZGFibGVId20iLCJyZWFkYWJsZUhpZ2hXYXRlck1hcmsiLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsImF3YWl0RHJhaW4iLCJyZWFkaW5nTW9yZSIsImRlY29kZXIiLCJfcmVhZCIsInNraXBDaHVua0NoZWNrIiwicmVhZGFibGVBZGRDaHVuayIsImFkZFRvRnJvbnQiLCJvbkVvZkNodW5rIiwiY2h1bmtJbnZhbGlkIiwiYWRkQ2h1bmsiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwiZW1pdFJlYWRhYmxlIiwiaXNQYXVzZWQiLCJzZXRFbmNvZGluZyIsIk1BWF9IV00iLCJjb21wdXRlTmV3SGlnaFdhdGVyTWFyayIsImhvd011Y2hUb1JlYWQiLCJoZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImRlc3QiLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZXJyb3IiLCJvbmRhdGEiLCJpbmNyZWFzZWRBd2FpdERyYWluIiwicGF1c2UiLCJyZXN1bWUiLCJkZXN0cyIsInNwbGljZSIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInJlc3VtZV8iLCJ3cmFwIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiY2xlYXIiLCJmcm9tTGlzdFBhcnRpYWwiLCJoYXNTdHJpbmdzIiwiY29weUZyb21CdWZmZXJTdHJpbmciLCJjb3B5RnJvbUJ1ZmZlciIsIm5iIiwidGFpbCIsImVuZFJlYWRhYmxlTlQiLCJ4cyIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsIl9ub3JtYWxpemVFbmNvZGluZyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJ0ZXh0IiwidXRmMTZUZXh0IiwidXRmMTZFbmQiLCJmaWxsTGFzdCIsInV0ZjhGaWxsTGFzdCIsImJhc2U2NFRleHQiLCJiYXNlNjRFbmQiLCJzaW1wbGVXcml0ZSIsInNpbXBsZUVuZCIsImxhc3ROZWVkIiwibGFzdFRvdGFsIiwibGFzdENoYXIiLCJ1dGY4RW5kIiwidXRmOFRleHQiLCJ1dGY4Q2hlY2tCeXRlIiwiYnl0ZSIsInV0ZjhDaGVja0luY29tcGxldGUiLCJ1dGY4Q2hlY2tFeHRyYUJ5dGVzIiwidG90YWwiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjaHVuayIsInJzIiwibmVlZFRyYW5zZm9ybSIsIndyaXRlZW5jb2RpbmciLCJ0cmFuc2Zvcm0iLCJfdHJhbnNmb3JtIiwiZmx1c2giLCJfZmx1c2giLCJkb25lIiwiX3RoaXMyIiwiZXJyMiIsInZvbCIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsIlN0YXRzXzEiLCJEaXJlbnRfMSIsInZvbHVtZV8xIiwiZnNTeW5jTWV0aG9kcyIsImZzQXN5bmNNZXRob2RzIiwiVm9sdW1lIiwiY3JlYXRlRnNGcm9tVm9sdW1lIiwiZnMiLCJmc1N5bmNNZXRob2RzXzEiLCJmc0FzeW5jTWV0aG9kc18xIiwiU3RhdFdhdGNoZXIiLCJGU1dhdGNoZXIiLCJXcml0ZVN0cmVhbSIsIlJlYWRTdHJlYW0iLCJwcm9taXNlcyIsIl90b1VuaXhUaW1lc3RhbXAiLCJ0b1VuaXhUaW1lc3RhbXAiLCJzZW1hbnRpYyIsIkJpZ0ludCIsIkJpZ0ludE5vdFN1cHBvcnRlZCIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4IiwiZXh0cmFCeXRlcyIsInBhcnRzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJydCIsImFicyIsIkxOMiIsIm9iamVjdEFzc2lnbiIsImhhc093biIsInBTbGljZSIsImZ1bmN0aW9uc0hhdmVOYW1lcyIsInBUb1N0cmluZyIsImFycmJ1ZiIsIkRhdGFWaWV3Iiwib2siLCJyZWdleCIsImZ1bmMiLCJnZXRNZXNzYWdlIiwiZmFpbCIsInN0YWNrIiwiZm5fbmFtZSIsIm5leHRfbGluZSIsInN1YnN0cmluZyIsInRydW5jYXRlIiwic29tZXRoaW5nIiwicmF3bmFtZSIsImVxdWFsIiwibm90RXF1YWwiLCJkZWVwRXF1YWwiLCJfZGVlcEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwic3RyaWN0IiwibWVtb3MiLCJzb3VyY2UiLCJtdWx0aWxpbmUiLCJsYXN0SW5kZXgiLCJpZ25vcmVDYXNlIiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiYWN0dWFsSW5kZXgiLCJvYmpFcXVpdiIsImlzQXJndW1lbnRzIiwiYWN0dWFsVmlzaXRlZE9iamVjdHMiLCJhSXNBcmdzIiwiYklzQXJncyIsImthIiwia2IiLCJzb3J0Iiwibm90RGVlcEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJleHBlY3RlZEV4Y2VwdGlvbiIsImlzUHJvdG90eXBlT2YiLCJfdHJ5QmxvY2siLCJibG9jayIsIl90aHJvd3MiLCJzaG91bGRUaHJvdyIsInVzZXJQcm92aWRlZE1lc3NhZ2UiLCJpc1Vud2FudGVkRXhjZXB0aW9uIiwiaXNVbmV4cGVjdGVkRXhjZXB0aW9uIiwidGhyb3dzIiwiZG9lc05vdFRocm93IiwiaWZFcnJvciIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0Iiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJ0ZXN0MiIsIm9yZGVyMiIsInRlc3QzIiwibGV0dGVyIiwidG8iLCJzeW1ib2xzIiwicGF0aE1vZHVsZSIsIm5vZGVfMSIsInNldEltbWVkaWF0ZV8xIiwicHJvY2Vzc18xIiwic2V0VGltZW91dFVucmVmXzEiLCJzdHJlYW1fMSIsImV2ZW50c18xIiwiZXh0ZW5kIiwicHJvbWlzZXNfMSIsInJlc29sdmVDcm9zc1BsYXRmb3JtIiwic2VwIiwicmVsYXRpdmUiLCJwb3NpeCIsImlzV2luIiwicGxhdGZvcm0iLCJrTWluUG9vbFNwYWNlIiwiRVJSU1RSIiwiUEFUSF9TVFIiLCJGRCIsIk1PREVfSU5UIiwiQ0IiLCJVSUQiLCJHSUQiLCJMRU4iLCJBVElNRSIsIk1USU1FIiwiUFJFRklYIiwiQlVGRkVSIiwiT0ZGU0VUIiwiTEVOR1RIIiwiUE9TSVRJT04iLCJFUlJTVFJfT1BUUyIsInRpcGVvZiIsIkVOT0VOVCIsIkVCQURGIiwiRUlOVkFMIiwiRVBFUk0iLCJFUFJPVE8iLCJFRVhJU1QiLCJFTk9URElSIiwiRU1GSUxFIiwiRUFDQ0VTIiwiRUlTRElSIiwiRU5PVEVNUFRZIiwiRU5PU1lTIiwiZXJyb3JDb2RlIiwicGF0aCIsInBhdGgyIiwicGF0aEZvcm1hdHRlZCIsImNyZWF0ZUVycm9yIiwiQ29uc3RydWN0b3IiLCJ0aHJvd0Vycm9yIiwiRkxBR1MiLCJ3eCIsImF4IiwiZmxhZ3NUb051bWJlciIsImZsYWdzIiwiZmxhZ3NOdW0iLCJnZXRPcHRpb25zIiwiZGVmYXVsdHMiLCJvcHRzR2VuZXJhdG9yIiwidmFsaWRhdGVDYWxsYmFjayIsIm9wdHNBbmRDYkdlbmVyYXRvciIsImdldE9wdHMiLCJvcHRzRGVmYXVsdHMiLCJnZXREZWZhdWx0T3B0cyIsImdldERlZmF1bHRPcHRzQW5kQ2IiLCJyZWFkRmlsZU9wdHNEZWZhdWx0cyIsImZsYWciLCJnZXRSZWFkRmlsZU9wdGlvbnMiLCJ3cml0ZUZpbGVEZWZhdWx0cyIsImdldFdyaXRlRmlsZU9wdGlvbnMiLCJhcHBlbmRGaWxlRGVmYXVsdHMiLCJnZXRBcHBlbmRGaWxlT3B0cyIsImdldEFwcGVuZEZpbGVPcHRzQW5kQ2IiLCJyZWFscGF0aERlZmF1bHRzIiwiZ2V0UmVhbHBhdGhPcHRpb25zIiwiZ2V0UmVhbHBhdGhPcHRzQW5kQ2IiLCJta2RpckRlZmF1bHRzIiwicmVjdXJzaXZlIiwiZ2V0TWtkaXJPcHRpb25zIiwicmVhZGRpckRlZmF1bHRzIiwid2l0aEZpbGVUeXBlcyIsImdldFJlYWRkaXJPcHRpb25zIiwiZ2V0UmVhZGRpck9wdHNBbmRDYiIsInN0YXREZWZhdWx0cyIsImdldFN0YXRPcHRpb25zIiwiZ2V0U3RhdE9wdHNBbmRDYiIsImdldFBhdGhGcm9tVVJMUG9zaXgiLCJ1cmwiLCJob3N0bmFtZSIsInBhdGhuYW1lIiwidGhpcmQiLCJjb2RlUG9pbnRBdCIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhdGhUb0ZpbGVuYW1lIiwiVVJMIiwicGF0aFN0cmluZyIsIm51bGxDaGVjayIsImZpbGVuYW1lIiwiX3Jlc29sdmVfMSIsInVuaXhpZnlfMSIsInVuaXhpZnkiLCJmaWxlbmFtZVRvU3RlcHMiLCJmdWxsUGF0aCIsImZ1bGxQYXRoU2Fuc1NsYXNoIiwicGF0aFRvU3RlcHMiLCJkYXRhVG9TdHIiLCJkYXRhVG9CdWZmZXIiLCJidWZmZXJUb0VuY29kaW5nIiwiX21vZGVUb051bWJlciIsImRlZiIsIm1vZGVUb051bWJlciIsInJlc3VsdCIsImlzRmQiLCJ2YWxpZGF0ZUZkIiwiZmQiLCJub3ciLCJnZXRBcmdBbmRDYiIsInZhbGlkYXRlVWlkIiwidmFsaWRhdGVHaWQiLCJwcm9wcyIsImlub2RlcyIsInJlbGVhc2VkSW5vcyIsImZkcyIsInJlbGVhc2VkRmRzIiwibWF4RmlsZXMiLCJvcGVuRmlsZXMiLCJwcm9taXNlc0FwaSIsInN0YXRXYXRjaGVycyIsIk5vZGUiLCJMaW5rIiwiRmlsZSIsInJvb3QiLCJjcmVhdGVMaW5rIiwic2V0Tm9kZSIsImNyZWF0ZU5vZGUiLCJfUmVhZFN0cmVhbSIsIkZzUmVhZFN0cmVhbSIsImNsYXNzXzEiLCJfV3JpdGVTdHJlYW0iLCJGc1dyaXRlU3RyZWFtIiwiY2xhc3NfMiIsImZyb21KU09OIiwianNvbiIsInBhcmVudCIsInBlcm0iLCJjcmVhdGVDaGlsZCIsImRlbGV0ZUxpbmsiLCJkZWxldGVDaGlsZCIsIm5ld0lub051bWJlciIsIm5ld0ZkTnVtYmVyIiwic2V0SXNEaXJlY3RvcnkiLCJkZWxldGVOb2RlIiwiZGVsIiwiZ2VuUm5kU3RyIiwicmFuZG9tIiwiZ2V0TGluayIsInN0ZXBzIiwid2FsayIsImdldExpbmtPclRocm93IiwiZnVuY05hbWUiLCJnZXRSZXNvbHZlZExpbmsiLCJmaWxlbmFtZU9yU3RlcHMiLCJzdGVwIiwiZ2V0Q2hpbGQiLCJpc1N5bWxpbmsiLCJzeW1saW5rIiwiZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyIsInJlc29sdmVTeW1saW5rcyIsImdldExpbmtBc0Rpck9yVGhyb3ciLCJnZXRMaW5rUGFyZW50IiwiZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyIsImdldEZpbGVCeUZkIiwiZ2V0RmlsZUJ5RmRPclRocm93IiwiZmlsZSIsImdldE5vZGVCeUlkT3JDcmVhdGUiLCJkaXJMaW5rIiwibmFtZV8xIiwid3JhcEFzeW5jIiwiX3RvSlNPTiIsImlzRW1wdHkiLCJjaGlsZHJlbiIsIm5hbWVfMiIsImNoaWxkIiwiZ2V0UGF0aCIsImdldFN0cmluZyIsImRpclBhdGgiLCJwYXRocyIsImlzUmVsYXRpdmUiLCJsaW5rcyIsInBhdGhzXzEiLCJsaW5rc18xIiwiZGlybmFtZSIsIm1rZGlycEJhc2UiLCJ3cml0ZUZpbGVTeW5jIiwicmVzZXQiLCJtb3VudFN5bmMiLCJtb3VudHBvaW50Iiwib3BlbkxpbmsiLCJyZWFsTGluayIsImNhblJlYWQiLCJvcGVuRmlsZSIsIm1vZGVOdW0iLCJvcGVuQmFzZSIsIm9wZW5TeW5jIiwiZmlsZU5hbWUiLCJvcGVuIiwiY2xvc2VGaWxlIiwiY2xvc2VTeW5jIiwib3BlbkZpbGVPckdldEJ5SWQiLCJyZWFkQmFzZSIsInJlYWRTeW5jIiwicmVhZEZpbGVCYXNlIiwiaXNVc2VyRmQiLCJ1c2VyT3duc0ZkIiwicmVhZEZpbGVTeW5jIiwicmVhZEZpbGUiLCJ3cml0ZUJhc2UiLCJ3cml0ZVN5bmMiLCJ0aXBhIiwidGlwYiIsInRpcGMiLCJ0aXBkIiwid3JpdGVGaWxlQmFzZSIsIndyaXR0ZW4iLCJ3cml0ZUZpbGUiLCJsaW5rQmFzZSIsImZpbGVuYW1lMSIsImZpbGVuYW1lMiIsInN0ZXBzMSIsImxpbmsxIiwic3RlcHMyIiwiZGlyMiIsImNvcHlGaWxlQmFzZSIsImV4aXN0c1N5bmMiLCJjb3B5RmlsZVN5bmMiLCJzcmNGaWxlbmFtZSIsImRlc3RGaWxlbmFtZSIsImNvcHlGaWxlIiwibGlua1N5bmMiLCJleGlzdGluZ1BhdGgiLCJuZXdQYXRoIiwiZXhpc3RpbmdQYXRoRmlsZW5hbWUiLCJuZXdQYXRoRmlsZW5hbWUiLCJ1bmxpbmtCYXNlIiwidW5saW5rU3luYyIsInVubGluayIsInN5bWxpbmtCYXNlIiwidGFyZ2V0RmlsZW5hbWUiLCJwYXRoRmlsZW5hbWUiLCJwYXRoU3RlcHMiLCJtYWtlU3ltbGluayIsInN5bWxpbmtTeW5jIiwicmVhbHBhdGhCYXNlIiwicmVhbHBhdGhTeW5jIiwicmVhbHBhdGgiLCJsc3RhdEJhc2UiLCJsc3RhdFN5bmMiLCJsc3RhdCIsInN0YXRCYXNlIiwic3RhdFN5bmMiLCJzdGF0IiwiZnN0YXRCYXNlIiwiZnN0YXRTeW5jIiwiZnN0YXQiLCJyZW5hbWVCYXNlIiwib2xkUGF0aEZpbGVuYW1lIiwibmV3UGF0aFN0ZXBzIiwibmV3UGF0aERpckxpbmsiLCJvbGRMaW5rUGFyZW50Iiwic2V0Q2hpbGQiLCJyZW5hbWVTeW5jIiwib2xkUGF0aCIsInJlbmFtZSIsImV4aXN0c0Jhc2UiLCJleGlzdHMiLCJhY2Nlc3NCYXNlIiwiYWNjZXNzU3luYyIsImFjY2VzcyIsImFwcGVuZEZpbGVTeW5jIiwiYXBwZW5kRmlsZSIsInJlYWRkaXJCYXNlIiwibGlzdF8xIiwibmFtZV8zIiwibmFtZV80IiwicmVhZGRpclN5bmMiLCJyZWFkZGlyIiwicmVhZGxpbmtCYXNlIiwicmVhZGxpbmtTeW5jIiwicmVhZGxpbmsiLCJmc3luY0Jhc2UiLCJmc3luY1N5bmMiLCJmc3luYyIsImZkYXRhc3luY0Jhc2UiLCJmZGF0YXN5bmNTeW5jIiwiZmRhdGFzeW5jIiwiZnRydW5jYXRlQmFzZSIsImZ0cnVuY2F0ZVN5bmMiLCJmdHJ1bmNhdGUiLCJ0cnVuY2F0ZUJhc2UiLCJ0cnVuY2F0ZVN5bmMiLCJmdXRpbWVzQmFzZSIsImZ1dGltZXNTeW5jIiwiZnV0aW1lcyIsInV0aW1lc0Jhc2UiLCJ1dGltZXNTeW5jIiwidXRpbWVzIiwibWtkaXJCYXNlIiwibWtkaXJTeW5jIiwibWtkaXIiLCJta2RpcnBTeW5jIiwibWtkaXJwIiwibWtkdGVtcEJhc2UiLCJwcmVmaXgiLCJyZXRyeSIsIm1rZHRlbXBTeW5jIiwibWtkdGVtcCIsInJtZGlyQmFzZSIsInJtZGlyU3luYyIsInJtZGlyIiwiZmNobW9kQmFzZSIsImNobW9kIiwiZmNobW9kU3luYyIsImZjaG1vZCIsImNobW9kQmFzZSIsImNobW9kU3luYyIsImxjaG1vZEJhc2UiLCJsY2htb2RTeW5jIiwibGNobW9kIiwiZmNob3duQmFzZSIsImNob3duIiwiZmNob3duU3luYyIsImZjaG93biIsImNob3duQmFzZSIsImNob3duU3luYyIsImxjaG93bkJhc2UiLCJsY2hvd25TeW5jIiwibGNob3duIiwid2F0Y2hGaWxlIiwiaW50ZXJ2YWwiLCJwZXJzaXN0ZW50Iiwid2F0Y2hlciIsInVud2F0Y2hGaWxlIiwic3RvcCIsImNyZWF0ZVJlYWRTdHJlYW0iLCJjcmVhdGVXcml0ZVN0cmVhbSIsIndhdGNoIiwiZW1pdFN0b3AiLCJ0aW1lb3V0UmVmIiwib25JbnRlcnZhbCIsImhhc0NoYW5nZWQiLCJsb29wIiwicG9vbCIsImFsbG9jTmV3UG9vbCIsInVzZWQiLCJfdm9sIiwiYXV0b0Nsb3NlIiwiYnl0ZXNSZWFkIiwidGhpc1Bvb2wiLCJ0b1JlYWQiLCJvbnJlYWQiLCJjbG9zZWQiLCJjbG9zZU9uT3BlbiIsImJ5dGVzV3JpdHRlbiIsImNodW5rcyIsImRlc3Ryb3lTb29uIiwiX2ZpbGVuYW1lIiwiX3N0ZXBzIiwiX2ZpbGVuYW1lRW5jb2RlZCIsIl9yZWN1cnNpdmUiLCJfZW5jb2RpbmciLCJfbGluayIsIl9vbk5vZGVDaGFuZ2UiLCJfZW1pdCIsIl9vblBhcmVudENoaWxkIiwiX2dldE5hbWUiLCJfcGVyc2lzdCIsIl90aW1lciIsImVycm5vIiwibm9ybWFsaXplQXJyYXkiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwicmVzb2x2ZWRQYXRoIiwicmVzb2x2ZWRBYnNvbHV0ZSIsImNoYXJBdCIsImZpbHRlciIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJ0cmFpbGluZ1NsYXNoIiwiZnJvbVBhcnRzIiwidG9QYXJ0cyIsInNhbWVQYXJ0c0xlbmd0aCIsIm91dHB1dFBhcnRzIiwiZGVsaW1pdGVyIiwiaGFzUm9vdCIsIm1hdGNoZWRTbGFzaCIsImJhc2VuYW1lIiwiZXh0bmFtZSIsInN0YXJ0RG90Iiwic3RhcnRQYXJ0IiwicHJlRG90U3RhdGUiLCJTRVAiLCJzZXRTdHJpbmciLCJ0b3VjaCIsInNldEJ1ZmZlciIsInNldE1vZGVQcm9wZXJ0eSIsInNldElzRmlsZSIsInNldElzU3ltbGluayIsImFjdHVhbExlbiIsImNhbldyaXRlIiwic2Vla1RvIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJkb2MiLCJkb2N1bWVudCIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImhhbmRsZSIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsInNldFRpbWVvdXRVbnJlZiIsIl9pc1N0ZGlvIiwiZGlkT25FbmQiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsImNvcHlCdWZmZXIiLCJjb25maWciLCJsb2NhbFN0b3JhZ2UiLCJnZXRSZXN1bHQiLCJpbnB1dCIsIkZpbGVIYW5kbGUiLCJkYXRhc3luYyIsImNyZWF0ZVByb21pc2VzQXBpIiwicHVueWNvZGUiLCJwYXJzZSIsInVybFBhcnNlIiwidXJsUmVzb2x2ZSIsInJlc29sdmVPYmplY3QiLCJ1cmxSZXNvbHZlT2JqZWN0IiwidXJsRm9ybWF0IiwiVXJsIiwicHJvdG9jb2wiLCJzbGFzaGVzIiwiYXV0aCIsImhvc3QiLCJwb3J0Iiwic2VhcmNoIiwicXVlcnkiLCJocmVmIiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInF1ZXJ5c3RyaW5nIiwicGFyc2VRdWVyeVN0cmluZyIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsInF1ZXJ5SW5kZXgiLCJzcGxpdHRlciIsInVTcGxpdCIsInNsYXNoUmVnZXgiLCJyZXN0Iiwic2ltcGxlUGF0aCIsImV4ZWMiLCJwcm90byIsImxvd2VyUHJvdG8iLCJob3N0RW5kIiwiaGVjIiwiYXRTaWduIiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInRvQVNDSUkiLCJoIiwiYWUiLCJlc2MiLCJlbmNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJxbSIsInJlbCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsImF1dGhJbkhvc3QiLCJoYXNUcmFpbGluZ1NsYXNoIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJmcmVlR2xvYmFsIiwibWF4SW50IiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImJhc2VNaW51c1RNaW4iLCJzdHJpbmdGcm9tQ2hhckNvZGUiLCJtYXBEb21haW4iLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImFkYXB0IiwiZGVsdGEiLCJudW1Qb2ludHMiLCJmaXJzdFRpbWUiLCJkZWNvZGUiLCJpbnB1dExlbmd0aCIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJiYXNlTWludXNUIiwiZW5jb2RlIiwiaGFuZGxlZENQQ291bnQiLCJiYXNpY0xlbmd0aCIsInEiLCJjdXJyZW50VmFsdWUiLCJoYW5kbGVkQ1BDb3VudFBsdXNPbmUiLCJxTWludXNUIiwidG9Vbmljb2RlIiwiZGVmaW5lIiwid2VicGFja1BvbHlmaWxsIiwicXMiLCJlcSIsInJlZ2V4cCIsIm1heEtleXMiLCJrc3RyIiwidnN0ciIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImtzIiwiY29ycmVjdFBhdGgiLCJyZW1vdmVUcmFpbGluZ1NlcGFyYXRvciIsImlzU2VwYXJhdG9yIiwiY2hhciIsIm5vcm1hbGl6ZVBhdGgiLCJzdHJpcFRyYWlsaW5nIiwiZmlsZXBhdGgiLCJmc1Byb3BzIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOztRQUVBO1FBQ0E7Ozs7Ozs7Ozs7OztBQzdEQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBS0MsU0FBUyxhQUFULEdBQUwsSUFBa0MsQ0FBQyxHQUFFQyxJQUFILEVBQVMsTUFBVCxDQUF0QztBQUNBLENBSEQsQ0FHRSxPQUFNQyxDQUFOLEVBQVM7QUFDVjtBQUNBLEtBQUcsUUFBT0MsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFyQixFQUNDSixJQUFJSSxNQUFKO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOztBQUVBQyxPQUFPQyxPQUFQLEdBQWlCTixDQUFqQixDOzs7Ozs7Ozs7QUNwQkE7QUFDQSxJQUFJTyxVQUFVRixPQUFPQyxPQUFQLEdBQWlC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QUF6TSxFQUFvTixPQUFwTixFQUE2TixNQUE3TixFQUFxTyxRQUFyTyxFQUErTyxTQUEvTyxFQUEwUCxPQUExUCxFQUFtUSxPQUFuUSxFQUE0USxNQUE1USxFQUFvUixVQUFwUixFQUFnUyxXQUFoUyxFQUE2UyxZQUE3UyxFQUEyVCxRQUEzVCxFQUFxVSxRQUFyVSxFQUErVSxXQUEvVSxFQUE0VixTQUE1VixFQUF1VyxVQUF2VyxFQUFtWCxXQUFuWCxFQUFnWSxhQUFoWSxFQUErWSxPQUEvWSxDQUE5QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAyYjhmOGI3ZjFlZWNkYWZkZTc0YSIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICAgIE9fUkRPTkxZOiAwLFxuICAgIE9fV1JPTkxZOiAxLFxuICAgIE9fUkRXUjogMixcbiAgICBTX0lGTVQ6IDYxNDQwLFxuICAgIFNfSUZSRUc6IDMyNzY4LFxuICAgIFNfSUZESVI6IDE2Mzg0LFxuICAgIFNfSUZDSFI6IDgxOTIsXG4gICAgU19JRkJMSzogMjQ1NzYsXG4gICAgU19JRklGTzogNDA5NixcbiAgICBTX0lGTE5LOiA0MDk2MCxcbiAgICBTX0lGU09DSzogNDkxNTIsXG4gICAgT19DUkVBVDogNjQsXG4gICAgT19FWENMOiAxMjgsXG4gICAgT19OT0NUVFk6IDI1NixcbiAgICBPX1RSVU5DOiA1MTIsXG4gICAgT19BUFBFTkQ6IDEwMjQsXG4gICAgT19ESVJFQ1RPUlk6IDY1NTM2LFxuICAgIE9fTk9BVElNRTogMjYyMTQ0LFxuICAgIE9fTk9GT0xMT1c6IDEzMTA3MixcbiAgICBPX1NZTkM6IDEwNTI2NzIsXG4gICAgT19ESVJFQ1Q6IDE2Mzg0LFxuICAgIE9fTk9OQkxPQ0s6IDIwNDgsXG4gICAgU19JUldYVTogNDQ4LFxuICAgIFNfSVJVU1I6IDI1NixcbiAgICBTX0lXVVNSOiAxMjgsXG4gICAgU19JWFVTUjogNjQsXG4gICAgU19JUldYRzogNTYsXG4gICAgU19JUkdSUDogMzIsXG4gICAgU19JV0dSUDogMTYsXG4gICAgU19JWEdSUDogOCxcbiAgICBTX0lSV1hPOiA3LFxuICAgIFNfSVJPVEg6IDQsXG4gICAgU19JV09USDogMixcbiAgICBTX0lYT1RIOiAxLFxuICAgIEZfT0s6IDAsXG4gICAgUl9PSzogNCxcbiAgICBXX09LOiAyLFxuICAgIFhfT0s6IDEsXG4gICAgVVZfRlNfU1lNTElOS19ESVI6IDEsXG4gICAgVVZfRlNfU1lNTElOS19KVU5DVElPTjogMixcbiAgICBVVl9GU19DT1BZRklMRV9FWENMOiAxLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgVVZfRlNfQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbiAgICBDT1BZRklMRV9FWENMOiAxLFxuICAgIENPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2NvbnN0YW50cy5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYiwgbnVsbCwgcmV0KSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLCByZWosIGNiKSB9KTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihjYWxsYmFja2lmaWVkLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2FsbGJhY2tpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbCkpO1xuICByZXR1cm4gY2FsbGJhY2tpZmllZDtcbn1cbmV4cG9ydHMuY2FsbGJhY2tpZnkgPSBjYWxsYmFja2lmeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBnZXRCaWdJbnRfMSA9IHJlcXVpcmUoXCIuL2dldEJpZ0ludFwiKTtcbnZhciBTX0lGTVQgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRk1ULCBTX0lGRElSID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZESVIsIFNfSUZSRUcgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRlJFRywgU19JRkJMSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGQkxLLCBTX0lGQ0hSID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZDSFIsIFNfSUZMTksgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkxOSywgU19JRklGTyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGSUZPLCBTX0lGU09DSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGU09DSztcbi8qKlxuICogU3RhdGlzdGljcyBhYm91dCBhIGZpbGUvZGlyZWN0b3J5LCBsaWtlIGBmcy5TdGF0c2AuXG4gKi9cbnZhciBTdGF0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0cygpIHtcbiAgICB9XG4gICAgU3RhdHMuYnVpbGQgPSBmdW5jdGlvbiAobm9kZSwgYmlnaW50KSB7XG4gICAgICAgIGlmIChiaWdpbnQgPT09IHZvaWQgMCkgeyBiaWdpbnQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc3RhdHMgPSBuZXcgU3RhdHMoKTtcbiAgICAgICAgdmFyIHVpZCA9IG5vZGUudWlkLCBnaWQgPSBub2RlLmdpZCwgYXRpbWUgPSBub2RlLmF0aW1lLCBtdGltZSA9IG5vZGUubXRpbWUsIGN0aW1lID0gbm9kZS5jdGltZTtcbiAgICAgICAgdmFyIGdldFN0YXROdW1iZXIgPSAhYmlnaW50ID8gZnVuY3Rpb24gKG51bWJlcikgeyByZXR1cm4gbnVtYmVyOyB9IDogZ2V0QmlnSW50XzEuZGVmYXVsdDtcbiAgICAgICAgLy8gQ29weSBhbGwgdmFsdWVzIG9uIFN0YXRzIGZyb20gTm9kZSwgc28gdGhhdCBpZiBOb2RlIHZhbHVlc1xuICAgICAgICAvLyBjaGFuZ2UsIHZhbHVlcyBvbiBTdGF0cyB3b3VsZCBzdGlsbCBiZSB0aGUgb2xkIG9uZXMsXG4gICAgICAgIC8vIGp1c3QgbGlrZSBpbiBOb2RlIGZzLlxuICAgICAgICBzdGF0cy51aWQgPSBnZXRTdGF0TnVtYmVyKHVpZCk7XG4gICAgICAgIHN0YXRzLmdpZCA9IGdldFN0YXROdW1iZXIoZ2lkKTtcbiAgICAgICAgc3RhdHMucmRldiA9IGdldFN0YXROdW1iZXIoMCk7XG4gICAgICAgIHN0YXRzLmJsa3NpemUgPSBnZXRTdGF0TnVtYmVyKDQwOTYpO1xuICAgICAgICBzdGF0cy5pbm8gPSBnZXRTdGF0TnVtYmVyKG5vZGUuaW5vKTtcbiAgICAgICAgc3RhdHMuc2l6ZSA9IGdldFN0YXROdW1iZXIobm9kZS5nZXRTaXplKCkpO1xuICAgICAgICBzdGF0cy5ibG9ja3MgPSBnZXRTdGF0TnVtYmVyKDEpO1xuICAgICAgICBzdGF0cy5hdGltZSA9IGF0aW1lO1xuICAgICAgICBzdGF0cy5tdGltZSA9IG10aW1lO1xuICAgICAgICBzdGF0cy5jdGltZSA9IGN0aW1lO1xuICAgICAgICBzdGF0cy5iaXJ0aHRpbWUgPSBjdGltZTtcbiAgICAgICAgc3RhdHMuYXRpbWVNcyA9IGdldFN0YXROdW1iZXIoYXRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgc3RhdHMubXRpbWVNcyA9IGdldFN0YXROdW1iZXIobXRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgdmFyIGN0aW1lTXMgPSBnZXRTdGF0TnVtYmVyKGN0aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIHN0YXRzLmN0aW1lTXMgPSBjdGltZU1zO1xuICAgICAgICBzdGF0cy5iaXJ0aHRpbWVNcyA9IGN0aW1lTXM7XG4gICAgICAgIHN0YXRzLmRldiA9IGdldFN0YXROdW1iZXIoMCk7XG4gICAgICAgIHN0YXRzLm1vZGUgPSBnZXRTdGF0TnVtYmVyKG5vZGUubW9kZSk7XG4gICAgICAgIHN0YXRzLm5saW5rID0gZ2V0U3RhdE51bWJlcihub2RlLm5saW5rKTtcbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH07XG4gICAgU3RhdHMucHJvdG90eXBlLl9jaGVja01vZGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gKE51bWJlcih0aGlzLm1vZGUpICYgU19JRk1UKSA9PT0gcHJvcGVydHk7XG4gICAgfTtcbiAgICBTdGF0cy5wcm90b3R5cGUuaXNEaXJlY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGRElSKTtcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5pc0Jsb2NrRGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkJMSyk7XG4gICAgfTtcbiAgICBTdGF0cy5wcm90b3R5cGUuaXNDaGFyYWN0ZXJEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGQ0hSKTtcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5pc1N5bWJvbGljTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH07XG4gICAgU3RhdHMucHJvdG90eXBlLmlzRklGTyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZJRk8pO1xuICAgIH07XG4gICAgU3RhdHMucHJvdG90eXBlLmlzU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlNPQ0spO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRzO1xufSgpKTtcbmV4cG9ydHMuU3RhdHMgPSBTdGF0cztcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9TdGF0cy5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuZXhwb3J0cy5CdWZmZXIgPSBidWZmZXJfMS5CdWZmZXI7XG5mdW5jdGlvbiBidWZmZXJWMFAxMlBvbnlmaWxsKGFyZzApIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgKGJ1ZmZlcl8xLkJ1ZmZlci5iaW5kLmFwcGx5KGJ1ZmZlcl8xLkJ1ZmZlciwgX19zcHJlYWRBcnJheXMoW3ZvaWQgMCwgYXJnMF0sIGFyZ3MpKSkoKTtcbn1cbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvY1Vuc2FmZSB8fCBidWZmZXJWMFAxMlBvbnlmaWxsO1xuZXhwb3J0cy5idWZmZXJBbGxvY1Vuc2FmZSA9IGJ1ZmZlckFsbG9jVW5zYWZlO1xudmFyIGJ1ZmZlckZyb20gPSBidWZmZXJfMS5CdWZmZXIuZnJvbSB8fCBidWZmZXJWMFAxMlBvbnlmaWxsO1xuZXhwb3J0cy5idWZmZXJGcm9tID0gYnVmZmVyRnJvbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW50ZXJuYWwvYnVmZmVyLmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbnZhciBTX0lGTVQgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRk1ULCBTX0lGRElSID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZESVIsIFNfSUZSRUcgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRlJFRywgU19JRkJMSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGQkxLLCBTX0lGQ0hSID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZDSFIsIFNfSUZMTksgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkxOSywgU19JRklGTyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGSUZPLCBTX0lGU09DSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGU09DSztcbi8qKlxuICogQSBkaXJlY3RvcnkgZW50cnksIGxpa2UgYGZzLkRpcmVudGAuXG4gKi9cbnZhciBEaXJlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGlyZW50KCkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5tb2RlID0gMDtcbiAgICB9XG4gICAgRGlyZW50LmJ1aWxkID0gZnVuY3Rpb24gKGxpbmssIGVuY29kaW5nKSB7XG4gICAgICAgIHZhciBkaXJlbnQgPSBuZXcgRGlyZW50KCk7XG4gICAgICAgIHZhciBtb2RlID0gbGluay5nZXROb2RlKCkubW9kZTtcbiAgICAgICAgZGlyZW50Lm5hbWUgPSBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcobGluay5nZXROYW1lKCksIGVuY29kaW5nKTtcbiAgICAgICAgZGlyZW50Lm1vZGUgPSBtb2RlO1xuICAgICAgICByZXR1cm4gZGlyZW50O1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5fY2hlY2tNb2RlUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBwcm9wZXJ0eTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNEaXJlY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGRElSKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlJFRyk7XG4gICAgfTtcbiAgICBEaXJlbnQucHJvdG90eXBlLmlzQmxvY2tEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGQkxLKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNDaGFyYWN0ZXJEZXZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGQ0hSKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNTeW1ib2xpY0xpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGTE5LKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNGSUZPID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRklGTyk7XG4gICAgfTtcbiAgICBEaXJlbnQucHJvdG90eXBlLmlzU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlNPQ0spO1xuICAgIH07XG4gICAgcmV0dXJuIERpcmVudDtcbn0oKSk7XG5leHBvcnRzLkRpcmVudCA9IERpcmVudDtcbmV4cG9ydHMuZGVmYXVsdCA9IERpcmVudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvRGlyZW50LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9idWZmZXJcIik7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvZXJyb3JzXCIpO1xuZXhwb3J0cy5FTkNPRElOR19VVEY4ID0gJ3V0ZjgnO1xuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgJiYgIWJ1ZmZlcl8xLkJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSlcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX09QVF9WQUxVRV9FTkNPRElORycsIGVuY29kaW5nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0RW5jb2RpbmcgPSBhc3NlcnRFbmNvZGluZztcbmZ1bmN0aW9uIHN0clRvRW5jb2Rpbmcoc3RyLCBlbmNvZGluZykge1xuICAgIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09IGV4cG9ydHMuRU5DT0RJTkdfVVRGOClcbiAgICAgICAgcmV0dXJuIHN0cjsgLy8gVVRGLThcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdidWZmZXInKVxuICAgICAgICByZXR1cm4gbmV3IGJ1ZmZlcl8xLkJ1ZmZlcihzdHIpOyAvLyBgYnVmZmVyYCBlbmNvZGluZ1xuICAgIHJldHVybiBuZXcgYnVmZmVyXzEuQnVmZmVyKHN0cikudG9TdHJpbmcoZW5jb2RpbmcpOyAvLyBDdXN0b20gZW5jb2Rpbmdcbn1cbmV4cG9ydHMuc3RyVG9FbmNvZGluZyA9IHN0clRvRW5jb2Rpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2VuY29kaW5nLmpzIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xuLy8gVGhlIHdob2xlIHBvaW50IGJlaGluZCB0aGlzIGludGVybmFsIG1vZHVsZSBpcyB0byBhbGxvdyBOb2RlLmpzIHRvIG5vXG4vLyBsb25nZXIgYmUgZm9yY2VkIHRvIHRyZWF0IGV2ZXJ5IGVycm9yIG1lc3NhZ2UgY2hhbmdlIGFzIGEgc2VtdmVyLW1ham9yXG4vLyBjaGFuZ2UuIFRoZSBOb2RlRXJyb3IgY2xhc3NlcyBoZXJlIGFsbCBleHBvc2UgYSBgY29kZWAgcHJvcGVydHkgd2hvc2Vcbi8vIHZhbHVlIHN0YXRpY2FsbHkgYW5kIHBlcm1hbmVudGx5IGlkZW50aWZpZXMgdGhlIGVycm9yLiBXaGlsZSB0aGUgZXJyb3Jcbi8vIG1lc3NhZ2UgbWF5IGNoYW5nZSwgdGhlIGNvZGUgc2hvdWxkIG5vdC5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGtDb2RlID0gdHlwZW9mIFN5bWJvbCA9PT0gJ3VuZGVmaW5lZCcgPyAnX2tDb2RlJyA6IFN5bWJvbCgnY29kZScpO1xudmFyIG1lc3NhZ2VzID0ge307IC8vIG5ldyBNYXAoKTtcbi8vIExhemlseSBsb2FkZWRcbnZhciBhc3NlcnQgPSBudWxsO1xudmFyIHV0aWwgPSBudWxsO1xuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcihCYXNlKSB7XG4gICAgcmV0dXJuIC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5vZGVFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTm9kZUVycm9yKGtleSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2Uoa2V5LCBhcmdzKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSBrZXk7XG4gICAgICAgICAgICBfdGhpc1trQ29kZV0gPSBrZXk7XG4gICAgICAgICAgICBfdGhpcy5uYW1lID0gX3N1cGVyLnByb3RvdHlwZS5uYW1lICsgXCIgW1wiICsgX3RoaXNba0NvZGVdICsgXCJdXCI7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgICB9KEJhc2UpKTtcbn1cbnZhciBBc3NlcnRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNzZXJ0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleHBvcnRzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfQVJHX1RZUEUnLCAnb3B0aW9ucycsICdvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMubWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1dGlsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdXRpbC5pbnNwZWN0KG9wdGlvbnMuYWN0dWFsKS5zbGljZSgwLCAxMjgpICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChvcHRpb25zLm9wZXJhdG9yICsgXCIgXCIgKyB1dGlsLmluc3BlY3Qob3B0aW9ucy5leHBlY3RlZCkuc2xpY2UoMCwgMTI4KSkpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFvcHRpb25zLm1lc3NhZ2U7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3IgW0VSUl9BU1NFUlRJT05dJztcbiAgICAgICAgX3RoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICAgICAgX3RoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gICAgICAgIF90aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgICAgICAgX3RoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICAgICAgICBleHBvcnRzLkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEFzc2VydGlvbkVycm9yO1xufShnbG9iYWwuRXJyb3IpKTtcbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbmZ1bmN0aW9uIG1lc3NhZ2Uoa2V5LCBhcmdzKSB7XG4gICAgaWYgKGFzc2VydCA9PT0gbnVsbCkge1xuICAgICAgICBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbiAgICB9XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBrZXksICdzdHJpbmcnKTtcbiAgICAvLyBjb25zdCBtc2cgPSBtZXNzYWdlcy5nZXQoa2V5KTtcbiAgICB2YXIgbXNnID0gbWVzc2FnZXNba2V5XTtcbiAgICBhc3NlcnQobXNnLCBcIkFuIGludmFsaWQgZXJyb3IgbWVzc2FnZSBrZXkgd2FzIHVzZWQ6IFwiICsga2V5ICsgXCIuXCIpO1xuICAgIHZhciBmbXQ7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm10ID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm10ID0gdXRpbC5mb3JtYXQ7XG4gICAgICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbXNnO1xuICAgICAgICBhcmdzLnVuc2hpZnQobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhmbXQuYXBwbHkobnVsbCwgYXJncykpO1xufVxuZXhwb3J0cy5tZXNzYWdlID0gbWVzc2FnZTtcbi8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIHRoZSBlcnJvciBjb2Rlcy4gT25seSB1c2VkIGhlcmUuIEV4cG9ydGVkXG4vLyAqb25seSogdG8gYWxsb3cgZm9yIHRlc3RpbmcuXG5mdW5jdGlvbiBFKHN5bSwgdmFsKSB7XG4gICAgbWVzc2FnZXNbc3ltXSA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgPyB2YWwgOiBTdHJpbmcodmFsKTtcbn1cbmV4cG9ydHMuRSA9IEU7XG5leHBvcnRzLkVycm9yID0gbWFrZU5vZGVFcnJvcihnbG9iYWwuRXJyb3IpO1xuZXhwb3J0cy5UeXBlRXJyb3IgPSBtYWtlTm9kZUVycm9yKGdsb2JhbC5UeXBlRXJyb3IpO1xuZXhwb3J0cy5SYW5nZUVycm9yID0gbWFrZU5vZGVFcnJvcihnbG9iYWwuUmFuZ2VFcnJvcik7XG4vLyBUbyBkZWNsYXJlIGFuIGVycm9yIG1lc3NhZ2UsIHVzZSB0aGUgRShzeW0sIHZhbCkgZnVuY3Rpb24gYWJvdmUuIFRoZSBzeW1cbi8vIG11c3QgYmUgYW4gdXBwZXIgY2FzZSBzdHJpbmcuIFRoZSB2YWwgY2FuIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nLlxuLy8gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gbXVzdCBiZSBhIHN0cmluZy5cbi8vIEV4YW1wbGVzOlxuLy8gRSgnRVhBTVBMRV9LRVkxJywgJ1RoaXMgaXMgdGhlIGVycm9yIHZhbHVlJyk7XG4vLyBFKCdFWEFNUExFX0tFWTInLCAoYSwgYikgPT4gcmV0dXJuIGAke2F9ICR7Yn1gKTtcbi8vXG4vLyBPbmNlIGFuIGVycm9yIGNvZGUgaGFzIGJlZW4gYXNzaWduZWQsIHRoZSBjb2RlIGl0c2VsZiBNVVNUIE5PVCBjaGFuZ2UgYW5kXG4vLyBhbnkgZ2l2ZW4gZXJyb3IgY29kZSBtdXN0IG5ldmVyIGJlIHJldXNlZCB0byBpZGVudGlmeSBhIGRpZmZlcmVudCBlcnJvci5cbi8vXG4vLyBBbnkgZXJyb3IgY29kZSBhZGRlZCBoZXJlIHNob3VsZCBhbHNvIGJlIGFkZGVkIHRvIHRoZSBkb2N1bWVudGF0aW9uXG4vL1xuLy8gTm90ZTogUGxlYXNlIHRyeSB0byBrZWVwIHRoZXNlIGluIGFscGhhYmV0aWNhbCBvcmRlclxuRSgnRVJSX0FSR19OT1RfSVRFUkFCTEUnLCAnJXMgbXVzdCBiZSBpdGVyYWJsZScpO1xuRSgnRVJSX0FTU0VSVElPTicsICclcycpO1xuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJywgYnVmZmVyT3V0T2ZCb3VuZHMpO1xuRSgnRVJSX0NISUxEX0NMT1NFRF9CRUZPUkVfUkVQTFknLCAnQ2hpbGQgY2xvc2VkIGJlZm9yZSByZXBseSByZWNlaXZlZCcpO1xuRSgnRVJSX0NPTlNPTEVfV1JJVEFCTEVfU1RSRUFNJywgJ0NvbnNvbGUgZXhwZWN0cyBhIHdyaXRhYmxlIHN0cmVhbSBpbnN0YW5jZSBmb3IgJXMnKTtcbkUoJ0VSUl9DUFVfVVNBR0UnLCAnVW5hYmxlIHRvIG9idGFpbiBjcHUgdXNhZ2UgJXMnKTtcbkUoJ0VSUl9ETlNfU0VUX1NFUlZFUlNfRkFJTEVEJywgZnVuY3Rpb24gKGVyciwgc2VydmVycykgeyByZXR1cm4gXCJjLWFyZXMgZmFpbGVkIHRvIHNldCBzZXJ2ZXJzOiBcXFwiXCIgKyBlcnIgKyBcIlxcXCIgW1wiICsgc2VydmVycyArIFwiXVwiOyB9KTtcbkUoJ0VSUl9GQUxTWV9WQUxVRV9SRUpFQ1RJT04nLCAnUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBmYWxzeSB2YWx1ZScpO1xuRSgnRVJSX0VOQ09ESU5HX05PVF9TVVBQT1JURUQnLCBmdW5jdGlvbiAoZW5jKSB7IHJldHVybiBcIlRoZSBcXFwiXCIgKyBlbmMgKyBcIlxcXCIgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFwiOyB9KTtcbkUoJ0VSUl9FTkNPRElOR19JTlZBTElEX0VOQ09ERURfREFUQScsIGZ1bmN0aW9uIChlbmMpIHsgcmV0dXJuIFwiVGhlIGVuY29kZWQgZGF0YSB3YXMgbm90IHZhbGlkIGZvciBlbmNvZGluZyBcIiArIGVuYzsgfSk7XG5FKCdFUlJfSFRUUF9IRUFERVJTX1NFTlQnLCAnQ2Fubm90IHJlbmRlciBoZWFkZXJzIGFmdGVyIHRoZXkgYXJlIHNlbnQgdG8gdGhlIGNsaWVudCcpO1xuRSgnRVJSX0hUVFBfSU5WQUxJRF9TVEFUVVNfQ09ERScsICdJbnZhbGlkIHN0YXR1cyBjb2RlOiAlcycpO1xuRSgnRVJSX0hUVFBfVFJBSUxFUl9JTlZBTElEJywgJ1RyYWlsZXJzIGFyZSBpbnZhbGlkIHdpdGggdGhpcyB0cmFuc2ZlciBlbmNvZGluZycpO1xuRSgnRVJSX0lOREVYX09VVF9PRl9SQU5HRScsICdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgaW52YWxpZEFyZ1R5cGUpO1xuRSgnRVJSX0lOVkFMSURfQVJSQVlfTEVOR1RIJywgZnVuY3Rpb24gKG5hbWUsIGxlbiwgYWN0dWFsKSB7XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKHR5cGVvZiBhY3R1YWwsICdudW1iZXInKTtcbiAgICByZXR1cm4gXCJUaGUgYXJyYXkgXFxcIlwiICsgbmFtZSArIFwiXFxcIiAobGVuZ3RoIFwiICsgYWN0dWFsICsgXCIpIG11c3QgYmUgb2YgbGVuZ3RoIFwiICsgbGVuICsgXCIuXCI7XG59KTtcbkUoJ0VSUl9JTlZBTElEX0JVRkZFUl9TSVpFJywgJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAlcycpO1xuRSgnRVJSX0lOVkFMSURfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5FKCdFUlJfSU5WQUxJRF9DSEFSJywgJ0ludmFsaWQgY2hhcmFjdGVyIGluICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9DVVJTT1JfUE9TJywgJ0Nhbm5vdCBzZXQgY3Vyc29yIHJvdyB3aXRob3V0IHNldHRpbmcgaXRzIGNvbHVtbicpO1xuRSgnRVJSX0lOVkFMSURfRkQnLCAnXCJmZFwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyOiAlcycpO1xuRSgnRVJSX0lOVkFMSURfRklMRV9VUkxfSE9TVCcsICdGaWxlIFVSTCBob3N0IG11c3QgYmUgXCJsb2NhbGhvc3RcIiBvciBlbXB0eSBvbiAlcycpO1xuRSgnRVJSX0lOVkFMSURfRklMRV9VUkxfUEFUSCcsICdGaWxlIFVSTCBwYXRoICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9IQU5ETEVfVFlQRScsICdUaGlzIGhhbmRsZSB0eXBlIGNhbm5vdCBiZSBzZW50Jyk7XG5FKCdFUlJfSU5WQUxJRF9JUF9BRERSRVNTJywgJ0ludmFsaWQgSVAgYWRkcmVzczogJXMnKTtcbkUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHJldHVybiBcIlRoZSB2YWx1ZSBcXFwiXCIgKyBTdHJpbmcodmFsdWUpICsgXCJcXFwiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCI7XG59KTtcbkUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRV9FTkNPRElORycsIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gXCJUaGUgdmFsdWUgXFxcIlwiICsgU3RyaW5nKHZhbHVlKSArIFwiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcImVuY29kaW5nXFxcIlwiOyB9KTtcbkUoJ0VSUl9JTlZBTElEX1JFUExfRVZBTF9DT05GSUcnLCAnQ2Fubm90IHNwZWNpZnkgYm90aCBcImJyZWFrRXZhbE9uU2lnaW50XCIgYW5kIFwiZXZhbFwiIGZvciBSRVBMJyk7XG5FKCdFUlJfSU5WQUxJRF9TWU5DX0ZPUktfSU5QVVQnLCAnQXN5bmNocm9ub3VzIGZvcmtzIGRvIG5vdCBzdXBwb3J0IEJ1ZmZlciwgVWludDhBcnJheSBvciBzdHJpbmcgaW5wdXQ6ICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9USElTJywgJ1ZhbHVlIG9mIFwidGhpc1wiIG11c3QgYmUgb2YgdHlwZSAlcycpO1xuRSgnRVJSX0lOVkFMSURfVFVQTEUnLCAnJXMgbXVzdCBiZSBhbiBpdGVyYWJsZSAlcyB0dXBsZScpO1xuRSgnRVJSX0lOVkFMSURfVVJMJywgJ0ludmFsaWQgVVJMOiAlcycpO1xuRSgnRVJSX0lOVkFMSURfVVJMX1NDSEVNRScsIGZ1bmN0aW9uIChleHBlY3RlZCkgeyByZXR1cm4gXCJUaGUgVVJMIG11c3QgYmUgXCIgKyBvbmVPZihleHBlY3RlZCwgJ3NjaGVtZScpOyB9KTtcbkUoJ0VSUl9JUENfQ0hBTk5FTF9DTE9TRUQnLCAnQ2hhbm5lbCBjbG9zZWQnKTtcbkUoJ0VSUl9JUENfRElTQ09OTkVDVEVEJywgJ0lQQyBjaGFubmVsIGlzIGFscmVhZHkgZGlzY29ubmVjdGVkJyk7XG5FKCdFUlJfSVBDX09ORV9QSVBFJywgJ0NoaWxkIHByb2Nlc3MgY2FuIGhhdmUgb25seSBvbmUgSVBDIHBpcGUnKTtcbkUoJ0VSUl9JUENfU1lOQ19GT1JLJywgJ0lQQyBjYW5ub3QgYmUgdXNlZCB3aXRoIHN5bmNocm9ub3VzIGZvcmtzJyk7XG5FKCdFUlJfTUlTU0lOR19BUkdTJywgbWlzc2luZ0FyZ3MpO1xuRSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuRSgnRVJSX05BUElfQ09OU19GVU5DVElPTicsICdDb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbkUoJ0VSUl9OQVBJX0NPTlNfUFJPVE9UWVBFX09CSkVDVCcsICdDb25zdHJ1Y3Rvci5wcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3QnKTtcbkUoJ0VSUl9OT19DUllQVE8nLCAnTm9kZS5qcyBpcyBub3QgY29tcGlsZWQgd2l0aCBPcGVuU1NMIGNyeXB0byBzdXBwb3J0Jyk7XG5FKCdFUlJfTk9fTE9OR0VSX1NVUFBPUlRFRCcsICclcyBpcyBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG5FKCdFUlJfUEFSU0VfSElTVE9SWV9EQVRBJywgJ0NvdWxkIG5vdCBwYXJzZSBoaXN0b3J5IGRhdGEgaW4gJXMnKTtcbkUoJ0VSUl9TT0NLRVRfQUxSRUFEWV9CT1VORCcsICdTb2NrZXQgaXMgYWxyZWFkeSBib3VuZCcpO1xuRSgnRVJSX1NPQ0tFVF9CQURfUE9SVCcsICdQb3J0IHNob3VsZCBiZSA+IDAgYW5kIDwgNjU1MzYnKTtcbkUoJ0VSUl9TT0NLRVRfQkFEX1RZUEUnLCAnQmFkIHNvY2tldCB0eXBlIHNwZWNpZmllZC4gVmFsaWQgdHlwZXMgYXJlOiB1ZHA0LCB1ZHA2Jyk7XG5FKCdFUlJfU09DS0VUX0NBTk5PVF9TRU5EJywgJ1VuYWJsZSB0byBzZW5kIGRhdGEnKTtcbkUoJ0VSUl9TT0NLRVRfQ0xPU0VEJywgJ1NvY2tldCBpcyBjbG9zZWQnKTtcbkUoJ0VSUl9TT0NLRVRfREdSQU1fTk9UX1JVTk5JTkcnLCAnTm90IHJ1bm5pbmcnKTtcbkUoJ0VSUl9TVERFUlJfQ0xPU0UnLCAncHJvY2Vzcy5zdGRlcnIgY2Fubm90IGJlIGNsb3NlZCcpO1xuRSgnRVJSX1NURE9VVF9DTE9TRScsICdwcm9jZXNzLnN0ZG91dCBjYW5ub3QgYmUgY2xvc2VkJyk7XG5FKCdFUlJfU1RSRUFNX1dSQVAnLCAnU3RyZWFtIGhhcyBTdHJpbmdEZWNvZGVyIHNldCBvciBpcyBpbiBvYmplY3RNb2RlJyk7XG5FKCdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJywgXCJIb3N0bmFtZS9JUCBkb2VzIG5vdCBtYXRjaCBjZXJ0aWZpY2F0ZSdzIGFsdG5hbWVzOiAlc1wiKTtcbkUoJ0VSUl9UTFNfREhfUEFSQU1fU0laRScsIGZ1bmN0aW9uIChzaXplKSB7IHJldHVybiBcIkRIIHBhcmFtZXRlciBzaXplIFwiICsgc2l6ZSArIFwiIGlzIGxlc3MgdGhhbiAyMDQ4XCI7IH0pO1xuRSgnRVJSX1RMU19IQU5EU0hBS0VfVElNRU9VVCcsICdUTFMgaGFuZHNoYWtlIHRpbWVvdXQnKTtcbkUoJ0VSUl9UTFNfUkVORUdPVElBVElPTl9GQUlMRUQnLCAnRmFpbGVkIHRvIHJlbmVnb3RpYXRlJyk7XG5FKCdFUlJfVExTX1JFUVVJUkVEX1NFUlZFUl9OQU1FJywgJ1wic2VydmVybmFtZVwiIGlzIHJlcXVpcmVkIHBhcmFtZXRlciBmb3IgU2VydmVyLmFkZENvbnRleHQnKTtcbkUoJ0VSUl9UTFNfU0VTU0lPTl9BVFRBQ0snLCAnVFNMIHNlc3Npb24gcmVuZWdvdGlhdGlvbiBhdHRhY2sgZGV0ZWN0ZWQnKTtcbkUoJ0VSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcnLCAnQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuRSgnRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wJywgJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cml0YWJsZVN0YXRlLmxlbmd0aCAhPSAwJyk7XG5FKCdFUlJfVU5LTk9XTl9FTkNPRElORycsICdVbmtub3duIGVuY29kaW5nOiAlcycpO1xuRSgnRVJSX1VOS05PV05fU0lHTkFMJywgJ1Vua25vd24gc2lnbmFsOiAlcycpO1xuRSgnRVJSX1VOS05PV05fU1RESU5fVFlQRScsICdVbmtub3duIHN0ZGluIGZpbGUgdHlwZScpO1xuRSgnRVJSX1VOS05PV05fU1RSRUFNX1RZUEUnLCAnVW5rbm93biBzdHJlYW0gZmlsZSB0eXBlJyk7XG5FKCdFUlJfVjhCUkVBS0lURVJBVE9SJywgJ0Z1bGwgSUNVIGRhdGEgbm90IGluc3RhbGxlZC4gJyArICdTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3dpa2kvSW50bCcpO1xuZnVuY3Rpb24gaW52YWxpZEFyZ1R5cGUobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAgIGFzc2VydChuYW1lLCAnbmFtZSBpcyByZXF1aXJlZCcpO1xuICAgIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gICAgdmFyIGRldGVybWluZXI7XG4gICAgaWYgKGV4cGVjdGVkLmluY2x1ZGVzKCdub3QgJykpIHtcbiAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQuc3BsaXQoJ25vdCAnKVsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gICAgfVxuICAgIHZhciBtc2c7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgdmFyIG5hbWVzID0gbmFtZS5tYXAoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gXCJcXFwiXCIgKyB2YWwgKyBcIlxcXCJcIjsgfSkuam9pbignLCAnKTtcbiAgICAgICAgbXNnID0gXCJUaGUgXCIgKyBuYW1lcyArIFwiIGFyZ3VtZW50cyBcIiArIGRldGVybWluZXIgKyBcIiBcIiArIG9uZU9mKGV4cGVjdGVkLCAndHlwZScpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluY2x1ZGVzKCcgYXJndW1lbnQnKSkge1xuICAgICAgICAvLyBmb3IgdGhlIGNhc2UgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgICAgIG1zZyA9IFwiVGhlIFwiICsgbmFtZSArIFwiIFwiICsgZGV0ZXJtaW5lciArIFwiIFwiICsgb25lT2YoZXhwZWN0ZWQsICd0eXBlJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdHlwZSA9IG5hbWUuaW5jbHVkZXMoJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgICAgICBtc2cgPSBcIlRoZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIFwiICsgdHlwZSArIFwiIFwiICsgZGV0ZXJtaW5lciArIFwiIFwiICsgb25lT2YoZXhwZWN0ZWQsICd0eXBlJyk7XG4gICAgfVxuICAgIC8vIGlmIGFjdHVhbCB2YWx1ZSByZWNlaXZlZCwgb3V0cHV0IGl0XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xuICAgICAgICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIgKyAoYWN0dWFsICE9PSBudWxsID8gdHlwZW9mIGFjdHVhbCA6ICdudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59XG5mdW5jdGlvbiBtaXNzaW5nQXJncygpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgYXNzZXJ0KGFyZ3MubGVuZ3RoID4gMCwgJ0F0IGxlYXN0IG9uZSBhcmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgdmFyIG1zZyA9ICdUaGUgJztcbiAgICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBcIlxcXCJcIiArIGEgKyBcIlxcXCJcIjsgfSk7XG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgbXNnICs9IGFyZ3NbMF0gKyBcIiBhcmd1bWVudFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIG1zZyArPSBhcmdzWzBdICsgXCIgYW5kIFwiICsgYXJnc1sxXSArIFwiIGFyZ3VtZW50c1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtc2cgKz0gYXJncy5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpO1xuICAgICAgICAgICAgbXNnICs9IFwiLCBhbmQgXCIgKyBhcmdzW2xlbiAtIDFdICsgXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG1zZyArIFwiIG11c3QgYmUgc3BlY2lmaWVkXCI7XG59XG5mdW5jdGlvbiBvbmVPZihleHBlY3RlZCwgdGhpbmcpIHtcbiAgICBhc3NlcnQoZXhwZWN0ZWQsICdleHBlY3RlZCBpcyByZXF1aXJlZCcpO1xuICAgIGFzc2VydCh0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnLCAndGhpbmcgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICAgICAgYXNzZXJ0KGxlbiA+IDAsICdBdCBsZWFzdCBvbmUgZXhwZWN0ZWQgdmFsdWUgbmVlZHMgdG8gYmUgc3BlY2lmaWVkJyk7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gU3RyaW5nKGkpOyB9KTtcbiAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm9uZSBvZiBcIiArIHRoaW5nICsgXCIgXCIgKyBleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpICsgXCIsIG9yIFwiICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvbmUgb2YgXCIgKyB0aGluZyArIFwiIFwiICsgZXhwZWN0ZWRbMF0gKyBcIiBvciBcIiArIGV4cGVjdGVkWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwib2YgXCIgKyB0aGluZyArIFwiIFwiICsgZXhwZWN0ZWRbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcIm9mIFwiICsgdGhpbmcgKyBcIiBcIiArIFN0cmluZyhleHBlY3RlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVmZmVyT3V0T2ZCb3VuZHMobmFtZSwgaXNXcml0aW5nKSB7XG4gICAgaWYgKGlzV3JpdGluZykge1xuICAgICAgICByZXR1cm4gJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzXCI7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9pbnRlcm5hbC9lcnJvcnMuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8vIEhlcmUgd2UgbW9jayB0aGUgZ2xvYmFsIGBwcm9jZXNzYCB2YXJpYWJsZSBpbiBjYXNlIHdlIGFyZSBub3QgaW4gTm9kZSdzIGVudmlyb25tZW50LlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBMb29rcyB0byByZXR1cm4gYSBgcHJvY2Vzc2Agb2JqZWN0LCBpZiBvbmUgaXMgYXZhaWxhYmxlLlxuICpcbiAqIFRoZSBnbG9iYWwgYHByb2Nlc3NgIGlzIHJldHVybmVkIGlmIGRlZmluZWQ7XG4gKiBvdGhlcndpc2UgYHJlcXVpcmUoJ3Byb2Nlc3MnKWAgaXMgYXR0ZW1wdGVkLlxuICpcbiAqIElmIHRoYXQgZmFpbHMsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEByZXR1cm4ge0lQcm9jZXNzIHwgdW5kZWZpbmVkfVxuICovXG52YXIgbWF5YmVSZXR1cm5Qcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3M7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKCdwcm9jZXNzJyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQcm9jZXNzKCkge1xuICAgIHZhciBwID0gbWF5YmVSZXR1cm5Qcm9jZXNzKCkgfHwge307XG4gICAgaWYgKCFwLmdldHVpZClcbiAgICAgICAgcC5nZXR1aWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgIGlmICghcC5nZXRnaWQpXG4gICAgICAgIHAuZ2V0Z2lkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfTtcbiAgICBpZiAoIXAuY3dkKVxuICAgICAgICBwLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJzsgfTtcbiAgICBpZiAoIXAubmV4dFRpY2spXG4gICAgICAgIHAubmV4dFRpY2sgPSByZXF1aXJlKCcuL3NldEltbWVkaWF0ZScpLmRlZmF1bHQ7XG4gICAgaWYgKCFwLmVtaXRXYXJuaW5nKVxuICAgICAgICBwLmVtaXRXYXJuaW5nID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIHR5cGUgKyAodHlwZSA/ICc6ICcgOiAnJykgKyBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICBpZiAoIXAuZW52KVxuICAgICAgICBwLmVudiA9IHt9O1xuICAgIHJldHVybiBwO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9jZXNzID0gY3JlYXRlUHJvY2VzcztcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVByb2Nlc3MoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvcHJvY2Vzcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9zZXRJbW1lZGlhdGU7XG5pZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICBfc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsKTtcbmVsc2VcbiAgICBfc2V0SW1tZWRpYXRlID0gc2V0VGltZW91dC5iaW5kKGdsb2JhbCk7XG5leHBvcnRzLmRlZmF1bHQgPSBfc2V0SW1tZWRpYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9zZXRJbW1lZGlhdGUuanMiLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7dm9sLCB3cml0ZUZpbGVTeW5jLCByZWFkRmlsZVN5bmN9IGZyb20gJ2ZzJztcblxud3JpdGVGaWxlU3luYygnL3RleHQudHh0JywgJ0hlbGxvIHdvcmxkIScpO1xuY29uc29sZS5sb2cocmVhZEZpbGVTeW5jKCcvdGV4dC50eHQnLCAndXRmOCcpKTtcbmNvbnNvbGUubG9nKHZvbC50b0pTT04oKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdGF0c18xID0gcmVxdWlyZShcIi4vU3RhdHNcIik7XG52YXIgRGlyZW50XzEgPSByZXF1aXJlKFwiLi9EaXJlbnRcIik7XG52YXIgdm9sdW1lXzEgPSByZXF1aXJlKFwiLi92b2x1bWVcIik7XG52YXIgX2EgPSByZXF1aXJlKCdmcy1tb25rZXkvbGliL3V0aWwvbGlzdHMnKSwgZnNTeW5jTWV0aG9kcyA9IF9hLmZzU3luY01ldGhvZHMsIGZzQXN5bmNNZXRob2RzID0gX2EuZnNBc3luY01ldGhvZHM7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgRl9PSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5GX09LLCBSX09LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlJfT0ssIFdfT0sgPSBjb25zdGFudHNfMS5jb25zdGFudHMuV19PSywgWF9PSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5YX09LO1xuZXhwb3J0cy5Wb2x1bWUgPSB2b2x1bWVfMS5Wb2x1bWU7XG4vLyBEZWZhdWx0IHZvbHVtZS5cbmV4cG9ydHMudm9sID0gbmV3IHZvbHVtZV8xLlZvbHVtZSgpO1xuZnVuY3Rpb24gY3JlYXRlRnNGcm9tVm9sdW1lKHZvbCkge1xuICAgIHZhciBmcyA9IHsgRl9PSzogRl9PSywgUl9PSzogUl9PSywgV19PSzogV19PSywgWF9PSzogWF9PSywgY29uc3RhbnRzOiBjb25zdGFudHNfMS5jb25zdGFudHMsIFN0YXRzOiBTdGF0c18xLmRlZmF1bHQsIERpcmVudDogRGlyZW50XzEuZGVmYXVsdCB9O1xuICAgIC8vIEJpbmQgRlMgbWV0aG9kcy5cbiAgICBmb3IgKHZhciBfaSA9IDAsIGZzU3luY01ldGhvZHNfMSA9IGZzU3luY01ldGhvZHM7IF9pIDwgZnNTeW5jTWV0aG9kc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWV0aG9kID0gZnNTeW5jTWV0aG9kc18xW19pXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2b2xbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZzW21ldGhvZF0gPSB2b2xbbWV0aG9kXS5iaW5kKHZvbCk7XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgZnNBc3luY01ldGhvZHNfMSA9IGZzQXN5bmNNZXRob2RzOyBfYSA8IGZzQXN5bmNNZXRob2RzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBmc0FzeW5jTWV0aG9kc18xW19hXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2b2xbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZzW21ldGhvZF0gPSB2b2xbbWV0aG9kXS5iaW5kKHZvbCk7XG4gICAgfVxuICAgIGZzLlN0YXRXYXRjaGVyID0gdm9sLlN0YXRXYXRjaGVyO1xuICAgIGZzLkZTV2F0Y2hlciA9IHZvbC5GU1dhdGNoZXI7XG4gICAgZnMuV3JpdGVTdHJlYW0gPSB2b2wuV3JpdGVTdHJlYW07XG4gICAgZnMuUmVhZFN0cmVhbSA9IHZvbC5SZWFkU3RyZWFtO1xuICAgIGZzLnByb21pc2VzID0gdm9sLnByb21pc2VzO1xuICAgIGZzLl90b1VuaXhUaW1lc3RhbXAgPSB2b2x1bWVfMS50b1VuaXhUaW1lc3RhbXA7XG4gICAgcmV0dXJuIGZzO1xufVxuZXhwb3J0cy5jcmVhdGVGc0Zyb21Wb2x1bWUgPSBjcmVhdGVGc0Zyb21Wb2x1bWU7XG5leHBvcnRzLmZzID0gY3JlYXRlRnNGcm9tVm9sdW1lKGV4cG9ydHMudm9sKTtcbm1vZHVsZS5leHBvcnRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG1vZHVsZS5leHBvcnRzKSwgZXhwb3J0cy5mcyk7XG5tb2R1bGUuZXhwb3J0cy5zZW1hbnRpYyA9IHRydWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2luZGV4LmpzIiwiaWYgKHR5cGVvZiBCaWdJbnQgPT09ICdmdW5jdGlvbicpIGV4cG9ydHMuZGVmYXVsdCA9IEJpZ0ludDtcbmVsc2VcbiAgZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gQmlnSW50Tm90U3VwcG9ydGVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQmlnSW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nKTtcbiAgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvZ2V0QmlnSW50LmpzIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWwvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBvYmplY3RBc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGZ1bmN0aW9uc0hhdmVOYW1lcyA9IChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmb28oKSB7fS5uYW1lID09PSAnZm9vJztcbn0oKSk7XG5mdW5jdGlvbiBwVG9TdHJpbmcgKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG59XG5mdW5jdGlvbiBpc1ZpZXcoYXJyYnVmKSB7XG4gIGlmIChpc0J1ZmZlcihhcnJidWYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZ2xvYmFsLkFycmF5QnVmZmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyhhcnJidWYpO1xuICB9XG4gIGlmICghYXJyYnVmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcnJidWYgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChhcnJidWYuYnVmZmVyICYmIGFycmJ1Zi5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbnZhciByZWdleCA9IC9cXHMqZnVuY3Rpb25cXHMrKFteXFwoXFxzXSopXFxzKi87XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL2Z1bmN0aW9uLnByb3RvdHlwZS5uYW1lL2Jsb2IvYWRlZWVlYzhiZmNjNjA2OGIxODdkN2Q5ZmIzZDViYjFkM2EzMDg5OS9pbXBsZW1lbnRhdGlvbi5qc1xuZnVuY3Rpb24gZ2V0TmFtZShmdW5jKSB7XG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMpIHtcbiAgICByZXR1cm4gZnVuYy5uYW1lO1xuICB9XG4gIHZhciBzdHIgPSBmdW5jLnRvU3RyaW5nKCk7XG4gIHZhciBtYXRjaCA9IHN0ci5tYXRjaChyZWdleCk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBub24gdjggYnJvd3NlcnMgc28gd2UgY2FuIGhhdmUgYSBzdGFja3RyYWNlXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xuICAgIGlmIChlcnIuc3RhY2spIHtcbiAgICAgIHZhciBvdXQgPSBlcnIuc3RhY2s7XG5cbiAgICAgIC8vIHRyeSB0byBzdHJpcCB1c2VsZXNzIGZyYW1lc1xuICAgICAgdmFyIGZuX25hbWUgPSBnZXROYW1lKHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gICAgICB2YXIgaWR4ID0gb3V0LmluZGV4T2YoJ1xcbicgKyBmbl9uYW1lKTtcbiAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAvLyBvbmNlIHdlIGhhdmUgbG9jYXRlZCB0aGUgZnVuY3Rpb24gZnJhbWVcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzdHJpcCBvdXQgZXZlcnl0aGluZyBiZWZvcmUgaXQgKGFuZCBpdHMgbGluZSlcbiAgICAgICAgdmFyIG5leHRfbGluZSA9IG91dC5pbmRleE9mKCdcXG4nLCBpZHggKyAxKTtcbiAgICAgICAgb3V0ID0gb3V0LnN1YnN0cmluZyhuZXh0X2xpbmUgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFjayA9IG91dDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFzc2VydC5Bc3NlcnRpb25FcnJvciBpbnN0YW5jZW9mIEVycm9yXG51dGlsLmluaGVyaXRzKGFzc2VydC5Bc3NlcnRpb25FcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc3BlY3Qoc29tZXRoaW5nKSB7XG4gIGlmIChmdW5jdGlvbnNIYXZlTmFtZXMgfHwgIXV0aWwuaXNGdW5jdGlvbihzb21ldGhpbmcpKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5zcGVjdChzb21ldGhpbmcpO1xuICB9XG4gIHZhciByYXduYW1lID0gZ2V0TmFtZShzb21ldGhpbmcpO1xuICB2YXIgbmFtZSA9IHJhd25hbWUgPyAnOiAnICsgcmF3bmFtZSA6ICcnO1xuICByZXR1cm4gJ1tGdW5jdGlvbicgKyAgbmFtZSArICddJztcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmFjdHVhbCksIDEyOCkgKyAnICcgK1xuICAgICAgICAgc2VsZi5vcGVyYXRvciArICcgJyArXG4gICAgICAgICB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuZXhwZWN0ZWQpLCAxMjgpO1xufVxuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgISFndWFyZCxcbi8vIG1lc3NhZ2Vfb3B0KTsuIFRvIHRlc3Qgc3RyaWN0bHkgZm9yIHRoZSB2YWx1ZSB0cnVlLCB1c2Vcbi8vIGFzc2VydC5zdHJpY3RFcXVhbCh0cnVlLCBndWFyZCwgbWVzc2FnZV9vcHQpOy5cblxuZnVuY3Rpb24gb2sodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBTdHJpY3RFcXVhbCcsIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAmJiBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gY29tcGFyZShhY3R1YWwsIGV4cGVjdGVkKSA9PT0gMDtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoKGFjdHVhbCA9PT0gbnVsbCB8fCB0eXBlb2YgYWN0dWFsICE9PSAnb2JqZWN0JykgJiZcbiAgICAgICAgICAgICAoZXhwZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIGV4cGVjdGVkICE9PSAnb2JqZWN0JykpIHtcbiAgICByZXR1cm4gc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyBJZiBib3RoIHZhbHVlcyBhcmUgaW5zdGFuY2VzIG9mIHR5cGVkIGFycmF5cywgd3JhcCB0aGVpciB1bmRlcmx5aW5nXG4gIC8vIEFycmF5QnVmZmVycyBpbiBhIEJ1ZmZlciBlYWNoIHRvIGluY3JlYXNlIHBlcmZvcm1hbmNlXG4gIC8vIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoZSBhcnJheXMgdG8gaGF2ZSB0aGUgc2FtZSB0eXBlIGFzIGNoZWNrZWQgYnlcbiAgLy8gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAoYWthIHBUb1N0cmluZykuIE5ldmVyIHBlcmZvcm0gYmluYXJ5XG4gIC8vIGNvbXBhcmlzb25zIGZvciBGbG9hdCpBcnJheXMsIHRob3VnaCwgc2luY2UgZS5nLiArMCA9PT0gLTAgYnV0IHRoZWlyXG4gIC8vIGJpdCBwYXR0ZXJucyBhcmUgbm90IGlkZW50aWNhbC5cbiAgfSBlbHNlIGlmIChpc1ZpZXcoYWN0dWFsKSAmJiBpc1ZpZXcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgcFRvU3RyaW5nKGFjdHVhbCkgPT09IHBUb1N0cmluZyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICAhKGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuICAgICAgICAgICAgICAgYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkge1xuICAgIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGFjdHVhbC5idWZmZXIpLFxuICAgICAgICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGV4cGVjdGVkLmJ1ZmZlcikpID09PSAwO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSBpZiAoaXNCdWZmZXIoYWN0dWFsKSAhPT0gaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIG1lbW9zID0gbWVtb3MgfHwge2FjdHVhbDogW10sIGV4cGVjdGVkOiBbXX07XG5cbiAgICB2YXIgYWN0dWFsSW5kZXggPSBtZW1vcy5hY3R1YWwuaW5kZXhPZihhY3R1YWwpO1xuICAgIGlmIChhY3R1YWxJbmRleCAhPT0gLTEpIHtcbiAgICAgIGlmIChhY3R1YWxJbmRleCA9PT0gbWVtb3MuZXhwZWN0ZWQuaW5kZXhPZihleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MuYWN0dWFsLnB1c2goYWN0dWFsKTtcbiAgICBtZW1vcy5leHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcblxuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGlmIG9uZSBpcyBhIHByaW1pdGl2ZSwgdGhlIG90aGVyIG11c3QgYmUgc2FtZVxuICBpZiAodXRpbC5pc1ByaW1pdGl2ZShhKSB8fCB1dGlsLmlzUHJpbWl0aXZlKGIpKVxuICAgIHJldHVybiBhID09PSBiO1xuICBpZiAoc3RyaWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihhKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGIpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdmFyIGFJc0FyZ3MgPSBpc0FyZ3VtZW50cyhhKTtcbiAgdmFyIGJJc0FyZ3MgPSBpc0FyZ3VtZW50cyhiKTtcbiAgaWYgKChhSXNBcmdzICYmICFiSXNBcmdzKSB8fCAoIWFJc0FyZ3MgJiYgYklzQXJncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoYUlzQXJncykge1xuICAgIGEgPSBwU2xpY2UuY2FsbChhKTtcbiAgICBiID0gcFNsaWNlLmNhbGwoYik7XG4gICAgcmV0dXJuIF9kZWVwRXF1YWwoYSwgYiwgc3RyaWN0KTtcbiAgfVxuICB2YXIga2EgPSBvYmplY3RLZXlzKGEpO1xuICB2YXIga2IgPSBvYmplY3RLZXlzKGIpO1xuICB2YXIga2V5LCBpO1xuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyA4LiBUaGUgbm9uLWVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBmb3IgYW55IGRlZXAgaW5lcXVhbGl0eS5cbi8vIGFzc2VydC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RGVlcEVxdWFsID0gZnVuY3Rpb24gbm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcEVxdWFsJywgYXNzZXJ0Lm5vdERlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5mdW5jdGlvbiBub3REZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCB0cnVlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBTdHJpY3RFcXVhbCcsIG5vdERlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn1cblxuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSWdub3JlLiAgVGhlIGluc3RhbmNlb2YgY2hlY2sgZG9lc24ndCB3b3JrIGZvciBhcnJvdyBmdW5jdGlvbnMuXG4gIH1cblxuICBpZiAoRXJyb3IuaXNQcm90b3R5cGVPZihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX3RyeUJsb2NrKGJsb2NrKSB7XG4gIHZhciBlcnJvcjtcbiAgdHJ5IHtcbiAgICBibG9jaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3IgPSBlO1xuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cblxuZnVuY3Rpb24gX3Rocm93cyhzaG91bGRUaHJvdywgYmxvY2ssIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIHZhciBhY3R1YWw7XG5cbiAgaWYgKHR5cGVvZiBibG9jayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYmxvY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgbWVzc2FnZSA9IGV4cGVjdGVkO1xuICAgIGV4cGVjdGVkID0gbnVsbDtcbiAgfVxuXG4gIGFjdHVhbCA9IF90cnlCbG9jayhibG9jayk7XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICB2YXIgdXNlclByb3ZpZGVkTWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJztcbiAgdmFyIGlzVW53YW50ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgdXRpbC5pc0Vycm9yKGFjdHVhbCk7XG4gIHZhciBpc1VuZXhwZWN0ZWRFeGNlcHRpb24gPSAhc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmICFleHBlY3RlZDtcblxuICBpZiAoKGlzVW53YW50ZWRFeGNlcHRpb24gJiZcbiAgICAgIHVzZXJQcm92aWRlZE1lc3NhZ2UgJiZcbiAgICAgIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fFxuICAgICAgaXNVbmV4cGVjdGVkRXhjZXB0aW9uKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKHRydWUsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG4vLyBFWFRFTlNJT04hIFRoaXMgaXMgYW5ub3lpbmcgdG8gd3JpdGUgb3V0c2lkZSB0aGlzIG1vZHVsZS5cbmFzc2VydC5kb2VzTm90VGhyb3cgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyhmYWxzZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbmFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24oZXJyKSB7IGlmIChlcnIpIHRocm93IGVycjsgfTtcblxuLy8gRXhwb3NlIGEgc3RyaWN0IG9ubHkgdmFyaWFudCBvZiBhc3NlcnRcbmZ1bmN0aW9uIHN0cmljdCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBzdHJpY3QpO1xufVxuYXNzZXJ0LnN0cmljdCA9IG9iamVjdEFzc2lnbihzdHJpY3QsIGFzc2VydCwge1xuICBlcXVhbDogYXNzZXJ0LnN0cmljdEVxdWFsLFxuICBkZWVwRXF1YWw6IGFzc2VydC5kZWVwU3RyaWN0RXF1YWwsXG4gIG5vdEVxdWFsOiBhc3NlcnQubm90U3RyaWN0RXF1YWwsXG4gIG5vdERlZXBFcXVhbDogYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbFxufSk7XG5hc3NlcnQuc3RyaWN0LnN0cmljdCA9IGFzc2VydC5zdHJpY3Q7XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcbiAgICByZXR1cm4gcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcGF0aE1vZHVsZSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xudmFyIG5vZGVfMSA9IHJlcXVpcmUoXCIuL25vZGVcIik7XG52YXIgU3RhdHNfMSA9IHJlcXVpcmUoXCIuL1N0YXRzXCIpO1xudmFyIERpcmVudF8xID0gcmVxdWlyZShcIi4vRGlyZW50XCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnVmZmVyXCIpO1xudmFyIHNldEltbWVkaWF0ZV8xID0gcmVxdWlyZShcIi4vc2V0SW1tZWRpYXRlXCIpO1xudmFyIHByb2Nlc3NfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3NcIik7XG52YXIgc2V0VGltZW91dFVucmVmXzEgPSByZXF1aXJlKFwiLi9zZXRUaW1lb3V0VW5yZWZcIik7XG52YXIgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBlbmNvZGluZ18xID0gcmVxdWlyZShcIi4vZW5jb2RpbmdcIik7XG52YXIgZXJyb3JzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvZXJyb3JzXCIpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoXCJmYXN0LWV4dGVuZFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG52YXIgcHJvbWlzZXNfMSA9IHJlcXVpcmUoXCIuL3Byb21pc2VzXCIpO1xudmFyIHJlc29sdmVDcm9zc1BsYXRmb3JtID0gcGF0aE1vZHVsZS5yZXNvbHZlO1xudmFyIE9fUkRPTkxZID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fUkRPTkxZLCBPX1dST05MWSA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5PX1dST05MWSwgT19SRFdSID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fUkRXUiwgT19DUkVBVCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5PX0NSRUFULCBPX0VYQ0wgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19FWENMLCBPX1RSVU5DID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fVFJVTkMsIE9fQVBQRU5EID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fQVBQRU5ELCBPX1NZTkMgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19TWU5DLCBGX09LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLkZfT0ssIENPUFlGSUxFX0VYQ0wgPSBjb25zdGFudHNfMS5jb25zdGFudHMuQ09QWUZJTEVfRVhDTCwgQ09QWUZJTEVfRklDTE9ORV9GT1JDRSA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5DT1BZRklMRV9GSUNMT05FX0ZPUkNFO1xudmFyIHNlcDtcbnZhciByZWxhdGl2ZTtcbmlmIChwYXRoTW9kdWxlLnBvc2l4KSB7XG4gICAgdmFyIHBvc2l4ID0gcGF0aE1vZHVsZS5wb3NpeDtcbiAgICBzZXAgPSBwb3NpeC5zZXA7XG4gICAgcmVsYXRpdmUgPSBwb3NpeC5yZWxhdGl2ZTtcbn1cbmVsc2Uge1xuICAgIHNlcCA9IHBhdGhNb2R1bGUuc2VwO1xuICAgIHJlbGF0aXZlID0gcGF0aE1vZHVsZS5yZWxhdGl2ZTtcbn1cbnZhciBpc1dpbiA9IHByb2Nlc3NfMS5kZWZhdWx0LnBsYXRmb3JtID09PSAnd2luMzInO1xudmFyIGtNaW5Qb29sU3BhY2UgPSAxMjg7XG4vLyBjb25zdCBrTWF4TGVuZ3RoID0gcmVxdWlyZSgnYnVmZmVyJykua01heExlbmd0aDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRXJyb3IgbWVzc2FnZXNcbi8vIFRPRE86IFVzZSBgaW50ZXJuYWwvZXJyb3JzLmpzYCBpbiB0aGUgZnV0dXJlLlxudmFyIEVSUlNUUiA9IHtcbiAgICBQQVRIX1NUUjogJ3BhdGggbXVzdCBiZSBhIHN0cmluZyBvciBCdWZmZXInLFxuICAgIC8vIEZEOiAgICAgICAgICAgICAnZmlsZSBkZXNjcmlwdG9yIG11c3QgYmUgYSB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlcicsXG4gICAgRkQ6ICdmZCBtdXN0IGJlIGEgZmlsZSBkZXNjcmlwdG9yJyxcbiAgICBNT0RFX0lOVDogJ21vZGUgbXVzdCBiZSBhbiBpbnQnLFxuICAgIENCOiAnY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyxcbiAgICBVSUQ6ICd1aWQgbXVzdCBiZSBhbiB1bnNpZ25lZCBpbnQnLFxuICAgIEdJRDogJ2dpZCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludCcsXG4gICAgTEVOOiAnbGVuIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgQVRJTUU6ICdhdGltZSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgIE1USU1FOiAnbXRpbWUgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICBQUkVGSVg6ICdmaWxlbmFtZSBwcmVmaXggaXMgcmVxdWlyZWQnLFxuICAgIEJVRkZFUjogJ2J1ZmZlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEJ1ZmZlciBvciBTdGF0aWNCdWZmZXInLFxuICAgIE9GRlNFVDogJ29mZnNldCBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgIExFTkdUSDogJ2xlbmd0aCBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgIFBPU0lUSU9OOiAncG9zaXRpb24gbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbn07XG52YXIgRVJSU1RSX09QVFMgPSBmdW5jdGlvbiAodGlwZW9mKSB7IHJldHVybiBcIkV4cGVjdGVkIG9wdGlvbnMgdG8gYmUgZWl0aGVyIGFuIG9iamVjdCBvciBhIHN0cmluZywgYnV0IGdvdCBcIiArIHRpcGVvZiArIFwiIGluc3RlYWRcIjsgfTtcbi8vIGNvbnN0IEVSUlNUUl9GTEFHID0gZmxhZyA9PiBgVW5rbm93biBmaWxlIG9wZW4gZmxhZzogJHtmbGFnfWA7XG52YXIgRU5PRU5UID0gJ0VOT0VOVCc7XG52YXIgRUJBREYgPSAnRUJBREYnO1xudmFyIEVJTlZBTCA9ICdFSU5WQUwnO1xudmFyIEVQRVJNID0gJ0VQRVJNJztcbnZhciBFUFJPVE8gPSAnRVBST1RPJztcbnZhciBFRVhJU1QgPSAnRUVYSVNUJztcbnZhciBFTk9URElSID0gJ0VOT1RESVInO1xudmFyIEVNRklMRSA9ICdFTUZJTEUnO1xudmFyIEVBQ0NFUyA9ICdFQUNDRVMnO1xudmFyIEVJU0RJUiA9ICdFSVNESVInO1xudmFyIEVOT1RFTVBUWSA9ICdFTk9URU1QVFknO1xudmFyIEVOT1NZUyA9ICdFTk9TWVMnO1xuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3JDb2RlLCBmdW5jLCBwYXRoLCBwYXRoMikge1xuICAgIGlmIChmdW5jID09PSB2b2lkIDApIHsgZnVuYyA9ICcnOyB9XG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gJyc7IH1cbiAgICBpZiAocGF0aDIgPT09IHZvaWQgMCkgeyBwYXRoMiA9ICcnOyB9XG4gICAgdmFyIHBhdGhGb3JtYXR0ZWQgPSAnJztcbiAgICBpZiAocGF0aClcbiAgICAgICAgcGF0aEZvcm1hdHRlZCA9IFwiICdcIiArIHBhdGggKyBcIidcIjtcbiAgICBpZiAocGF0aDIpXG4gICAgICAgIHBhdGhGb3JtYXR0ZWQgKz0gXCIgLT4gJ1wiICsgcGF0aDIgKyBcIidcIjtcbiAgICBzd2l0Y2ggKGVycm9yQ29kZSkge1xuICAgICAgICBjYXNlIEVOT0VOVDpcbiAgICAgICAgICAgIHJldHVybiBcIkVOT0VOVDogbm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFQkFERjpcbiAgICAgICAgICAgIHJldHVybiBcIkVCQURGOiBiYWQgZmlsZSBkZXNjcmlwdG9yLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVJTlZBTDpcbiAgICAgICAgICAgIHJldHVybiBcIkVJTlZBTDogaW52YWxpZCBhcmd1bWVudCwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFUEVSTTpcbiAgICAgICAgICAgIHJldHVybiBcIkVQRVJNOiBvcGVyYXRpb24gbm90IHBlcm1pdHRlZCwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFUFJPVE86XG4gICAgICAgICAgICByZXR1cm4gXCJFUFJPVE86IHByb3RvY29sIGVycm9yLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVFWElTVDpcbiAgICAgICAgICAgIHJldHVybiBcIkVFWElTVDogZmlsZSBhbHJlYWR5IGV4aXN0cywgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFTk9URElSOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5PVERJUjogbm90IGEgZGlyZWN0b3J5LCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVJU0RJUjpcbiAgICAgICAgICAgIHJldHVybiBcIkVJU0RJUjogaWxsZWdhbCBvcGVyYXRpb24gb24gYSBkaXJlY3RvcnksIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRUFDQ0VTOlxuICAgICAgICAgICAgcmV0dXJuIFwiRUFDQ0VTOiBwZXJtaXNzaW9uIGRlbmllZCwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFTk9URU1QVFk6XG4gICAgICAgICAgICByZXR1cm4gXCJFTk9URU1QVFk6IGRpcmVjdG9yeSBub3QgZW1wdHksIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRU1GSUxFOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU1GSUxFOiB0b28gbWFueSBvcGVuIGZpbGVzLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVOT1NZUzpcbiAgICAgICAgICAgIHJldHVybiBcIkVOT1NZUzogZnVuY3Rpb24gbm90IGltcGxlbWVudGVkLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGVycm9yQ29kZSArIFwiOiBlcnJvciBvY2N1cnJlZCwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihlcnJvckNvZGUsIGZ1bmMsIHBhdGgsIHBhdGgyLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmIChmdW5jID09PSB2b2lkIDApIHsgZnVuYyA9ICcnOyB9XG4gICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gJyc7IH1cbiAgICBpZiAocGF0aDIgPT09IHZvaWQgMCkgeyBwYXRoMiA9ICcnOyB9XG4gICAgaWYgKENvbnN0cnVjdG9yID09PSB2b2lkIDApIHsgQ29uc3RydWN0b3IgPSBFcnJvcjsgfVxuICAgIHZhciBlcnJvciA9IG5ldyBDb25zdHJ1Y3Rvcihmb3JtYXRFcnJvcihlcnJvckNvZGUsIGZ1bmMsIHBhdGgsIHBhdGgyKSk7XG4gICAgZXJyb3IuY29kZSA9IGVycm9yQ29kZTtcbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiB0aHJvd0Vycm9yKGVycm9yQ29kZSwgZnVuYywgcGF0aCwgcGF0aDIsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGZ1bmMgPT09IHZvaWQgMCkgeyBmdW5jID0gJyc7IH1cbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSAnJzsgfVxuICAgIGlmIChwYXRoMiA9PT0gdm9pZCAwKSB7IHBhdGgyID0gJyc7IH1cbiAgICBpZiAoQ29uc3RydWN0b3IgPT09IHZvaWQgMCkgeyBDb25zdHJ1Y3RvciA9IEVycm9yOyB9XG4gICAgdGhyb3cgY3JlYXRlRXJyb3IoZXJyb3JDb2RlLCBmdW5jLCBwYXRoLCBwYXRoMiwgQ29uc3RydWN0b3IpO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBGbGFnc1xuLy8gTGlzdCBvZiBmaWxlIGBmbGFnc2AgYXMgZGVmaW5lZCBieSBOb2RlLlxudmFyIEZMQUdTO1xuKGZ1bmN0aW9uIChGTEFHUykge1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcInJcIl0gPSBPX1JET05MWV0gPSBcInJcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcuIEFuIGV4Y2VwdGlvbiBvY2N1cnMgaWYgdGhlIGZpbGUgZG9lcyBub3QgZXhpc3QuXG4gICAgRkxBR1NbRkxBR1NbXCJyK1wiXSA9IE9fUkRXUl0gPSBcInIrXCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGluIHN5bmNocm9ub3VzIG1vZGUuIEluc3RydWN0cyB0aGUgb3BlcmF0aW5nIHN5c3RlbSB0byBieXBhc3MgdGhlIGxvY2FsIGZpbGUgc3lzdGVtIGNhY2hlLlxuICAgIEZMQUdTW0ZMQUdTW1wicnNcIl0gPSBPX1JET05MWSB8IE9fU1lOQ10gPSBcInJzXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzclwiXSA9IEZMQUdTLnJzXSA9IFwic3JcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcsIHRlbGxpbmcgdGhlIE9TIHRvIG9wZW4gaXQgc3luY2hyb25vdXNseS4gU2VlIG5vdGVzIGZvciAncnMnIGFib3V0IHVzaW5nIHRoaXMgd2l0aCBjYXV0aW9uLlxuICAgIEZMQUdTW0ZMQUdTW1wicnMrXCJdID0gT19SRFdSIHwgT19TWU5DXSA9IFwicnMrXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJzcitcIl0gPSBGTEFHU1sncnMrJ11dID0gXCJzcitcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gICAgRkxBR1NbRkxBR1NbXCJ3XCJdID0gT19XUk9OTFkgfCBPX0NSRUFUIHwgT19UUlVOQ10gPSBcIndcIjtcbiAgICAvLyBMaWtlICd3JyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJ3eFwiXSA9IE9fV1JPTkxZIHwgT19DUkVBVCB8IE9fVFJVTkMgfCBPX0VYQ0xdID0gXCJ3eFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wieHdcIl0gPSBGTEFHUy53eF0gPSBcInh3XCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGFuZCB3cml0aW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIChpZiBpdCBkb2VzIG5vdCBleGlzdCkgb3IgdHJ1bmNhdGVkIChpZiBpdCBleGlzdHMpLlxuICAgIEZMQUdTW0ZMQUdTW1widytcIl0gPSBPX1JEV1IgfCBPX0NSRUFUIHwgT19UUlVOQ10gPSBcIncrXCI7XG4gICAgLy8gTGlrZSAndysnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcInd4K1wiXSA9IE9fUkRXUiB8IE9fQ1JFQVQgfCBPX1RSVU5DIHwgT19FWENMXSA9IFwid3grXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4dytcIl0gPSBGTEFHU1snd3grJ11dID0gXCJ4dytcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIGFwcGVuZGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcImFcIl0gPSBPX1dST05MWSB8IE9fQVBQRU5EIHwgT19DUkVBVF0gPSBcImFcIjtcbiAgICAvLyBMaWtlICdhJyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJheFwiXSA9IE9fV1JPTkxZIHwgT19BUFBFTkQgfCBPX0NSRUFUIHwgT19FWENMXSA9IFwiYXhcIjtcbiAgICBGTEFHU1tGTEFHU1tcInhhXCJdID0gRkxBR1MuYXhdID0gXCJ4YVwiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgYXBwZW5kaW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgIEZMQUdTW0ZMQUdTW1wiYStcIl0gPSBPX1JEV1IgfCBPX0FQUEVORCB8IE9fQ1JFQVRdID0gXCJhK1wiO1xuICAgIC8vIExpa2UgJ2ErJyBidXQgZmFpbHMgaWYgcGF0aCBleGlzdHMuXG4gICAgRkxBR1NbRkxBR1NbXCJheCtcIl0gPSBPX1JEV1IgfCBPX0FQUEVORCB8IE9fQ1JFQVQgfCBPX0VYQ0xdID0gXCJheCtcIjtcbiAgICBGTEFHU1tGTEFHU1tcInhhK1wiXSA9IEZMQUdTWydheCsnXV0gPSBcInhhK1wiO1xufSkoRkxBR1MgPSBleHBvcnRzLkZMQUdTIHx8IChleHBvcnRzLkZMQUdTID0ge30pKTtcbmZ1bmN0aW9uIGZsYWdzVG9OdW1iZXIoZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGZsYWdzID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBmbGFnc051bSA9IEZMQUdTW2ZsYWdzXTtcbiAgICAgICAgaWYgKHR5cGVvZiBmbGFnc051bSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gZmxhZ3NOdW07XG4gICAgfVxuICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoZm9ybWF0RXJyb3IoRVJSU1RSX0ZMQUcoZmxhZ3MpKSk7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsICdmbGFncycsIGZsYWdzKTtcbn1cbmV4cG9ydHMuZmxhZ3NUb051bWJlciA9IGZsYWdzVG9OdW1iZXI7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE9wdGlvbnNcbmZ1bmN0aW9uIGdldE9wdGlvbnMoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cztcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRpcGVvZiA9IHR5cGVvZiBvcHRpb25zO1xuICAgICAgICBzd2l0Y2ggKHRpcGVvZikge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBvcHRzID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgeyBlbmNvZGluZzogb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgb3B0cyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSX09QVFModGlwZW9mKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuZW5jb2RpbmcgIT09ICdidWZmZXInKVxuICAgICAgICBlbmNvZGluZ18xLmFzc2VydEVuY29kaW5nKG9wdHMuZW5jb2RpbmcpO1xuICAgIHJldHVybiBvcHRzO1xufVxuZnVuY3Rpb24gb3B0c0dlbmVyYXRvcihkZWZhdWx0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykgeyByZXR1cm4gZ2V0T3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucyk7IH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKEVSUlNUUi5DQik7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xufVxuZnVuY3Rpb24gb3B0c0FuZENiR2VuZXJhdG9yKGdldE9wdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IFtnZXRPcHRzKCksIG9wdGlvbnNdIDogW2dldE9wdHMob3B0aW9ucyksIHZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2spXTtcbiAgICB9O1xufVxudmFyIG9wdHNEZWZhdWx0cyA9IHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxufTtcbnZhciBnZXREZWZhdWx0T3B0cyA9IG9wdHNHZW5lcmF0b3Iob3B0c0RlZmF1bHRzKTtcbnZhciBnZXREZWZhdWx0T3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldERlZmF1bHRPcHRzKTtcbnZhciByZWFkRmlsZU9wdHNEZWZhdWx0cyA9IHtcbiAgICBmbGFnOiAncicsXG59O1xudmFyIGdldFJlYWRGaWxlT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3IocmVhZEZpbGVPcHRzRGVmYXVsdHMpO1xudmFyIHdyaXRlRmlsZURlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogNDM4IC8qIERFRkFVTFQgKi8sXG4gICAgZmxhZzogRkxBR1NbRkxBR1Mud10sXG59O1xudmFyIGdldFdyaXRlRmlsZU9wdGlvbnMgPSBvcHRzR2VuZXJhdG9yKHdyaXRlRmlsZURlZmF1bHRzKTtcbnZhciBhcHBlbmRGaWxlRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiA0MzggLyogREVGQVVMVCAqLyxcbiAgICBmbGFnOiBGTEFHU1tGTEFHUy5hXSxcbn07XG52YXIgZ2V0QXBwZW5kRmlsZU9wdHMgPSBvcHRzR2VuZXJhdG9yKGFwcGVuZEZpbGVEZWZhdWx0cyk7XG52YXIgZ2V0QXBwZW5kRmlsZU9wdHNBbmRDYiA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXRBcHBlbmRGaWxlT3B0cyk7XG52YXIgcmVhbHBhdGhEZWZhdWx0cyA9IG9wdHNEZWZhdWx0cztcbnZhciBnZXRSZWFscGF0aE9wdGlvbnMgPSBvcHRzR2VuZXJhdG9yKHJlYWxwYXRoRGVmYXVsdHMpO1xudmFyIGdldFJlYWxwYXRoT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldFJlYWxwYXRoT3B0aW9ucyk7XG52YXIgbWtkaXJEZWZhdWx0cyA9IHtcbiAgICBtb2RlOiA1MTEgLyogRElSICovLFxuICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG59O1xudmFyIGdldE1rZGlyT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgbWtkaXJEZWZhdWx0cywgeyBtb2RlOiBvcHRpb25zIH0pO1xuICAgIHJldHVybiBleHRlbmQoe30sIG1rZGlyRGVmYXVsdHMsIG9wdGlvbnMpO1xufTtcbnZhciByZWFkZGlyRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbn07XG52YXIgZ2V0UmVhZGRpck9wdGlvbnMgPSBvcHRzR2VuZXJhdG9yKHJlYWRkaXJEZWZhdWx0cyk7XG52YXIgZ2V0UmVhZGRpck9wdHNBbmRDYiA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXRSZWFkZGlyT3B0aW9ucyk7XG52YXIgc3RhdERlZmF1bHRzID0ge1xuICAgIGJpZ2ludDogZmFsc2UsXG59O1xudmFyIGdldFN0YXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBleHRlbmQoe30sIHN0YXREZWZhdWx0cywgb3B0aW9ucyk7XG59O1xudmFyIGdldFN0YXRPcHRzQW5kQ2IgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBbZ2V0U3RhdE9wdGlvbnMoKSwgb3B0aW9uc10gOiBbZ2V0U3RhdE9wdGlvbnMob3B0aW9ucyksIHZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2spXTtcbn07XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFV0aWxpdHkgZnVuY3Rpb25zXG5mdW5jdGlvbiBnZXRQYXRoRnJvbVVSTFBvc2l4KHVybCkge1xuICAgIGlmICh1cmwuaG9zdG5hbWUgIT09ICcnKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnMuVHlwZUVycm9yKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9IT1NUJywgcHJvY2Vzc18xLmRlZmF1bHQucGxhdGZvcm0pO1xuICAgIH1cbiAgICB2YXIgcGF0aG5hbWUgPSB1cmwucGF0aG5hbWU7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBwYXRobmFtZS5sZW5ndGg7IG4rKykge1xuICAgICAgICBpZiAocGF0aG5hbWVbbl0gPT09ICclJykge1xuICAgICAgICAgICAgdmFyIHRoaXJkID0gcGF0aG5hbWUuY29kZVBvaW50QXQobiArIDIpIHwgMHgyMDtcbiAgICAgICAgICAgIGlmIChwYXRobmFtZVtuICsgMV0gPT09ICcyJyAmJiB0aGlyZCA9PT0gMTAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX0ZJTEVfVVJMX1BBVEgnLCAnbXVzdCBub3QgaW5jbHVkZSBlbmNvZGVkIC8gY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gcGF0aFRvRmlsZW5hbWUocGF0aCkge1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycgJiYgIWJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihwYXRoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIHJlcXVpcmUoJ3VybCcpLlVSTCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJTVFIuUEFUSF9TVFIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSU1RSLlBBVEhfU1RSKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gZ2V0UGF0aEZyb21VUkxQb3NpeChwYXRoKTtcbiAgICB9XG4gICAgdmFyIHBhdGhTdHJpbmcgPSBTdHJpbmcocGF0aCk7XG4gICAgbnVsbENoZWNrKHBhdGhTdHJpbmcpO1xuICAgIC8vIHJldHVybiBzbGFzaChwYXRoU3RyaW5nKTtcbiAgICByZXR1cm4gcGF0aFN0cmluZztcbn1cbmV4cG9ydHMucGF0aFRvRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZTtcbnZhciByZXNvbHZlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBiYXNlKSB7XG4gICAgaWYgKGJhc2UgPT09IHZvaWQgMCkgeyBiYXNlID0gcHJvY2Vzc18xLmRlZmF1bHQuY3dkKCk7IH1cbiAgICByZXR1cm4gcmVzb2x2ZUNyb3NzUGxhdGZvcm0oYmFzZSwgZmlsZW5hbWUpO1xufTtcbmlmIChpc1dpbikge1xuICAgIHZhciBfcmVzb2x2ZV8xID0gcmVzb2x2ZTtcbiAgICB2YXIgdW5peGlmeV8xID0gcmVxdWlyZSgnZnMtbW9ua2V5L2xpYi9jb3JyZWN0UGF0aCcpLnVuaXhpZnk7XG4gICAgcmVzb2x2ZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgYmFzZSkgeyByZXR1cm4gdW5peGlmeV8xKF9yZXNvbHZlXzEoZmlsZW5hbWUsIGJhc2UpKTsgfTtcbn1cbmZ1bmN0aW9uIGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSwgYmFzZSkge1xuICAgIHZhciBmdWxsUGF0aCA9IHJlc29sdmUoZmlsZW5hbWUsIGJhc2UpO1xuICAgIHZhciBmdWxsUGF0aFNhbnNTbGFzaCA9IGZ1bGxQYXRoLnN1YnN0cigxKTtcbiAgICBpZiAoIWZ1bGxQYXRoU2Fuc1NsYXNoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIGZ1bGxQYXRoU2Fuc1NsYXNoLnNwbGl0KHNlcCk7XG59XG5leHBvcnRzLmZpbGVuYW1lVG9TdGVwcyA9IGZpbGVuYW1lVG9TdGVwcztcbmZ1bmN0aW9uIHBhdGhUb1N0ZXBzKHBhdGgpIHtcbiAgICByZXR1cm4gZmlsZW5hbWVUb1N0ZXBzKHBhdGhUb0ZpbGVuYW1lKHBhdGgpKTtcbn1cbmV4cG9ydHMucGF0aFRvU3RlcHMgPSBwYXRoVG9TdGVwcztcbmZ1bmN0aW9uIGRhdGFUb1N0cihkYXRhLCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4OyB9XG4gICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuYnVmZmVyRnJvbShkYXRhKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gU3RyaW5nKGRhdGEpO1xufVxuZXhwb3J0cy5kYXRhVG9TdHIgPSBkYXRhVG9TdHI7XG5mdW5jdGlvbiBkYXRhVG9CdWZmZXIoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGODsgfVxuICAgIGlmIChidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoZGF0YSkpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gYnVmZmVyXzEuYnVmZmVyRnJvbShkYXRhKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBidWZmZXJfMS5idWZmZXJGcm9tKFN0cmluZyhkYXRhKSwgZW5jb2RpbmcpO1xufVxuZXhwb3J0cy5kYXRhVG9CdWZmZXIgPSBkYXRhVG9CdWZmZXI7XG5mdW5jdGlvbiBidWZmZXJUb0VuY29kaW5nKGJ1ZmZlciwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIWVuY29kaW5nIHx8IGVuY29kaW5nID09PSAnYnVmZmVyJylcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoZW5jb2RpbmcpO1xufVxuZXhwb3J0cy5idWZmZXJUb0VuY29kaW5nID0gYnVmZmVyVG9FbmNvZGluZztcbmZ1bmN0aW9uIG51bGxDaGVjayhwYXRoLCBjYWxsYmFjaykge1xuICAgIGlmICgoJycgKyBwYXRoKS5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgIHZhciBlciA9IG5ldyBFcnJvcignUGF0aCBtdXN0IGJlIGEgc3RyaW5nIHdpdGhvdXQgbnVsbCBieXRlcycpO1xuICAgICAgICBlci5jb2RlID0gRU5PRU5UO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKGNhbGxiYWNrLCBlcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBfbW9kZVRvTnVtYmVyKG1vZGUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBtb2RlO1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBwYXJzZUludChtb2RlLCA4KTtcbiAgICBpZiAoZGVmKVxuICAgICAgICByZXR1cm4gbW9kZVRvTnVtYmVyKGRlZik7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIG1vZGVUb051bWJlcihtb2RlLCBkZWYpIHtcbiAgICB2YXIgcmVzdWx0ID0gX21vZGVUb051bWJlcihtb2RlLCBkZWYpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnbnVtYmVyJyB8fCBpc05hTihyZXN1bHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUlNUUi5NT0RFX0lOVCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzRmQocGF0aCkge1xuICAgIHJldHVybiBwYXRoID4+PiAwID09PSBwYXRoO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVGZChmZCkge1xuICAgIGlmICghaXNGZChmZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuRkQpO1xufVxuLy8gY29udmVydHMgRGF0ZSBvciBudW1iZXIgdG8gYSBmcmFjdGlvbmFsIFVOSVggdGltZXN0YW1wXG5mdW5jdGlvbiB0b1VuaXhUaW1lc3RhbXAodGltZSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSB0cmlwbGUtZXF1YWxzXG4gICAgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJyAmJiArdGltZSA9PSB0aW1lKSB7XG4gICAgICAgIHJldHVybiArdGltZTtcbiAgICB9XG4gICAgaWYgKHRpbWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB0aW1lLmdldFRpbWUoKSAvIDEwMDA7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZSh0aW1lKSkge1xuICAgICAgICBpZiAodGltZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGFyc2UgdGltZTogJyArIHRpbWUpO1xufVxuZXhwb3J0cy50b1VuaXhUaW1lc3RhbXAgPSB0b1VuaXhUaW1lc3RhbXA7XG4vKipcbiAqIFJldHVybnMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIGNhbGxiYWNrXG4gKiBAcGFyYW0gYXJnIEFyZ3VtZW50IG9yIGNhbGxiYWNrIHZhbHVlXG4gKiBAcGFyYW0gY2FsbGJhY2sgQ2FsbGJhY2sgb3IgdW5kZWZpbmVkXG4gKiBAcGFyYW0gZGVmIERlZmF1bHQgYXJndW1lbnQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0QXJnQW5kQ2IoYXJnLCBjYWxsYmFjaywgZGVmKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBbZGVmLCBhcmddIDogW2FyZywgY2FsbGJhY2tdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVVaWQodWlkKSB7XG4gICAgaWYgKHR5cGVvZiB1aWQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSLlVJRCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUdpZChnaWQpIHtcbiAgICBpZiAodHlwZW9mIGdpZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuR0lEKTtcbn1cbi8qKlxuICogYFZvbHVtZWAgcmVwcmVzZW50cyBhIGZpbGUgc3lzdGVtLlxuICovXG52YXIgVm9sdW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZvbHVtZShwcm9wcykge1xuICAgICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgeyBwcm9wcyA9IHt9OyB9XG4gICAgICAgIC8vIEktbm9kZSBudW1iZXIgY291bnRlci5cbiAgICAgICAgdGhpcy5pbm8gPSAwO1xuICAgICAgICAvLyBBIG1hcHBpbmcgZm9yIGktbm9kZSBudW1iZXJzIHRvIGktbm9kZXMgKGBOb2RlYCk7XG4gICAgICAgIHRoaXMuaW5vZGVzID0ge307XG4gICAgICAgIC8vIExpc3Qgb2YgcmVsZWFzZWQgaS1ub2RlIG51bWJlcnMsIGZvciByZXVzZS5cbiAgICAgICAgdGhpcy5yZWxlYXNlZElub3MgPSBbXTtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGZvciBmaWxlIGRlc2NyaXB0b3JzIHRvIGBGaWxlYHMuXG4gICAgICAgIHRoaXMuZmRzID0ge307XG4gICAgICAgIC8vIEEgbGlzdCBvZiByZXVzYWJsZSAob3BlbmVkIGFuZCBjbG9zZWQpIGZpbGUgZGVzY3JpcHRvcnMsIHRoYXQgc2hvdWxkIGJlXG4gICAgICAgIC8vIHVzZWQgZmlyc3QgYmVmb3JlIGNyZWF0aW5nIGEgbmV3IGZpbGUgZGVzY3JpcHRvci5cbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcyA9IFtdO1xuICAgICAgICAvLyBNYXggbnVtYmVyIG9mIG9wZW4gZmlsZXMuXG4gICAgICAgIHRoaXMubWF4RmlsZXMgPSAxMDAwMDtcbiAgICAgICAgLy8gQ3VycmVudCBudW1iZXIgb2Ygb3BlbiBmaWxlcy5cbiAgICAgICAgdGhpcy5vcGVuRmlsZXMgPSAwO1xuICAgICAgICB0aGlzLnByb21pc2VzQXBpID0gcHJvbWlzZXNfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRXYXRjaGVycyA9IHt9O1xuICAgICAgICB0aGlzLnByb3BzID0gZXh0ZW5kKHsgTm9kZTogbm9kZV8xLk5vZGUsIExpbms6IG5vZGVfMS5MaW5rLCBGaWxlOiBub2RlXzEuRmlsZSB9LCBwcm9wcyk7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5jcmVhdGVMaW5rKCk7XG4gICAgICAgIHJvb3Quc2V0Tm9kZSh0aGlzLmNyZWF0ZU5vZGUodHJ1ZSkpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgICAgIHRoaXMuU3RhdFdhdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoU3RhdFdhdGNoZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBTdGF0V2F0Y2hlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2VsZikgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdGF0V2F0Y2hlcjtcbiAgICAgICAgfShTdGF0V2F0Y2hlcikpO1xuICAgICAgICB2YXIgX1JlYWRTdHJlYW0gPSBGc1JlYWRTdHJlYW07XG4gICAgICAgIHRoaXMuUmVhZFN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5cyhbc2VsZl0sIGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgIH0oX1JlYWRTdHJlYW0pKTtcbiAgICAgICAgdmFyIF9Xcml0ZVN0cmVhbSA9IEZzV3JpdGVTdHJlYW07XG4gICAgICAgIHRoaXMuV3JpdGVTdHJlYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoY2xhc3NfMiwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYXNzXzIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheXMoW3NlbGZdLCBhcmdzKSkgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc18yO1xuICAgICAgICB9KF9Xcml0ZVN0cmVhbSkpO1xuICAgICAgICB0aGlzLkZTV2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhGU1dhdGNoZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBGU1dhdGNoZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNlbGYpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRlNXYXRjaGVyO1xuICAgICAgICB9KEZTV2F0Y2hlcikpO1xuICAgICAgICAvLyByb290LnNldENoaWxkKCcuJywgcm9vdCk7XG4gICAgICAgIC8vIHJvb3QuZ2V0Tm9kZSgpLm5saW5rKys7XG4gICAgICAgIC8vIHJvb3Quc2V0Q2hpbGQoJy4uJywgcm9vdCk7XG4gICAgICAgIC8vIHJvb3QuZ2V0Tm9kZSgpLm5saW5rKys7XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XG4gICAgfVxuICAgIFZvbHVtZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBjd2QpIHtcbiAgICAgICAgdmFyIHZvbCA9IG5ldyBWb2x1bWUoKTtcbiAgICAgICAgdm9sLmZyb21KU09OKGpzb24sIGN3ZCk7XG4gICAgICAgIHJldHVybiB2b2w7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVm9sdW1lLnByb3RvdHlwZSwgXCJwcm9taXNlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvbWlzZXNBcGkgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9taXNlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VzQXBpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNyZWF0ZUxpbmsgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBpc0RpcmVjdG9yeSwgcGVybSkge1xuICAgICAgICBpZiAoaXNEaXJlY3RvcnkgPT09IHZvaWQgMCkgeyBpc0RpcmVjdG9yeSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiBwYXJlbnQgPyBwYXJlbnQuY3JlYXRlQ2hpbGQobmFtZSwgdGhpcy5jcmVhdGVOb2RlKGlzRGlyZWN0b3J5LCBwZXJtKSkgOiBuZXcgdGhpcy5wcm9wcy5MaW5rKHRoaXMsIG51bGwsICcnKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZGVsZXRlTGluayA9IGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgICAgICAgICAgbGluay52b2wgPSBudWxsO1xuICAgICAgICAgICAgbGluay5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5uZXdJbm9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VkSW5vcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxlYXNlZElub3MucG9wKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbm8gPSAodGhpcy5pbm8gKyAxKSAlIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbm87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubmV3RmROdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VkRmRzLmxlbmd0aCA/IHRoaXMucmVsZWFzZWRGZHMucG9wKCkgOiBWb2x1bWUuZmQtLTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIChpc0RpcmVjdG9yeSwgcGVybSkge1xuICAgICAgICBpZiAoaXNEaXJlY3RvcnkgPT09IHZvaWQgMCkgeyBpc0RpcmVjdG9yeSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBub2RlID0gbmV3IHRoaXMucHJvcHMuTm9kZSh0aGlzLm5ld0lub051bWJlcigpLCBwZXJtKTtcbiAgICAgICAgaWYgKGlzRGlyZWN0b3J5KVxuICAgICAgICAgICAgbm9kZS5zZXRJc0RpcmVjdG9yeSgpO1xuICAgICAgICB0aGlzLmlub2Rlc1tub2RlLmlub10gPSBub2RlO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uIChpbm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5vZGVzW2lub107XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmRlbGV0ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLmRlbCgpO1xuICAgICAgICBkZWxldGUgdGhpcy5pbm9kZXNbbm9kZS5pbm9dO1xuICAgICAgICB0aGlzLnJlbGVhc2VkSW5vcy5wdXNoKG5vZGUuaW5vKTtcbiAgICB9O1xuICAgIC8vIEdlbmVyYXRlcyA2IGNoYXJhY3RlciBsb25nIHJhbmRvbSBzdHJpbmcsIHVzZWQgYnkgYG1rZHRlbXBgLlxuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2VuUm5kU3RyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RyID0gKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDYpO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNilcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlblJuZFN0cigpO1xuICAgIH07XG4gICAgLy8gUmV0dXJucyBhIGBMaW5rYCAoaGFyZCBsaW5rKSByZWZlcmVuY2VkIGJ5IHBhdGggXCJzcGxpdFwiIGludG8gc3RlcHMuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRMaW5rID0gZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Qud2FsayhzdGVwcyk7XG4gICAgfTtcbiAgICAvLyBKdXN0IGxpbmsgYGdldExpbmtgLCBidXQgdGhyb3dzIGEgY29ycmVjdCB1c2VyIGVycm9yLCBpZiBsaW5rIHRvIGZvdW5kLlxuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0TGlua09yVGhyb3cgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGZ1bmNOYW1lKSB7XG4gICAgICAgIHZhciBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsIGZ1bmNOYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgLy8gSnVzdCBsaWtlIGBnZXRMaW5rYCwgYnV0IGFsc28gZGVyZWZlcmVuY2UvcmVzb2x2ZXMgc3ltYm9saWMgbGlua3MuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRSZXNvbHZlZExpbmsgPSBmdW5jdGlvbiAoZmlsZW5hbWVPclN0ZXBzKSB7XG4gICAgICAgIHZhciBzdGVwcyA9IHR5cGVvZiBmaWxlbmFtZU9yU3RlcHMgPT09ICdzdHJpbmcnID8gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lT3JTdGVwcykgOiBmaWxlbmFtZU9yU3RlcHM7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5yb290O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICAgICAgbGluayA9IGxpbmsuZ2V0Q2hpbGQoc3RlcCk7XG4gICAgICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNTeW1saW5rKCkpIHtcbiAgICAgICAgICAgICAgICBzdGVwcyA9IG5vZGUuc3ltbGluay5jb25jYXQoc3RlcHMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBsaW5rID0gdGhpcy5yb290O1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgLy8gSnVzdCBsaWtlIGBnZXRMaW5rT3JUaHJvd2AsIGJ1dCBhbHNvIGRlcmVmZXJlbmNlL3Jlc29sdmVzIHN5bWJvbGljIGxpbmtzLlxuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZnVuY05hbWUpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhmaWxlbmFtZSk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVzb2x2ZVN5bWxpbmtzID0gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgLy8gbGV0IG5vZGU6IE5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgLy8gd2hpbGUobGluayAmJiBub2RlLmlzU3ltbGluaygpKSB7XG4gICAgICAgIC8vICAgICBsaW5rID0gdGhpcy5nZXRMaW5rKG5vZGUuc3ltbGluayk7XG4gICAgICAgIC8vICAgICBpZighbGluaykgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vICAgICBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcmV0dXJuIGxpbms7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlc29sdmVkTGluayhsaW5rLnN0ZXBzLnNsaWNlKDEpKTtcbiAgICB9O1xuICAgIC8vIEp1c3QgbGlrZSBgZ2V0TGlua09yVGhyb3dgLCBidXQgYWxzbyB2ZXJpZmllcyB0aGF0IHRoZSBsaW5rIGlzIGEgZGlyZWN0b3J5LlxuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0TGlua0FzRGlyT3JUaHJvdyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZnVuY05hbWUpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCBmdW5jTmFtZSk7XG4gICAgICAgIGlmICghbGluay5nZXROb2RlKCkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PVERJUiwgZnVuY05hbWUsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfTtcbiAgICAvLyBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgZGlyZWN0b3J5IG9mIHRoZSBsaW5rLlxuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0TGlua1BhcmVudCA9IGZ1bmN0aW9uIChzdGVwcykge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LndhbGsoc3RlcHMsIHN0ZXBzLmxlbmd0aCAtIDEpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRMaW5rUGFyZW50QXNEaXJPclRocm93ID0gZnVuY3Rpb24gKGZpbGVuYW1lT3JTdGVwcywgZnVuY05hbWUpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVPclN0ZXBzIGluc3RhbmNlb2YgQXJyYXkgPyBmaWxlbmFtZU9yU3RlcHMgOiBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWVPclN0ZXBzKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldExpbmtQYXJlbnQoc3RlcHMpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgZnVuY05hbWUsIHNlcCArIHN0ZXBzLmpvaW4oc2VwKSk7XG4gICAgICAgIGlmICghbGluay5nZXROb2RlKCkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PVERJUiwgZnVuY05hbWUsIHNlcCArIHN0ZXBzLmpvaW4oc2VwKSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRGaWxlQnlGZCA9IGZ1bmN0aW9uIChmZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZHNbU3RyaW5nKGZkKV07XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmdldEZpbGVCeUZkT3JUaHJvdyA9IGZ1bmN0aW9uIChmZCwgZnVuY05hbWUpIHtcbiAgICAgICAgaWYgKCFpc0ZkKGZkKSlcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuRkQpO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoZmQpO1xuICAgICAgICBpZiAoIWZpbGUpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVCQURGLCBmdW5jTmFtZSk7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXROb2RlQnlJZE9yQ3JlYXRlID0gZnVuY3Rpb24gKGlkLCBmbGFncywgcGVybSkge1xuICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkKGlkKTtcbiAgICAgICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignRmlsZSBudG8gZm91bmQnKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RlcHMgPSBwYXRoVG9TdGVwcyhpZCk7XG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGluayhzdGVwcyk7XG4gICAgICAgICAgICBpZiAobGluaylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICAvLyBUcnkgY3JlYXRpbmcgYSBub2RlIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICAgIGlmIChmbGFncyAmIE9fQ1JFQVQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRpckxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsaW5rID0gdGhpcy5jcmVhdGVMaW5rKGRpckxpbmssIG5hbWVfMSwgZmFsc2UsIHBlcm0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdnZXROb2RlQnlJZE9yQ3JlYXRlJywgcGF0aFRvRmlsZW5hbWUoaWQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cmFwQXN5bmMgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlXzEuZGVmYXVsdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1ldGhvZC5hcHBseShfdGhpcywgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5fdG9KU09OID0gZnVuY3Rpb24gKGxpbmssIGpzb24sIHBhdGgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobGluayA9PT0gdm9pZCAwKSB7IGxpbmsgPSB0aGlzLnJvb3Q7IH1cbiAgICAgICAgaWYgKGpzb24gPT09IHZvaWQgMCkgeyBqc29uID0ge307IH1cbiAgICAgICAgdmFyIGlzRW1wdHkgPSB0cnVlO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBsaW5rLmNoaWxkcmVuO1xuICAgICAgICBpZiAobGluay5nZXROb2RlKCkuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gKF9hID0ge30sIF9hW2xpbmsuZ2V0TmFtZSgpXSA9IGxpbmsucGFyZW50LmdldENoaWxkKGxpbmsuZ2V0TmFtZSgpKSwgX2EpO1xuICAgICAgICAgICAgbGluayA9IGxpbmsucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIG5hbWVfMiBpbiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbGluay5nZXRDaGlsZChuYW1lXzIpO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjaGlsZC5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGNoaWxkLmdldFBhdGgoKTtcbiAgICAgICAgICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZWxhdGl2ZShwYXRoLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAganNvbltmaWxlbmFtZV0gPSBub2RlLmdldFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG9KU09OKGNoaWxkLCBqc29uLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyUGF0aCA9IGxpbmsuZ2V0UGF0aCgpO1xuICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgIGRpclBhdGggPSByZWxhdGl2ZShwYXRoLCBkaXJQYXRoKTtcbiAgICAgICAgaWYgKGRpclBhdGggJiYgaXNFbXB0eSkge1xuICAgICAgICAgICAganNvbltkaXJQYXRoXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChwYXRocywganNvbiwgaXNSZWxhdGl2ZSkge1xuICAgICAgICBpZiAoanNvbiA9PT0gdm9pZCAwKSB7IGpzb24gPSB7fTsgfVxuICAgICAgICBpZiAoaXNSZWxhdGl2ZSA9PT0gdm9pZCAwKSB7IGlzUmVsYXRpdmUgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgaWYgKHBhdGhzKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRocyBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgICAgICBwYXRocyA9IFtwYXRoc107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhdGhzXzEgPSBwYXRoczsgX2kgPCBwYXRoc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlua3MucHVzaCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGlua3MubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgbGlua3NfMSA9IGxpbmtzOyBfYSA8IGxpbmtzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluayA9IGxpbmtzXzFbX2FdO1xuICAgICAgICAgICAgdGhpcy5fdG9KU09OKGxpbmssIGpzb24sIGlzUmVsYXRpdmUgPyBsaW5rLmdldFBhdGgoKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIC8vIGZyb21KU09OKGpzb246IHtbZmlsZW5hbWU6IHN0cmluZ106IHN0cmluZ30sIGN3ZDogc3RyaW5nID0gJy8nKSB7XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIChqc29uLCBjd2QpIHtcbiAgICAgICAgaWYgKGN3ZCA9PT0gdm9pZCAwKSB7IGN3ZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmN3ZCgpOyB9XG4gICAgICAgIGZvciAodmFyIGZpbGVuYW1lIGluIGpzb24pIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ganNvbltmaWxlbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWUgPSByZXNvbHZlKGZpbGVuYW1lLCBjd2QpO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcm5hbWUgPSBzZXAgKyBzdGVwcy5zbGljZSgwLCBzdGVwcy5sZW5ndGggLSAxKS5qb2luKHNlcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShkaXJuYW1lLCA1MTEgLyogRElSICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZUZpbGVTeW5jKGZpbGVuYW1lLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShmaWxlbmFtZSwgNTExIC8qIERJUiAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5vID0gMDtcbiAgICAgICAgdGhpcy5pbm9kZXMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZElub3MgPSBbXTtcbiAgICAgICAgdGhpcy5mZHMgPSB7fTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcyA9IFtdO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcyA9IDA7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuY3JlYXRlTGluaygpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0Tm9kZSh0aGlzLmNyZWF0ZU5vZGUodHJ1ZSkpO1xuICAgIH07XG4gICAgLy8gTGVnYWN5IGludGVyZmFjZVxuICAgIFZvbHVtZS5wcm90b3R5cGUubW91bnRTeW5jID0gZnVuY3Rpb24gKG1vdW50cG9pbnQsIGpzb24pIHtcbiAgICAgICAgdGhpcy5mcm9tSlNPTihqc29uLCBtb3VudHBvaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlbkxpbmsgPSBmdW5jdGlvbiAobGluaywgZmxhZ3NOdW0sIHJlc29sdmVTeW1saW5rcykge1xuICAgICAgICBpZiAocmVzb2x2ZVN5bWxpbmtzID09PSB2b2lkIDApIHsgcmVzb2x2ZVN5bWxpbmtzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGhpcy5vcGVuRmlsZXMgPj0gdGhpcy5tYXhGaWxlcykge1xuICAgICAgICAgICAgLy8gVG9vIG1hbnkgb3BlbiBmaWxlcy5cbiAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVNRklMRSwgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSBzeW1saW5rcy5cbiAgICAgICAgdmFyIHJlYWxMaW5rID0gbGluaztcbiAgICAgICAgaWYgKHJlc29sdmVTeW1saW5rcylcbiAgICAgICAgICAgIHJlYWxMaW5rID0gdGhpcy5yZXNvbHZlU3ltbGlua3MobGluayk7XG4gICAgICAgIGlmICghcmVhbExpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIHZhciBub2RlID0gcmVhbExpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAobm9kZS5pc0RpcmVjdG9yeSgpICYmIGZsYWdzTnVtICE9PSBGTEFHUy5yKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFSVNESVIsICdvcGVuJywgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICAvLyBDaGVjayBub2RlIHBlcm1pc3Npb25zXG4gICAgICAgIGlmICghKGZsYWdzTnVtICYgT19XUk9OTFkpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY2FuUmVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihFQUNDRVMsICdvcGVuJywgbGluay5nZXRQYXRoKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFnc051bSAmIE9fUkRXUikge1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWxlID0gbmV3IHRoaXMucHJvcHMuRmlsZShsaW5rLCBub2RlLCBmbGFnc051bSwgdGhpcy5uZXdGZE51bWJlcigpKTtcbiAgICAgICAgdGhpcy5mZHNbZmlsZS5mZF0gPSBmaWxlO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcysrO1xuICAgICAgICBpZiAoZmxhZ3NOdW0gJiBPX1RSVU5DKVxuICAgICAgICAgICAgZmlsZS50cnVuY2F0ZSgpO1xuICAgICAgICByZXR1cm4gZmlsZTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlbkZpbGUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtLCByZXNvbHZlU3ltbGlua3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVTeW1saW5rcyA9PT0gdm9pZCAwKSB7IHJlc29sdmVTeW1saW5rcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIGxpbmsgPSByZXNvbHZlU3ltbGlua3MgPyB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcykgOiB0aGlzLmdldExpbmsoc3RlcHMpO1xuICAgICAgICAvLyBUcnkgY3JlYXRpbmcgYSBuZXcgZmlsZSwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIGlmICghbGluayAmJiBmbGFnc051bSAmIE9fQ1JFQVQpIHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGRpckxpbms6IExpbmsgPSB0aGlzLmdldExpbmtQYXJlbnQoc3RlcHMpO1xuICAgICAgICAgICAgdmFyIGRpckxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcy5zbGljZSgwLCBzdGVwcy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAvLyBpZighZGlyTGluaykgdGhyb3dFcnJvcihFTk9FTlQsICdvcGVuJywgZmlsZW5hbWUpO1xuICAgICAgICAgICAgaWYgKCFkaXJMaW5rKVxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnb3BlbicsIHNlcCArIHN0ZXBzLmpvaW4oc2VwKSk7XG4gICAgICAgICAgICBpZiAoZmxhZ3NOdW0gJiBPX0NSRUFUICYmIHR5cGVvZiBtb2RlTnVtID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGxpbmsgPSB0aGlzLmNyZWF0ZUxpbmsoZGlyTGluaywgc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV0sIGZhbHNlLCBtb2RlTnVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluaylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5MaW5rKGxpbmssIGZsYWdzTnVtLCByZXNvbHZlU3ltbGlua3MpO1xuICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm9wZW5CYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBmbGFnc051bSwgbW9kZU51bSwgcmVzb2x2ZVN5bWxpbmtzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlU3ltbGlua3MgPT09IHZvaWQgMCkgeyByZXNvbHZlU3ltbGlua3MgPSB0cnVlOyB9XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5vcGVuRmlsZShmaWxlbmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sIHJlc29sdmVTeW1saW5rcyk7XG4gICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnb3BlbicsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZpbGUuZmQ7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm9wZW5TeW5jID0gZnVuY3Rpb24gKHBhdGgsIGZsYWdzLCBtb2RlKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IDQzOCAvKiBERUZBVUxUICovOyB9XG4gICAgICAgIC8vIFZhbGlkYXRlICgxKSBtb2RlOyAoMikgcGF0aDsgKDMpIGZsYWdzIC0gaW4gdGhhdCBvcmRlci5cbiAgICAgICAgdmFyIG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIobW9kZSk7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgZmxhZ3NOdW0gPSBmbGFnc1RvTnVtYmVyKGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbkJhc2UoZmlsZU5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChwYXRoLCBmbGFncywgYSwgYikge1xuICAgICAgICB2YXIgbW9kZSA9IGE7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbW9kZSA9IDQzOCAvKiBERUZBVUxUICovO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IDQzOCAvKiBERUZBVUxUICovO1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIoZmxhZ3MpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLm9wZW5CYXNlLCBbZmlsZU5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jbG9zZUZpbGUgPSBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICBpZiAoIXRoaXMuZmRzW2ZpbGUuZmRdKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm9wZW5GaWxlcy0tO1xuICAgICAgICBkZWxldGUgdGhpcy5mZHNbZmlsZS5mZF07XG4gICAgICAgIHRoaXMucmVsZWFzZWRGZHMucHVzaChmaWxlLmZkKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2xvc2VTeW5jID0gZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnY2xvc2UnKTtcbiAgICAgICAgdGhpcy5jbG9zZUZpbGUoZmlsZSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGZkLCBjYWxsYmFjaykge1xuICAgICAgICB2YWxpZGF0ZUZkKGZkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jbG9zZVN5bmMsIFtmZF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlbkZpbGVPckdldEJ5SWQgPSBmdW5jdGlvbiAoaWQsIGZsYWdzTnVtLCBtb2RlTnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmRzW2lkXTtcbiAgICAgICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihFTk9FTlQpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuRmlsZShwYXRoVG9GaWxlbmFtZShpZCksIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkQmFzZSA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCk7XG4gICAgICAgIHJldHVybiBmaWxlLnJlYWQoYnVmZmVyLCBOdW1iZXIob2Zmc2V0KSwgTnVtYmVyKGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkQmFzZShmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIC8vIFRoaXMgYGlmYCBicmFuY2ggaXMgZnJvbSBOb2RlLmpzXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzXzEuZGVmYXVsdC5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAwLCBidWZmZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW1tZWRpYXRlXzEuZGVmYXVsdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlcyA9IF90aGlzLnJlYWRCYXNlKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnl0ZXMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRGaWxlQmFzZSA9IGZ1bmN0aW9uIChpZCwgZmxhZ3NOdW0sIGVuY29kaW5nKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHZhciBpc1VzZXJGZCA9IHR5cGVvZiBpZCA9PT0gJ251bWJlcic7XG4gICAgICAgIHZhciB1c2VyT3duc0ZkID0gaXNVc2VyRmQgJiYgaXNGZChpZCk7XG4gICAgICAgIHZhciBmZDtcbiAgICAgICAgaWYgKHVzZXJPd25zRmQpXG4gICAgICAgICAgICBmZCA9IGlkO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKGlkKTtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzKTtcbiAgICAgICAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKEVJU0RJUiwgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmZCA9IHRoaXMub3BlblN5bmMoaWQsIGZsYWdzTnVtKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVyVG9FbmNvZGluZyh0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCkuZ2V0QnVmZmVyKCksIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghdXNlck93bnNGZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkRmlsZVN5bmMgPSBmdW5jdGlvbiAoZmlsZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IGdldFJlYWRGaWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihvcHRzLmZsYWcpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkRmlsZUJhc2UoZmlsZSwgZmxhZ3NOdW0sIG9wdHMuZW5jb2RpbmcpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkRmlsZSA9IGZ1bmN0aW9uIChpZCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0UmVhZEZpbGVPcHRpb25zKShhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB2YXIgZmxhZ3NOdW0gPSBmbGFnc1RvTnVtYmVyKG9wdHMuZmxhZyk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhZEZpbGVCYXNlLCBbaWQsIGZsYWdzTnVtLCBvcHRzLmVuY29kaW5nXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cml0ZUJhc2UgPSBmdW5jdGlvbiAoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICd3cml0ZScpO1xuICAgICAgICByZXR1cm4gZmlsZS53cml0ZShidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uIChmZCwgYSwgYiwgYywgZCkge1xuICAgICAgICB2YWxpZGF0ZUZkKGZkKTtcbiAgICAgICAgdmFyIGVuY29kaW5nO1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgcG9zaXRpb247XG4gICAgICAgIHZhciBpc0J1ZmZlciA9IHR5cGVvZiBhICE9PSAnc3RyaW5nJztcbiAgICAgICAgaWYgKGlzQnVmZmVyKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGM7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGI7XG4gICAgICAgICAgICBlbmNvZGluZyA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IGRhdGFUb0J1ZmZlcihhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmIChpc0J1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQmFzZShmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChmZCwgYSwgYiwgYywgZCwgZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YWxpZGF0ZUZkKGZkKTtcbiAgICAgICAgdmFyIG9mZnNldDtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIHBvc2l0aW9uO1xuICAgICAgICB2YXIgZW5jb2Rpbmc7XG4gICAgICAgIHZhciBjYWxsYmFjaztcbiAgICAgICAgdmFyIHRpcGEgPSB0eXBlb2YgYTtcbiAgICAgICAgdmFyIHRpcGIgPSB0eXBlb2YgYjtcbiAgICAgICAgdmFyIHRpcGMgPSB0eXBlb2YgYztcbiAgICAgICAgdmFyIHRpcGQgPSB0eXBlb2YgZDtcbiAgICAgICAgaWYgKHRpcGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodGlwYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpcGMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aXBkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gYiB8IDA7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBjO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gZDtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGlwYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpcGMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGI7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gYjtcbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGM7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBkYXRhVG9CdWZmZXIoYSwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAodGlwYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICAgIHNldEltbWVkaWF0ZV8xLmRlZmF1bHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZXMgPSBfdGhpcy53cml0ZUJhc2UoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodGlwYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnl0ZXMsIGJ1Zik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cml0ZUZpbGVCYXNlID0gZnVuY3Rpb24gKGlkLCBidWYsIGZsYWdzTnVtLCBtb2RlTnVtKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd3cml0ZUZpbGVCYXNlJywgaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgICAgICAvLyBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlQnlJZE9yQ3JlYXRlKGlkLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIC8vIG5vZGUuc2V0QnVmZmVyKGJ1Zik7XG4gICAgICAgIHZhciBpc1VzZXJGZCA9IHR5cGVvZiBpZCA9PT0gJ251bWJlcic7XG4gICAgICAgIHZhciBmZDtcbiAgICAgICAgaWYgKGlzVXNlckZkKVxuICAgICAgICAgICAgZmQgPSBpZDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmZCA9IHRoaXMub3BlbkJhc2UocGF0aFRvRmlsZW5hbWUoaWQpLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgICAgICAvLyBmZCA9IHRoaXMub3BlblN5bmMoaWQgYXMgVEZpbGVQYXRoLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBmbGFnc051bSAmIE9fQVBQRU5EID8gbnVsbCA6IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciB3cml0dGVuID0gdGhpcy53cml0ZVN5bmMoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gd3JpdHRlbjtcbiAgICAgICAgICAgICAgICBsZW5ndGggLT0gd3JpdHRlbjtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uICs9IHdyaXR0ZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIWlzVXNlckZkKVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cml0ZUZpbGVTeW5jID0gZnVuY3Rpb24gKGlkLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gZ2V0V3JpdGVGaWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihvcHRzLmZsYWcpO1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihvcHRzLm1vZGUpO1xuICAgICAgICB2YXIgYnVmID0gZGF0YVRvQnVmZmVyKGRhdGEsIG9wdHMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyaXRlRmlsZUJhc2UoaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53cml0ZUZpbGUgPSBmdW5jdGlvbiAoaWQsIGRhdGEsIGEsIGIpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB3cml0ZUZpbGVEZWZhdWx0cztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0cyA9IGdldFdyaXRlRmlsZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIob3B0cy5mbGFnKTtcbiAgICAgICAgdmFyIG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIob3B0cy5tb2RlKTtcbiAgICAgICAgdmFyIGJ1ZiA9IGRhdGFUb0J1ZmZlcihkYXRhLCBvcHRzLmVuY29kaW5nKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy53cml0ZUZpbGVCYXNlLCBbaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxpbmtCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lMSwgZmlsZW5hbWUyKSB7XG4gICAgICAgIHZhciBzdGVwczEgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUxKTtcbiAgICAgICAgdmFyIGxpbmsxID0gdGhpcy5nZXRMaW5rKHN0ZXBzMSk7XG4gICAgICAgIGlmICghbGluazEpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ2xpbmsnLCBmaWxlbmFtZTEsIGZpbGVuYW1lMik7XG4gICAgICAgIHZhciBzdGVwczIgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUyKTtcbiAgICAgICAgLy8gQ2hlY2sgbmV3IGxpbmsgZGlyZWN0b3J5IGV4aXN0cy5cbiAgICAgICAgdmFyIGRpcjIgPSB0aGlzLmdldExpbmtQYXJlbnQoc3RlcHMyKTtcbiAgICAgICAgaWYgKCFkaXIyKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdsaW5rJywgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICB2YXIgbmFtZSA9IHN0ZXBzMltzdGVwczIubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIENoZWNrIGlmIG5ldyBmaWxlIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBpZiAoZGlyMi5nZXRDaGlsZChuYW1lKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUVYSVNULCAnbGluaycsIGZpbGVuYW1lMSwgZmlsZW5hbWUyKTtcbiAgICAgICAgdmFyIG5vZGUgPSBsaW5rMS5nZXROb2RlKCk7XG4gICAgICAgIG5vZGUubmxpbmsrKztcbiAgICAgICAgZGlyMi5jcmVhdGVDaGlsZChuYW1lLCBub2RlKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY29weUZpbGVCYXNlID0gZnVuY3Rpb24gKHNyYywgZGVzdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICAgIGlmIChmbGFncyAmIENPUFlGSUxFX0VYQ0wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV4aXN0c1N5bmMoZGVzdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKEVFWElTVCwgJ2NvcHlGaWxlJywgc3JjLCBkZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MgJiBDT1BZRklMRV9GSUNMT05FX0ZPUkNFKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT1NZUywgJ2NvcHlGaWxlJywgc3JjLCBkZXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlRmlsZUJhc2UoZGVzdCwgYnVmLCBGTEFHUy53LCA0MzggLyogREVGQVVMVCAqLyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNvcHlGaWxlU3luYyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzKSB7XG4gICAgICAgIHZhciBzcmNGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHNyYyk7XG4gICAgICAgIHZhciBkZXN0RmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShkZXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weUZpbGVCYXNlKHNyY0ZpbGVuYW1lLCBkZXN0RmlsZW5hbWUsIGZsYWdzIHwgMCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNvcHlGaWxlID0gZnVuY3Rpb24gKHNyYywgZGVzdCwgYSwgYikge1xuICAgICAgICB2YXIgc3JjRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShzcmMpO1xuICAgICAgICB2YXIgZGVzdEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoZGVzdCk7XG4gICAgICAgIHZhciBmbGFncztcbiAgICAgICAgdmFyIGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGZsYWdzID0gMDtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZsYWdzID0gYTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYjtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jb3B5RmlsZUJhc2UsIFtzcmNGaWxlbmFtZSwgZGVzdEZpbGVuYW1lLCBmbGFnc10sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGlua1N5bmMgPSBmdW5jdGlvbiAoZXhpc3RpbmdQYXRoLCBuZXdQYXRoKSB7XG4gICAgICAgIHZhciBleGlzdGluZ1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKGV4aXN0aW5nUGF0aCk7XG4gICAgICAgIHZhciBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy5saW5rQmFzZShleGlzdGluZ1BhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGluayA9IGZ1bmN0aW9uIChleGlzdGluZ1BhdGgsIG5ld1BhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBleGlzdGluZ1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKGV4aXN0aW5nUGF0aCk7XG4gICAgICAgIHZhciBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5saW5rQmFzZSwgW2V4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnVubGlua0Jhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldExpbmsoc3RlcHMpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ3VubGluaycsIGZpbGVuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgaXQgaXMgZmlsZSwgZGlyLCBvdGhlci4uLlxuICAgICAgICBpZiAobGluay5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRGlyIG5vdCBlbXB0eS4uLicpO1xuICAgICAgICB0aGlzLmRlbGV0ZUxpbmsobGluayk7XG4gICAgICAgIHZhciBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgIG5vZGUubmxpbmstLTtcbiAgICAgICAgLy8gV2hlbiBhbGwgaGFyZCBsaW5rcyB0byBpLW5vZGUgYXJlIGRlbGV0ZWQsIHJlbW92ZSB0aGUgaS1ub2RlLCB0b28uXG4gICAgICAgIGlmIChub2RlLm5saW5rIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS51bmxpbmtTeW5jID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMudW5saW5rQmFzZShmaWxlbmFtZSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy51bmxpbmtCYXNlLCBbZmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnN5bWxpbmtCYXNlID0gZnVuY3Rpb24gKHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpIHtcbiAgICAgICAgdmFyIHBhdGhTdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhwYXRoRmlsZW5hbWUpO1xuICAgICAgICAvLyBDaGVjayBpZiBkaXJlY3RvcnkgZXhpc3RzLCB3aGVyZSB3ZSBhYm91dCB0byBjcmVhdGUgYSBzeW1saW5rLlxuICAgICAgICB2YXIgZGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChwYXRoU3RlcHMpO1xuICAgICAgICBpZiAoIWRpckxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ3N5bWxpbmsnLCB0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXRoU3RlcHNbcGF0aFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBDaGVjayBpZiBuZXcgZmlsZSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgaWYgKGRpckxpbmsuZ2V0Q2hpbGQobmFtZSkpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVFWElTVCwgJ3N5bWxpbmsnLCB0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gQ3JlYXRlIHN5bWxpbmsuXG4gICAgICAgIHZhciBzeW1saW5rID0gZGlyTGluay5jcmVhdGVDaGlsZChuYW1lKTtcbiAgICAgICAgc3ltbGluay5nZXROb2RlKCkubWFrZVN5bWxpbmsoZmlsZW5hbWVUb1N0ZXBzKHRhcmdldEZpbGVuYW1lKSk7XG4gICAgICAgIHJldHVybiBzeW1saW5rO1xuICAgIH07XG4gICAgLy8gYHR5cGVgIGFyZ3VtZW50IHdvcmtzIG9ubHkgb24gV2luZG93cy5cbiAgICBWb2x1bWUucHJvdG90eXBlLnN5bWxpbmtTeW5jID0gZnVuY3Rpb24gKHRhcmdldCwgcGF0aCwgdHlwZSkge1xuICAgICAgICB2YXIgdGFyZ2V0RmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZSh0YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMuc3ltbGlua0Jhc2UodGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnN5bWxpbmsgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldEFyZ0FuZENiKGEsIGIpLCB0eXBlID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHZhciB0YXJnZXRGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5zeW1saW5rQmFzZSwgW3RhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWVdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWxwYXRoQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIHJlYWxMaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoc3RlcHMpO1xuICAgICAgICBpZiAoIXJlYWxMaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdyZWFscGF0aCcsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZyhyZWFsTGluay5nZXRQYXRoKCksIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhbHBhdGhTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHBhdGhCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCBnZXRSZWFscGF0aE9wdGlvbnMob3B0aW9ucykuZW5jb2RpbmcpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFscGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldFJlYWxwYXRoT3B0c0FuZENiKGEsIGIpLCBvcHRzID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHZhciBwYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFscGF0aEJhc2UsIFtwYXRoRmlsZW5hbWUsIG9wdHMuZW5jb2RpbmddLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxzdGF0QmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgYmlnaW50KSB7XG4gICAgICAgIGlmIChiaWdpbnQgPT09IHZvaWQgMCkgeyBiaWdpbnQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGluayhmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdsc3RhdCcsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIFN0YXRzXzEuZGVmYXVsdC5idWlsZChsaW5rLmdldE5vZGUoKSwgYmlnaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubHN0YXRTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubHN0YXRCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCBnZXRTdGF0T3B0aW9ucyhvcHRpb25zKS5iaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5sc3RhdCA9IGZ1bmN0aW9uIChwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldFN0YXRPcHRzQW5kQ2IoYSwgYiksIG9wdHMgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sc3RhdEJhc2UsIFtwYXRoVG9GaWxlbmFtZShwYXRoKSwgb3B0cy5iaWdpbnRdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnN0YXRCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBiaWdpbnQpIHtcbiAgICAgICAgaWYgKGJpZ2ludCA9PT0gdm9pZCAwKSB7IGJpZ2ludCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKSk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnc3RhdCcsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIFN0YXRzXzEuZGVmYXVsdC5idWlsZChsaW5rLmdldE5vZGUoKSwgYmlnaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuc3RhdFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0QmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSwgZ2V0U3RhdE9wdGlvbnMob3B0aW9ucykuYmlnaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uIChwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldFN0YXRPcHRzQW5kQ2IoYSwgYiksIG9wdHMgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5zdGF0QmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCBvcHRzLmJpZ2ludF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN0YXRCYXNlID0gZnVuY3Rpb24gKGZkLCBiaWdpbnQpIHtcbiAgICAgICAgaWYgKGJpZ2ludCA9PT0gdm9pZCAwKSB7IGJpZ2ludCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZChmZCk7XG4gICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUJBREYsICdmc3RhdCcpO1xuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGZpbGUubm9kZSwgYmlnaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN0YXRTeW5jID0gZnVuY3Rpb24gKGZkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZzdGF0QmFzZShmZCwgZ2V0U3RhdE9wdGlvbnMob3B0aW9ucykuYmlnaW50KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN0YXQgPSBmdW5jdGlvbiAoZmQsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0U3RhdE9wdHNBbmRDYihhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZzdGF0QmFzZSwgW2ZkLCBvcHRzLmJpZ2ludF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVuYW1lQmFzZSA9IGZ1bmN0aW9uIChvbGRQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGluayhmaWxlbmFtZVRvU3RlcHMob2xkUGF0aEZpbGVuYW1lKSk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAncmVuYW1lJywgb2xkUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBpdCBpcyBkaXJlY3RvcnksIGlmIG5vbi1lbXB0eSwgd2UgY2Fubm90IG1vdmUgaXQsIHJpZ2h0P1xuICAgICAgICB2YXIgbmV3UGF0aFN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIENoZWNrIGRpcmVjdG9yeSBleGlzdHMgZm9yIHRoZSBuZXcgbG9jYXRpb24uXG4gICAgICAgIHZhciBuZXdQYXRoRGlyTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChuZXdQYXRoU3RlcHMpO1xuICAgICAgICBpZiAoIW5ld1BhdGhEaXJMaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdyZW5hbWUnLCBvbGRQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIFRPRE86IEFsc28gdHJlYXQgY2FzZXMgd2l0aCBkaXJlY3RvcmllcyBhbmQgc3ltYm9saWMgbGlua3MuXG4gICAgICAgIC8vIFRPRE86IFNlZTogaHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW4yL3JlbmFtZS4yLmh0bWxcbiAgICAgICAgLy8gUmVtb3ZlIGhhcmQgbGluayBmcm9tIG9sZCBmb2xkZXIuXG4gICAgICAgIHZhciBvbGRMaW5rUGFyZW50ID0gbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChvbGRMaW5rUGFyZW50KSB7XG4gICAgICAgICAgICBvbGRMaW5rUGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmFtZSBzaG91bGQgb3ZlcndyaXRlIHRoZSBuZXcgcGF0aCwgaWYgdGhhdCBleGlzdHMuXG4gICAgICAgIHZhciBuYW1lID0gbmV3UGF0aFN0ZXBzW25ld1BhdGhTdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGluay5zdGVwcyA9IF9fc3ByZWFkQXJyYXlzKG5ld1BhdGhEaXJMaW5rLnN0ZXBzLCBbbmFtZV0pO1xuICAgICAgICBuZXdQYXRoRGlyTGluay5zZXRDaGlsZChsaW5rLmdldE5hbWUoKSwgbGluayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlbmFtZVN5bmMgPSBmdW5jdGlvbiAob2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICB2YXIgb2xkUGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUob2xkUGF0aCk7XG4gICAgICAgIHZhciBuZXdQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShuZXdQYXRoKTtcbiAgICAgICAgdGhpcy5yZW5hbWVCYXNlKG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24gKG9sZFBhdGgsIG5ld1BhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBvbGRQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShvbGRQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlbmFtZUJhc2UsIFtvbGRQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZXhpc3RzQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnN0YXRCYXNlKGZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZXhpc3RzU3luYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGlzdHNCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoRVJSU1RSLkNCKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlXzEuZGVmYXVsdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKF90aGlzLmV4aXN0c0Jhc2UoZmlsZW5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5hY2Nlc3NCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBtb2RlKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2FjY2VzcycpO1xuICAgICAgICAvLyBUT0RPOiBWZXJpZnkgcGVybWlzc2lvbnNcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuYWNjZXNzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IEZfT0s7IH1cbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIG1vZGUgPSBtb2RlIHwgMDtcbiAgICAgICAgdGhpcy5hY2Nlc3NCYXNlKGZpbGVuYW1lLCBtb2RlKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuYWNjZXNzID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBhO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1vZGUgPSBGX09LO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBtb2RlID0gbW9kZSB8IDA7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuYWNjZXNzQmFzZSwgW2ZpbGVuYW1lLCBtb2RlXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5hcHBlbmRGaWxlU3luYyA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBhcHBlbmRGaWxlRGVmYXVsdHM7IH1cbiAgICAgICAgdmFyIG9wdHMgPSBnZXRBcHBlbmRGaWxlT3B0cyhvcHRpb25zKTtcbiAgICAgICAgLy8gZm9yY2UgYXBwZW5kIGJlaGF2aW9yIHdoZW4gdXNpbmcgYSBzdXBwbGllZCBmaWxlIGRlc2NyaXB0b3JcbiAgICAgICAgaWYgKCFvcHRzLmZsYWcgfHwgaXNGZChpZCkpXG4gICAgICAgICAgICBvcHRzLmZsYWcgPSAnYSc7XG4gICAgICAgIHRoaXMud3JpdGVGaWxlU3luYyhpZCwgZGF0YSwgb3B0cyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmFwcGVuZEZpbGUgPSBmdW5jdGlvbiAoaWQsIGRhdGEsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0QXBwZW5kRmlsZU9wdHNBbmRDYihhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICAvLyBmb3JjZSBhcHBlbmQgYmVoYXZpb3Igd2hlbiB1c2luZyBhIHN1cHBsaWVkIGZpbGUgZGVzY3JpcHRvclxuICAgICAgICBpZiAoIW9wdHMuZmxhZyB8fCBpc0ZkKGlkKSlcbiAgICAgICAgICAgIG9wdHMuZmxhZyA9ICdhJztcbiAgICAgICAgdGhpcy53cml0ZUZpbGUoaWQsIGRhdGEsIG9wdHMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGRpckJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcyk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAncmVhZGRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKCFub2RlLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT1RESVIsICdzY2FuZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICBpZiAob3B0aW9ucy53aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICB2YXIgbGlzdF8xID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gbGluay5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGxpc3RfMS5wdXNoKERpcmVudF8xLmRlZmF1bHQuYnVpbGQobGluay5jaGlsZHJlbltuYW1lXzNdLCBvcHRpb25zLmVuY29kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzV2luICYmIG9wdGlvbnMuZW5jb2RpbmcgIT09ICdidWZmZXInKVxuICAgICAgICAgICAgICAgIGxpc3RfMS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPCBiLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLm5hbWUgPiBiLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGlzdF8xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIG5hbWVfNCBpbiBsaW5rLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2goZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKG5hbWVfNCwgb3B0aW9ucy5lbmNvZGluZykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXaW4gJiYgb3B0aW9ucy5lbmNvZGluZyAhPT0gJ2J1ZmZlcicpXG4gICAgICAgICAgICBsaXN0LnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRkaXJTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRSZWFkZGlyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRkaXJCYXNlKGZpbGVuYW1lLCBvcHRzKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uIChwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldFJlYWRkaXJPcHRzQW5kQ2IoYSwgYiksIG9wdGlvbnMgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVhZGRpckJhc2UsIFtmaWxlbmFtZSwgb3B0aW9uc10sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGxpbmtCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBlbmNvZGluZykge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsICdyZWFkbGluaycpO1xuICAgICAgICB2YXIgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIW5vZGUuaXNTeW1saW5rKCkpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVJTlZBTCwgJ3JlYWRsaW5rJywgZmlsZW5hbWUpO1xuICAgICAgICB2YXIgc3RyID0gc2VwICsgbm9kZS5zeW1saW5rLmpvaW4oc2VwKTtcbiAgICAgICAgcmV0dXJuIGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZyhzdHIsIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGxpbmtTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBnZXREZWZhdWx0T3B0cyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRsaW5rQmFzZShmaWxlbmFtZSwgb3B0cy5lbmNvZGluZyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRsaW5rID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdE9wdHNBbmRDYihhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFkbGlua0Jhc2UsIFtmaWxlbmFtZSwgb3B0cy5lbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN5bmNCYXNlID0gZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZnN5bmMnKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN5bmNTeW5jID0gZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgIHRoaXMuZnN5bmNCYXNlKGZkKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnN5bmMgPSBmdW5jdGlvbiAoZmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnN5bmNCYXNlLCBbZmRdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZkYXRhc3luY0Jhc2UgPSBmdW5jdGlvbiAoZmQpIHtcbiAgICAgICAgdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICdmZGF0YXN5bmMnKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmRhdGFzeW5jU3luYyA9IGZ1bmN0aW9uIChmZCkge1xuICAgICAgICB0aGlzLmZkYXRhc3luY0Jhc2UoZmQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mZGF0YXN5bmMgPSBmdW5jdGlvbiAoZmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZmRhdGFzeW5jQmFzZSwgW2ZkXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mdHJ1bmNhdGVCYXNlID0gZnVuY3Rpb24gKGZkLCBsZW4pIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Z0cnVuY2F0ZScpO1xuICAgICAgICBmaWxlLnRydW5jYXRlKGxlbik7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZ0cnVuY2F0ZVN5bmMgPSBmdW5jdGlvbiAoZmQsIGxlbikge1xuICAgICAgICB0aGlzLmZ0cnVuY2F0ZUJhc2UoZmQsIGxlbik7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZ0cnVuY2F0ZSA9IGZ1bmN0aW9uIChmZCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXRBcmdBbmRDYihhLCBiKSwgbGVuID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnRydW5jYXRlQmFzZSwgW2ZkLCBsZW5dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnRydW5jYXRlQmFzZSA9IGZ1bmN0aW9uIChwYXRoLCBsZW4pIHtcbiAgICAgICAgdmFyIGZkID0gdGhpcy5vcGVuU3luYyhwYXRoLCAncisnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZnRydW5jYXRlU3luYyhmZCwgbGVuKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS50cnVuY2F0ZVN5bmMgPSBmdW5jdGlvbiAoaWQsIGxlbikge1xuICAgICAgICBpZiAoaXNGZChpZCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdHJ1bmNhdGVTeW5jKGlkLCBsZW4pO1xuICAgICAgICB0aGlzLnRydW5jYXRlQmFzZShpZCwgbGVuKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbiAoaWQsIGEsIGIpIHtcbiAgICAgICAgaWYgKGlzRmQoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnRydW5jYXRlKGlkLCBhLCBiKTtcbiAgICAgICAgdmFyIF9hID0gZ2V0QXJnQW5kQ2IoYSwgYiwgMCksIGxlbiA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnRydW5jYXRlQmFzZSwgW2lkLCBsZW5dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZ1dGltZXNCYXNlID0gZnVuY3Rpb24gKGZkLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2Z1dGltZXMnKTtcbiAgICAgICAgdmFyIG5vZGUgPSBmaWxlLm5vZGU7XG4gICAgICAgIG5vZGUuYXRpbWUgPSBuZXcgRGF0ZShhdGltZSAqIDEwMDApO1xuICAgICAgICBub2RlLm10aW1lID0gbmV3IERhdGUobXRpbWUgKiAxMDAwKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoZmQsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB0aGlzLmZ1dGltZXNCYXNlKGZkLCB0b1VuaXhUaW1lc3RhbXAoYXRpbWUpLCB0b1VuaXhUaW1lc3RhbXAobXRpbWUpKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnV0aW1lcyA9IGZ1bmN0aW9uIChmZCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZ1dGltZXNCYXNlLCBbZmQsIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSldLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnV0aW1lc0Jhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB2YXIgZmQgPSB0aGlzLm9wZW5TeW5jKGZpbGVuYW1lLCAncisnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZnV0aW1lc0Jhc2UoZmQsIGF0aW1lLCBtdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudXRpbWVzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgdGhpcy51dGltZXNCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCB0b1VuaXhUaW1lc3RhbXAoYXRpbWUpLCB0b1VuaXhUaW1lc3RhbXAobXRpbWUpKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudXRpbWVzID0gZnVuY3Rpb24gKHBhdGgsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy51dGltZXNCYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSldLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm1rZGlyQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgdXNlciB0cmllcyB0byBjcmVhdGUgcm9vdCBkaXIgYGZzLm1rZGlyU3luYygnLycpYC5cbiAgICAgICAgaWYgKCFzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUlTRElSLCAnbWtkaXInLCBmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpciA9IHRoaXMuZ2V0TGlua1BhcmVudEFzRGlyT3JUaHJvdyhmaWxlbmFtZSwgJ21rZGlyJyk7XG4gICAgICAgIC8vIENoZWNrIHBhdGggYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIHZhciBuYW1lID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkaXIuZ2V0Q2hpbGQobmFtZSkpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVFWElTVCwgJ21rZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICBkaXIuY3JlYXRlQ2hpbGQobmFtZSwgdGhpcy5jcmVhdGVOb2RlKHRydWUsIG1vZGVOdW0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgZGlyZWN0b3J5IHRyZWUgcmVjdXJzaXZlbHkuXG4gICAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAgICogQHBhcmFtIG1vZGVOdW1cbiAgICAgKi9cbiAgICBWb2x1bWUucHJvdG90eXBlLm1rZGlycEJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJvb3Q7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgICAgICBpZiAoIWxpbmsuZ2V0Tm9kZSgpLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9URElSLCAnbWtkaXInLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBsaW5rLmdldENoaWxkKHN0ZXApO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgICAgICAgICBsaW5rID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKEVOT1RESVIsICdta2RpcicsIGNoaWxkLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5rID0gbGluay5jcmVhdGVDaGlsZChzdGVwLCB0aGlzLmNyZWF0ZU5vZGUodHJ1ZSwgbW9kZU51bSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm1rZGlyU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gZ2V0TWtkaXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihvcHRzLm1vZGUsIDUxMSk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBpZiAob3B0cy5yZWN1cnNpdmUpXG4gICAgICAgICAgICB0aGlzLm1rZGlycEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLm1rZGlyQmFzZShmaWxlbmFtZSwgbW9kZU51bSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm1rZGlyID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0QXJnQW5kQ2IoYSwgYiksIG9wdGlvbnMgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRNa2Rpck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG9wdHMubW9kZSwgNTExKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubWtkaXJwQmFzZSwgW2ZpbGVuYW1lLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLm1rZGlyQmFzZSwgW2ZpbGVuYW1lLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gbGVnYWN5IGludGVyZmFjZVxuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkaXJwU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgICAgIHRoaXMubWtkaXJTeW5jKHBhdGgsIHsgbW9kZTogbW9kZSwgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5ta2RpcnAgPSBmdW5jdGlvbiAocGF0aCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXRBcmdBbmRDYihhLCBiKSwgbW9kZSA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB0aGlzLm1rZGlyKHBhdGgsIHsgbW9kZTogbW9kZSwgcmVjdXJzaXZlOiB0cnVlIH0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkdGVtcEJhc2UgPSBmdW5jdGlvbiAocHJlZml4LCBlbmNvZGluZywgcmV0cnkpIHtcbiAgICAgICAgaWYgKHJldHJ5ID09PSB2b2lkIDApIHsgcmV0cnkgPSA1OyB9XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHByZWZpeCArIHRoaXMuZ2VuUm5kU3RyKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm1rZGlyQmFzZShmaWxlbmFtZSwgNTExIC8qIERJUiAqLyk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKGZpbGVuYW1lLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBFRVhJU1QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmV0cnkgPiAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1rZHRlbXBCYXNlKHByZWZpeCwgZW5jb2RpbmcsIHJldHJ5IC0gMSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSB0ZW1wIGRpci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkdGVtcFN5bmMgPSBmdW5jdGlvbiAocHJlZml4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IGdldERlZmF1bHRPcHRzKG9wdGlvbnMpLmVuY29kaW5nO1xuICAgICAgICBpZiAoIXByZWZpeCB8fCB0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoIW51bGxDaGVjayhwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdGhpcy5ta2R0ZW1wQmFzZShwcmVmaXgsIGVuY29kaW5nKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkdGVtcCA9IGZ1bmN0aW9uIChwcmVmaXgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdE9wdHNBbmRDYihhLCBiKSwgZW5jb2RpbmcgPSBfYVswXS5lbmNvZGluZywgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgaWYgKCFwcmVmaXggfHwgdHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlbmFtZSBwcmVmaXggaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgaWYgKCFudWxsQ2hlY2socHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ta2R0ZW1wQmFzZSwgW3ByZWZpeCwgZW5jb2RpbmddLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJtZGlyQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGlua0FzRGlyT3JUaHJvdyhmaWxlbmFtZSwgJ3JtZGlyJyk7XG4gICAgICAgIC8vIENoZWNrIGRpcmVjdG9yeSBpcyBlbXB0eS5cbiAgICAgICAgaWYgKGxpbmsubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9URU1QVFksICdybWRpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kZWxldGVMaW5rKGxpbmspO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5ybWRpclN5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB0aGlzLnJtZGlyQmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJtZGlyID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucm1kaXJCYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCldLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZjaG1vZEJhc2UgPSBmdW5jdGlvbiAoZmQsIG1vZGVOdW0pIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2ZjaG1vZCcpO1xuICAgICAgICBmaWxlLmNobW9kKG1vZGVOdW0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mY2htb2RTeW5jID0gZnVuY3Rpb24gKGZkLCBtb2RlKSB7XG4gICAgICAgIHRoaXMuZmNobW9kQmFzZShmZCwgbW9kZVRvTnVtYmVyKG1vZGUpKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmNobW9kID0gZnVuY3Rpb24gKGZkLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmZjaG1vZEJhc2UsIFtmZCwgbW9kZVRvTnVtYmVyKG1vZGUpXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jaG1vZEJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgdmFyIGZkID0gdGhpcy5vcGVuU3luYyhmaWxlbmFtZSwgJ3IrJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZjaG1vZEJhc2UoZmQsIG1vZGVOdW0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNobW9kU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5jaG1vZEJhc2UoZmlsZW5hbWUsIG1vZGVOdW0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuY2htb2RCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxjaG1vZEJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG1vZGVOdW0pIHtcbiAgICAgICAgdmFyIGZkID0gdGhpcy5vcGVuQmFzZShmaWxlbmFtZSwgT19SRFdSLCAwLCBmYWxzZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmZjaG1vZEJhc2UoZmQsIG1vZGVOdW0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxjaG1vZFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMubGNobW9kQmFzZShmaWxlbmFtZSwgbW9kZU51bSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxjaG1vZCA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubGNobW9kQmFzZSwgW2ZpbGVuYW1lLCBtb2RlTnVtXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mY2hvd25CYXNlID0gZnVuY3Rpb24gKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2ZjaG93bicpLmNob3duKHVpZCwgZ2lkKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmNob3duU3luYyA9IGZ1bmN0aW9uIChmZCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy5mY2hvd25CYXNlKGZkLCB1aWQsIGdpZCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZjaG93biA9IGZ1bmN0aW9uIChmZCwgdWlkLCBnaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZmNob3duQmFzZSwgW2ZkLCB1aWQsIGdpZF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2hvd25CYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCB1aWQsIGdpZCkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2Nob3duJyk7XG4gICAgICAgIHZhciBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgIG5vZGUuY2hvd24odWlkLCBnaWQpO1xuICAgICAgICAvLyBpZihub2RlLmlzRmlsZSgpIHx8IG5vZGUuaXNTeW1saW5rKCkpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gfSBlbHNlIGlmKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBXaGF0IGRvIHdlIGRvIGhlcmU/XG4gICAgICAgIC8vIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2hvd25TeW5jID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMuY2hvd25CYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCB1aWQsIGdpZCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNob3duID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVVpZCh1aWQpO1xuICAgICAgICB2YWxpZGF0ZUdpZChnaWQpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNob3duQmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCB1aWQsIGdpZF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGNob3duQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgdWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ2xjaG93bicpXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAuY2hvd24odWlkLCBnaWQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5sY2hvd25TeW5jID0gZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMubGNob3duQmFzZShwYXRoVG9GaWxlbmFtZShwYXRoKSwgdWlkLCBnaWQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubGNob3duQmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCB1aWQsIGdpZF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUud2F0Y2hGaWxlID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBvcHRpb25zID0gYTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gYjtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IGE7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignXCJ3YXRjaEZpbGUoKVwiIHJlcXVpcmVzIGEgbGlzdGVuZXIgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSA1MDA3O1xuICAgICAgICB2YXIgcGVyc2lzdGVudCA9IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmludGVydmFsID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBpbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucGVyc2lzdGVudCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgIHBlcnNpc3RlbnQgPSBvcHRpb25zLnBlcnNpc3RlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLnN0YXRXYXRjaGVyc1tmaWxlbmFtZV07XG4gICAgICAgIGlmICghd2F0Y2hlcikge1xuICAgICAgICAgICAgd2F0Y2hlciA9IG5ldyB0aGlzLlN0YXRXYXRjaGVyKCk7XG4gICAgICAgICAgICB3YXRjaGVyLnN0YXJ0KGZpbGVuYW1lLCBwZXJzaXN0ZW50LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRXYXRjaGVyc1tmaWxlbmFtZV0gPSB3YXRjaGVyO1xuICAgICAgICB9XG4gICAgICAgIHdhdGNoZXIuYWRkTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHdhdGNoZXI7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnVud2F0Y2hGaWxlID0gZnVuY3Rpb24gKHBhdGgsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuc3RhdFdhdGNoZXJzW2ZpbGVuYW1lXTtcbiAgICAgICAgaWYgKCF3YXRjaGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3YXRjaGVyLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXRjaGVyLnJlbW92ZUFsbExpc3RlbmVycygnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhdGNoZXIubGlzdGVuZXJDb3VudCgnY2hhbmdlJykgPT09IDApIHtcbiAgICAgICAgICAgIHdhdGNoZXIuc3RvcCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3RhdFdhdGNoZXJzW2ZpbGVuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNyZWF0ZVdyaXRlU3RyZWFtID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLldyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLy8gd2F0Y2gocGF0aDogVEZpbGVQYXRoKTogRlNXYXRjaGVyO1xuICAgIC8vIHdhdGNoKHBhdGg6IFRGaWxlUGF0aCwgb3B0aW9ucz86IElXYXRjaE9wdGlvbnMgfCBzdHJpbmcpOiBGU1dhdGNoZXI7XG4gICAgVm9sdW1lLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsaXN0ZW5lciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgIHZhciBfYSA9IGdldERlZmF1bHRPcHRzKG9wdGlvbnMpLCBwZXJzaXN0ZW50ID0gX2EucGVyc2lzdGVudCwgcmVjdXJzaXZlID0gX2EucmVjdXJzaXZlLCBlbmNvZGluZyA9IF9hLmVuY29kaW5nO1xuICAgICAgICBpZiAocGVyc2lzdGVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGVyc2lzdGVudCA9IHRydWU7XG4gICAgICAgIGlmIChyZWN1cnNpdmUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlY3Vyc2l2ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgd2F0Y2hlciA9IG5ldyB0aGlzLkZTV2F0Y2hlcigpO1xuICAgICAgICB3YXRjaGVyLnN0YXJ0KGZpbGVuYW1lLCBwZXJzaXN0ZW50LCByZWN1cnNpdmUsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB3YXRjaGVyLmFkZExpc3RlbmVyKCdjaGFuZ2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdhdGNoZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgZmlsZSBkZXNjcmlwdG9yIGNvdW50ZXIuIFVOSVggZmlsZSBkZXNjcmlwdG9ycyBzdGFydCBmcm9tIDAgYW5kIGdvIHNlcXVlbnRpYWxseVxuICAgICAqIHVwLCBzbyBoZXJlLCBpbiBvcmRlciBub3QgdG8gY29uZmxpY3Qgd2l0aCB0aGVtLCB3ZSBjaG9vc2Ugc29tZSBiaWcgbnVtYmVyIGFuZCBkZXNjcmVhc2VcbiAgICAgKiB0aGUgZmlsZSBkZXNjcmlwdG9yIG9mIGV2ZXJ5IG5ldyBvcGVuZWQgZmlsZS5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEB0b2RvIFRoaXMgc2hvdWxkIG5vdCBiZSBzdGF0aWMsIHJpZ2h0P1xuICAgICAqL1xuICAgIFZvbHVtZS5mZCA9IDB4N2ZmZmZmZmY7XG4gICAgcmV0dXJuIFZvbHVtZTtcbn0oKSk7XG5leHBvcnRzLlZvbHVtZSA9IFZvbHVtZTtcbmZ1bmN0aW9uIGVtaXRTdG9wKHNlbGYpIHtcbiAgICBzZWxmLmVtaXQoJ3N0b3AnKTtcbn1cbnZhciBTdGF0V2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3RhdFdhdGNoZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdFdhdGNoZXIodm9sKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnZvbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICAgICAgICBfdGhpcy5wcmV2ID0gbnVsbDtcbiAgICAgICAgX3RoaXMub25JbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRzID0gX3RoaXMudm9sLnN0YXRTeW5jKF90aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaGFzQ2hhbmdlZChzdGF0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2hhbmdlJywgc3RhdHMsIF90aGlzLnByZXYpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ID0gc3RhdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9vcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy52b2wgPSB2b2w7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3RhdFdhdGNoZXIucHJvdG90eXBlLmxvb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGltZW91dFJlZiA9IHRoaXMuc2V0VGltZW91dCh0aGlzLm9uSW50ZXJ2YWwsIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgU3RhdFdhdGNoZXIucHJvdG90eXBlLmhhc0NoYW5nZWQgPSBmdW5jdGlvbiAoc3RhdHMpIHtcbiAgICAgICAgLy8gaWYoIXRoaXMucHJldikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoc3RhdHMubXRpbWVNcyA+IHRoaXMucHJldi5tdGltZU1zKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChzdGF0cy5ubGluayAhPT0gdGhpcy5wcmV2Lm5saW5rKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFN0YXRXYXRjaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChwYXRoLCBwZXJzaXN0ZW50LCBpbnRlcnZhbCkge1xuICAgICAgICBpZiAocGVyc2lzdGVudCA9PT0gdm9pZCAwKSB7IHBlcnNpc3RlbnQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChpbnRlcnZhbCA9PT0gdm9pZCAwKSB7IGludGVydmFsID0gNTAwNzsgfVxuICAgICAgICB0aGlzLmZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHRoaXMuc2V0VGltZW91dCA9IHBlcnNpc3RlbnQgPyBzZXRUaW1lb3V0IDogc2V0VGltZW91dFVucmVmXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLnByZXYgPSB0aGlzLnZvbC5zdGF0U3luYyh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5sb29wKCk7XG4gICAgfTtcbiAgICBTdGF0V2F0Y2hlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gICAgICAgIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKGVtaXRTdG9wLCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0V2F0Y2hlcjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlN0YXRXYXRjaGVyID0gU3RhdFdhdGNoZXI7XG52YXIgcG9vbDtcbmZ1bmN0aW9uIGFsbG9jTmV3UG9vbChwb29sU2l6ZSkge1xuICAgIHBvb2wgPSBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZShwb29sU2l6ZSk7XG4gICAgcG9vbC51c2VkID0gMDtcbn1cbnV0aWwuaW5oZXJpdHMoRnNSZWFkU3RyZWFtLCBzdHJlYW1fMS5SZWFkYWJsZSk7XG5leHBvcnRzLlJlYWRTdHJlYW0gPSBGc1JlYWRTdHJlYW07XG5mdW5jdGlvbiBGc1JlYWRTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZzUmVhZFN0cmVhbSkpXG4gICAgICAgIHJldHVybiBuZXcgRnNSZWFkU3RyZWFtKHZvbCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fdm9sID0gdm9sO1xuICAgIC8vIGEgbGl0dGxlIGJpdCBiaWdnZXIgYnVmZmVyIGFuZCB3YXRlciBtYXJrcyBieSBkZWZhdWx0XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZ2V0T3B0aW9ucyhvcHRpb25zLCB7fSkpO1xuICAgIGlmIChvcHRpb25zLmhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5oaWdoV2F0ZXJNYXJrID0gNjQgKiAxMDI0O1xuICAgIHN0cmVhbV8xLlJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgdGhpcy5mZCA9IG9wdGlvbnMuZmQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmZkO1xuICAgIHRoaXMuZmxhZ3MgPSBvcHRpb25zLmZsYWdzID09PSB1bmRlZmluZWQgPyAncicgOiBvcHRpb25zLmZsYWdzO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkID8gNDM4IDogb3B0aW9ucy5tb2RlO1xuICAgIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gb3B0aW9ucy5lbmQ7XG4gICAgdGhpcy5hdXRvQ2xvc2UgPSBvcHRpb25zLmF1dG9DbG9zZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYXV0b0Nsb3NlO1xuICAgIHRoaXMucG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZXNSZWFkID0gMDtcbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmVuZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5kXCIgb3B0aW9uIG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFydCA+IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSA8PSBcImVuZFwiIG9wdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgdGhpcy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgICBzZWxmLmVtaXQoJ29wZW4nLCBmZCk7XG4gICAgICAgIC8vIHN0YXJ0IHRoZSBmbG93IG9mIGRhdGEuXG4gICAgICAgIHNlbGYucmVhZCgpO1xuICAgIH0pO1xufTtcbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWQobik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCBrTWluUG9vbFNwYWNlKSB7XG4gICAgICAgIC8vIGRpc2NhcmQgdGhlIG9sZCBwb29sLlxuICAgICAgICBhbGxvY05ld1Bvb2wodGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICB9XG4gICAgLy8gR3JhYiBhbm90aGVyIHJlZmVyZW5jZSB0byB0aGUgcG9vbCBpbiB0aGUgY2FzZSB0aGF0IHdoaWxlIHdlJ3JlXG4gICAgLy8gaW4gdGhlIHRocmVhZCBwb29sIGFub3RoZXIgcmVhZCgpIGZpbmlzaGVzIHVwIHRoZSBwb29sLCBhbmRcbiAgICAvLyBhbGxvY2F0ZXMgYSBuZXcgb25lLlxuICAgIHZhciB0aGlzUG9vbCA9IHBvb2w7XG4gICAgdmFyIHRvUmVhZCA9IE1hdGgubWluKHBvb2wubGVuZ3RoIC0gcG9vbC51c2VkLCBuKTtcbiAgICB2YXIgc3RhcnQgPSBwb29sLnVzZWQ7XG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRvUmVhZCA9IE1hdGgubWluKHRoaXMuZW5kIC0gdGhpcy5wb3MgKyAxLCB0b1JlYWQpO1xuICAgIC8vIGFscmVhZHkgcmVhZCBldmVyeXRoaW5nIHdlIHdlcmUgc3VwcG9zZWQgdG8gcmVhZCFcbiAgICAvLyB0cmVhdCBhcyBFT0YuXG4gICAgaWYgKHRvUmVhZCA8PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpO1xuICAgIC8vIHRoZSBhY3R1YWwgcmVhZC5cbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLnJlYWQodGhpcy5mZCwgcG9vbCwgcG9vbC51c2VkLCB0b1JlYWQsIHRoaXMucG9zLCBvbnJlYWQpO1xuICAgIC8vIG1vdmUgdGhlIHBvb2wgcG9zaXRpb25zLCBhbmQgaW50ZXJuYWwgcG9zaXRpb24gZm9yIHJlYWRpbmcuXG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMucG9zICs9IHRvUmVhZDtcbiAgICBwb29sLnVzZWQgKz0gdG9SZWFkO1xuICAgIGZ1bmN0aW9uIG9ucmVhZChlciwgYnl0ZXNSZWFkKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHNlbGYuYXV0b0Nsb3NlICYmIHNlbGYuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5ieXRlc1JlYWQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzUG9vbC5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlc1JlYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICAgIHRoaXMuY2xvc2UoZnVuY3Rpb24gKGVycjIpIHtcbiAgICAgICAgY2IoZXJyIHx8IGVycjIpO1xuICAgIH0pO1xufTtcbkZzUmVhZFN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChjYilcbiAgICAgICAgdGhpcy5vbmNlKCdjbG9zZScsIGNiKTtcbiAgICBpZiAodGhpcy5jbG9zZWQgfHwgdHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlT25PcGVuKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzc18xLmRlZmF1bHQubmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZW1pdCgnY2xvc2UnKTsgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl92b2wuY2xvc2UodGhpcy5mZCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmIChlcilcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIHRoaXMuZmQgPSBudWxsO1xufTtcbi8vIG5lZWRlZCBiZWNhdXNlIGFzIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYXJndW1lbnRzXG4vLyB0aGF0IGRvZXMgbm90IG1hdGNoIHRoaXMuY2xvc2UoKSBzaWduYXR1cmVcbmZ1bmN0aW9uIGNsb3NlT25PcGVuKGZkKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xufVxudXRpbC5pbmhlcml0cyhGc1dyaXRlU3RyZWFtLCBzdHJlYW1fMS5Xcml0YWJsZSk7XG5leHBvcnRzLldyaXRlU3RyZWFtID0gRnNXcml0ZVN0cmVhbTtcbmZ1bmN0aW9uIEZzV3JpdGVTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZzV3JpdGVTdHJlYW0pKVxuICAgICAgICByZXR1cm4gbmV3IEZzV3JpdGVTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKTtcbiAgICB0aGlzLl92b2wgPSB2b2w7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgZ2V0T3B0aW9ucyhvcHRpb25zLCB7fSkpO1xuICAgIHN0cmVhbV8xLldyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgdGhpcy5mZCA9IG9wdGlvbnMuZmQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmZkO1xuICAgIHRoaXMuZmxhZ3MgPSBvcHRpb25zLmZsYWdzID09PSB1bmRlZmluZWQgPyAndycgOiBvcHRpb25zLmZsYWdzO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkID8gNDM4IDogb3B0aW9ucy5tb2RlO1xuICAgIHRoaXMuc3RhcnQgPSBvcHRpb25zLnN0YXJ0O1xuICAgIHRoaXMuYXV0b0Nsb3NlID0gb3B0aW9ucy5hdXRvQ2xvc2UgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuYXV0b0Nsb3NlO1xuICAgIHRoaXMucG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic3RhcnRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInN0YXJ0XCIgbXVzdCBiZSA+PSB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZylcbiAgICAgICAgdGhpcy5zZXREZWZhdWx0RW5jb2Rpbmcob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgLy8gZGlzcG9zZSBvbiBmaW5pc2guXG4gICAgdGhpcy5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3ZvbC5vcGVuKHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCBmdW5jdGlvbiAoZXIsIGZkKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlICYmIHRoaXMuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgYnVmZmVyXzEuQnVmZmVyKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YScpKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZShkYXRhLCBlbmNvZGluZywgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXRoaXMtYXNzaWdubWVudFxuICAgIHRoaXMuX3ZvbC53cml0ZSh0aGlzLmZkLCBkYXRhLCAwLCBkYXRhLmxlbmd0aCwgdGhpcy5wb3MsIGZ1bmN0aW9uIChlciwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UgJiYgc2VsZi5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBjYigpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnBvcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnBvcyArPSBkYXRhLmxlbmd0aDtcbn07XG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5fd3JpdGV2ID0gZnVuY3Rpb24gKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGV2KGRhdGEsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGNodW5rcyA9IG5ldyBBcnJheShsZW4pO1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaHVuayA9IGRhdGFbaV0uY2h1bms7XG4gICAgICAgIGNodW5rc1tpXSA9IGNodW5rO1xuICAgICAgICBzaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICB0aGlzLl92b2wud3JpdGUodGhpcy5mZCwgYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzLnBvcywgZnVuY3Rpb24gKGVyLCBieXRlcykge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuYnl0ZXNXcml0dGVuICs9IGJ5dGVzO1xuICAgICAgICBjYigpO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnBvcyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLnBvcyArPSBzaXplO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95ID0gRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLmNsb3NlID0gRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5jbG9zZTtcbi8vIFRoZXJlIGlzIG5vIHNodXRkb3duKCkgZm9yIGZpbGVzLlxuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuZGVzdHJveVNvb24gPSBGc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5lbmQ7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZTV2F0Y2hlclxudmFyIEZTV2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRlNXYXRjaGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZTV2F0Y2hlcih2b2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuX2ZpbGVuYW1lID0gJyc7XG4gICAgICAgIF90aGlzLl9zdGVwcyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9maWxlbmFtZUVuY29kZWQgPSAnJztcbiAgICAgICAgLy8gX3BlcnNpc3RlbnQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAgICBfdGhpcy5fcmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGODtcbiAgICAgICAgX3RoaXMuX2xpbmsgPSBudWxsO1xuICAgICAgICBfdGhpcy5fb25Ob2RlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2VtaXQoJ2NoYW5nZScpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fb25QYXJlbnRDaGlsZCA9IGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICBpZiAobGluay5nZXROYW1lKCkgPT09IF90aGlzLl9nZXROYW1lKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdCgncmVuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NoYW5nZScsIHR5cGUsIF90aGlzLl9maWxlbmFtZUVuY29kZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fcGVyc2lzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl90aW1lciA9IHNldFRpbWVvdXQoX3RoaXMuX3BlcnNpc3QsIDFlNik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl92b2wgPSB2b2w7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgLy8gVE9ETzogRW1pdCBcImVycm9yXCIgbWVzc2FnZXMgd2hlbiB3YXRjaGluZy5cbiAgICAgICAgLy8gdGhpcy5faGFuZGxlLm9uY2hhbmdlID0gZnVuY3Rpb24oc3RhdHVzLCBldmVudFR5cGUsIGZpbGVuYW1lKSB7XG4gICAgICAgIC8vICAgICBpZiAoc3RhdHVzIDwgMCkge1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuX2hhbmRsZS5jbG9zZSgpO1xuICAgICAgICAvLyAgICAgICAgIGNvbnN0IGVycm9yID0gIWZpbGVuYW1lID9cbiAgICAgICAgLy8gICAgICAgICAgICAgZXJybm9FeGNlcHRpb24oc3RhdHVzLCAnRXJyb3Igd2F0Y2hpbmcgZmlsZSBmb3IgY2hhbmdlczonKSA6XG4gICAgICAgIC8vICAgICAgICAgICAgIGVycm5vRXhjZXB0aW9uKHN0YXR1cywgYEVycm9yIHdhdGNoaW5nIGZpbGUgJHtmaWxlbmFtZX0gZm9yIGNoYW5nZXM6YCk7XG4gICAgICAgIC8vICAgICAgICAgZXJyb3IuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLmVtaXQoJ2NoYW5nZScsIGV2ZW50VHlwZSwgZmlsZW5hbWUpO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9O1xuICAgIH1cbiAgICBGU1dhdGNoZXIucHJvdG90eXBlLl9nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcHNbdGhpcy5fc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgfTtcbiAgICBGU1dhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhdGgsIHBlcnNpc3RlbnQsIHJlY3Vyc2l2ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHBlcnNpc3RlbnQgPT09IHZvaWQgMCkgeyBwZXJzaXN0ZW50ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAocmVjdXJzaXZlID09PSB2b2lkIDApIHsgcmVjdXJzaXZlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSBlbmNvZGluZ18xLkVOQ09ESU5HX1VURjg7IH1cbiAgICAgICAgdGhpcy5fZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5fc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHModGhpcy5fZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLl9maWxlbmFtZUVuY29kZWQgPSBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcodGhpcy5fZmlsZW5hbWUpO1xuICAgICAgICAvLyB0aGlzLl9wZXJzaXN0ZW50ID0gcGVyc2lzdGVudDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlID0gcmVjdXJzaXZlO1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fbGluayA9IHRoaXMuX3ZvbC5nZXRMaW5rT3JUaHJvdyh0aGlzLl9maWxlbmFtZSwgJ0ZTV2F0Y2hlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIndhdGNoIFwiICsgdGhpcy5fZmlsZW5hbWUgKyBcIiBcIiArIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGVycm9yLmNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgIGVycm9yLmVycm5vID0gZXJyLmNvZGU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5rLmdldE5vZGUoKS5vbignY2hhbmdlJywgdGhpcy5fb25Ob2RlQ2hhbmdlKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX2xpbmsucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAvLyBwYXJlbnQub24oJ2NoaWxkOmFkZCcsIHRoaXMuX29uUGFyZW50Q2hpbGQpO1xuICAgICAgICAgICAgcGFyZW50Lm9uKCdjaGlsZDpkZWxldGUnLCB0aGlzLl9vblBhcmVudENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyc2lzdGVudClcbiAgICAgICAgICAgIHRoaXMuX3BlcnNpc3QoKTtcbiAgICB9O1xuICAgIEZTV2F0Y2hlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX2xpbmsuZ2V0Tm9kZSgpLnJlbW92ZUxpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbk5vZGVDaGFuZ2UpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5yZW1vdmVMaXN0ZW5lcignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlTGlzdGVuZXIoJ2NoaWxkOmRlbGV0ZScsIHRoaXMuX29uUGFyZW50Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRlNXYXRjaGVyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuRlNXYXRjaGVyID0gRlNXYXRjaGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi92b2x1bWUuanMiLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJvY2Vzc18xID0gcmVxdWlyZShcIi4vcHJvY2Vzc1wiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2J1ZmZlclwiKTtcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgU3RhdHNfMSA9IHJlcXVpcmUoXCIuL1N0YXRzXCIpO1xudmFyIFNfSUZNVCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGTVQsIFNfSUZESVIgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkRJUiwgU19JRlJFRyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGUkVHLCBTX0lGQkxLID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZCTEssIFNfSUZDSFIgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkNIUiwgU19JRkxOSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGTE5LLCBTX0lGSUZPID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZJRk8sIFNfSUZTT0NLID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZTT0NLLCBPX0FQUEVORCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5PX0FQUEVORDtcbmV4cG9ydHMuU0VQID0gJy8nO1xuLyoqXG4gKiBOb2RlIGluIGEgZmlsZSBzeXN0ZW0gKGxpa2UgaS1ub2RlLCB2LW5vZGUpLlxuICovXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb2RlKGlubywgcGVybSkge1xuICAgICAgICBpZiAocGVybSA9PT0gdm9pZCAwKSB7IHBlcm0gPSA0Mzg7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLy8gVXNlciBJRCBhbmQgZ3JvdXAgSUQuXG4gICAgICAgIF90aGlzLnVpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldHVpZCgpO1xuICAgICAgICBfdGhpcy5naWQgPSBwcm9jZXNzXzEuZGVmYXVsdC5nZXRnaWQoKTtcbiAgICAgICAgX3RoaXMuYXRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBfdGhpcy5tdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIF90aGlzLmN0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gZGF0YTogc3RyaW5nID0gJyc7XG4gICAgICAgIF90aGlzLmJ1ZiA9IG51bGw7XG4gICAgICAgIF90aGlzLnBlcm0gPSA0Mzg7IC8vIFBlcm1pc3Npb25zIGBjaG1vZGAsIGBmY2htb2RgXG4gICAgICAgIF90aGlzLm1vZGUgPSBTX0lGUkVHOyAvLyBTX0lGRElSLCBTX0lGUkVHLCBldGMuLiAoZmlsZSBieSBkZWZhdWx0PylcbiAgICAgICAgLy8gTnVtYmVyIG9mIGhhcmQgbGlua3MgcG9pbnRpbmcgYXQgdGhpcyBOb2RlLlxuICAgICAgICBfdGhpcy5ubGluayA9IDE7XG4gICAgICAgIC8vIFN0ZXBzIHRvIGFub3RoZXIgbm9kZSwgaWYgdGhpcyBub2RlIGlzIGEgc3ltbGluay5cbiAgICAgICAgX3RoaXMuc3ltbGluayA9IG51bGw7XG4gICAgICAgIF90aGlzLnBlcm0gPSBwZXJtO1xuICAgICAgICBfdGhpcy5tb2RlIHw9IHBlcm07XG4gICAgICAgIF90aGlzLmlubyA9IGlubztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBOb2RlLnByb3RvdHlwZS5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSAndXRmOCc7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCkudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuc2V0U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyB0aGlzLnNldEJ1ZmZlcihidWZmZXJGcm9tKHN0ciwgJ3V0ZjgnKSk7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyRnJvbShzdHIsICd1dGY4Jyk7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKDApKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLmJ1ZmZlckZyb20odGhpcy5idWYpOyAvLyBSZXR1cm4gYSBjb3B5LlxuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuc2V0QnVmZmVyID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcl8xLmJ1ZmZlckZyb20oYnVmKTsgLy8gQ3JlYXRlcyBhIGNvcHkgb2YgZGF0YS5cbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmID8gdGhpcy5idWYubGVuZ3RoIDogMDtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnNldE1vZGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB0aGlzLm1vZGUgPSAodGhpcy5tb2RlICYgflNfSUZNVCkgfCBwcm9wZXJ0eTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnNldElzRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRNb2RlUHJvcGVydHkoU19JRlJFRyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRJc0RpcmVjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRNb2RlUHJvcGVydHkoU19JRkRJUik7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRJc1N5bWxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0TW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIFNfSUZNVCkgPT09IFNfSUZSRUc7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pc0RpcmVjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGRElSO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaXNTeW1saW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyByZXR1cm4gISF0aGlzLnN5bWxpbms7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gU19JRkxOSztcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLm1ha2VTeW1saW5rID0gZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICAgIHRoaXMuc3ltbGluayA9IHN0ZXBzO1xuICAgICAgICB0aGlzLnNldElzU3ltbGluaygpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmLCBvZmYsIGxlbiwgcG9zKSB7XG4gICAgICAgIGlmIChvZmYgPT09IHZvaWQgMCkgeyBvZmYgPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSBidWYubGVuZ3RoOyB9XG4gICAgICAgIGlmIChwb3MgPT09IHZvaWQgMCkgeyBwb3MgPSAwOyB9XG4gICAgICAgIGlmICghdGhpcy5idWYpXG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAocG9zICsgbGVuID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV3QnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUocG9zICsgbGVuKTtcbiAgICAgICAgICAgIHRoaXMuYnVmLmNvcHkobmV3QnVmLCAwLCAwLCB0aGlzLmJ1Zi5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5idWYgPSBuZXdCdWY7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLmNvcHkodGhpcy5idWYsIHBvcywgb2ZmLCBvZmYgKyBsZW4pO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgcmVhZC5cbiAgICBOb2RlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGJ1Ziwgb2ZmLCBsZW4sIHBvcykge1xuICAgICAgICBpZiAob2ZmID09PSB2b2lkIDApIHsgb2ZmID0gMDsgfVxuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gYnVmLmJ5dGVMZW5ndGg7IH1cbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9IDA7IH1cbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIHZhciBhY3R1YWxMZW4gPSBsZW47XG4gICAgICAgIGlmIChhY3R1YWxMZW4gPiBidWYuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgYWN0dWFsTGVuID0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdHVhbExlbiArIHBvcyA+IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0dWFsTGVuID0gdGhpcy5idWYubGVuZ3RoIC0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmLmNvcHkoYnVmLCBvZmYsIHBvcywgcG9zICsgYWN0dWFsTGVuKTtcbiAgICAgICAgcmV0dXJuIGFjdHVhbExlbjtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gMDsgfVxuICAgICAgICBpZiAoIWxlbilcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgaWYgKGxlbiA8PSB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZiA9IHRoaXMuYnVmLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWYuY29weShidWYpO1xuICAgICAgICAgICAgICAgIGJ1Zi5maWxsKDAsIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuY2htb2QgPSBmdW5jdGlvbiAocGVybSkge1xuICAgICAgICB0aGlzLnBlcm0gPSBwZXJtO1xuICAgICAgICB0aGlzLm1vZGUgPSAodGhpcy5tb2RlICYgfjUxMSkgfCBwZXJtO1xuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5jaG93biA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcbiAgICAgICAgdGhpcy5naWQgPSBnaWQ7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm10aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB0aGlzKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmNhblJlYWQgPSBmdW5jdGlvbiAodWlkLCBnaWQpIHtcbiAgICAgICAgaWYgKHVpZCA9PT0gdm9pZCAwKSB7IHVpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldHVpZCgpOyB9XG4gICAgICAgIGlmIChnaWQgPT09IHZvaWQgMCkgeyBnaWQgPSBwcm9jZXNzXzEuZGVmYXVsdC5nZXRnaWQoKTsgfVxuICAgICAgICBpZiAodGhpcy5wZXJtICYgNCAvKiBJUk9USCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdGhpcy5naWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAzMiAvKiBJUkdSUCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZXJtICYgMjU2IC8qIElSVVNSICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuY2FuV3JpdGUgPSBmdW5jdGlvbiAodWlkLCBnaWQpIHtcbiAgICAgICAgaWYgKHVpZCA9PT0gdm9pZCAwKSB7IHVpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldHVpZCgpOyB9XG4gICAgICAgIGlmIChnaWQgPT09IHZvaWQgMCkgeyBnaWQgPSBwcm9jZXNzXzEuZGVmYXVsdC5nZXRnaWQoKTsgfVxuICAgICAgICBpZiAodGhpcy5wZXJtICYgMiAvKiBJV09USCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdGhpcy5naWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxNiAvKiBJV0dSUCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1aWQgPT09IHRoaXMudWlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZXJtICYgMTI4IC8qIElXVVNSICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlbGV0ZScsIHRoaXMpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5vOiB0aGlzLmlubyxcbiAgICAgICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgICAgICBnaWQ6IHRoaXMuZ2lkLFxuICAgICAgICAgICAgYXRpbWU6IHRoaXMuYXRpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbXRpbWU6IHRoaXMubXRpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgY3RpbWU6IHRoaXMuY3RpbWUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgcGVybTogdGhpcy5wZXJtLFxuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgbmxpbms6IHRoaXMubmxpbmssXG4gICAgICAgICAgICBzeW1saW5rOiB0aGlzLnN5bWxpbmssXG4gICAgICAgICAgICBkYXRhOiB0aGlzLmdldFN0cmluZygpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE5vZGU7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGhhcmQgbGluayB0aGF0IHBvaW50cyB0byBhbiBpLW5vZGUgYG5vZGVgLlxuICovXG52YXIgTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGluaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rKHZvbCwgcGFyZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLmNoaWxkcmVuID0ge307XG4gICAgICAgIC8vIFBhdGggdG8gdGhpcyBub2RlIGFzIEFycmF5OiBbJ3VzcicsICdiaW4nLCAnbm9kZSddLlxuICAgICAgICBfdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICAvLyBcImktbm9kZVwiIG9mIHRoaXMgaGFyZCBsaW5rLlxuICAgICAgICBfdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgLy8gXCJpLW5vZGVcIiBudW1iZXIgb2YgdGhlIG5vZGUuXG4gICAgICAgIF90aGlzLmlubyA9IDA7XG4gICAgICAgIC8vIE51bWJlciBvZiBjaGlsZHJlbi5cbiAgICAgICAgX3RoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgX3RoaXMudm9sID0gdm9sO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLnN0ZXBzID0gcGFyZW50ID8gcGFyZW50LnN0ZXBzLmNvbmNhdChbbmFtZV0pIDogW25hbWVdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmsucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmlubyA9IG5vZGUuaW5vO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLmNyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKG5hbWUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMCkgeyBub2RlID0gdGhpcy52b2wuY3JlYXRlTm9kZSgpOyB9XG4gICAgICAgIHZhciBsaW5rID0gbmV3IExpbmsodGhpcy52b2wsIHRoaXMsIG5hbWUpO1xuICAgICAgICBsaW5rLnNldE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIC8vIGxpbmsuc2V0Q2hpbGQoJy4nLCBsaW5rKTtcbiAgICAgICAgICAgIC8vIGxpbmsuZ2V0Tm9kZSgpLm5saW5rKys7XG4gICAgICAgICAgICAvLyBsaW5rLnNldENoaWxkKCcuLicsIHRoaXMpO1xuICAgICAgICAgICAgLy8gdGhpcy5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldENoaWxkKG5hbWUsIGxpbmspO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLnNldENoaWxkID0gZnVuY3Rpb24gKG5hbWUsIGxpbmspIHtcbiAgICAgICAgaWYgKGxpbmsgPT09IHZvaWQgMCkgeyBsaW5rID0gbmV3IExpbmsodGhpcy52b2wsIHRoaXMsIG5hbWUpOyB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bbmFtZV0gPSBsaW5rO1xuICAgICAgICBsaW5rLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hpbGQ6YWRkJywgbGluaywgdGhpcyk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuZGVsZXRlQ2hpbGQgPSBmdW5jdGlvbiAobGluaykge1xuICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlbltsaW5rLmdldE5hbWUoKV07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIHRoaXMuZW1pdCgnY2hpbGQ6ZGVsZXRlJywgbGluaywgdGhpcyk7XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNoaWxkcmVuLCBuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmpvaW4oZXhwb3J0cy5TRVApO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHNbdGhpcy5zdGVwcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIC8vIGRlbCgpIHtcbiAgICAvLyAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgLy8gICAgIGlmKHBhcmVudCkge1xuICAgIC8vICAgICAgICAgcGFyZW50LmRlbGV0ZUNoaWxkKGxpbmspO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAvLyAgICAgdGhpcy52b2wgPSBudWxsO1xuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBXYWxrIHRoZSB0cmVlIHBhdGggYW5kIHJldHVybiB0aGUgYExpbmtgIGF0IHRoYXQgbG9jYXRpb24sIGlmIGFueS5cbiAgICAgKiBAcGFyYW0gc3RlcHMge3N0cmluZ1tdfSBEZXNpcmVkIGxvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBzdG9wIHtudW1iZXJ9IE1heCBzdGVwcyB0byBnbyBpbnRvLlxuICAgICAqIEBwYXJhbSBpIHtudW1iZXJ9IEN1cnJlbnQgc3RlcCBpbiB0aGUgYHN0ZXBzYCBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIExpbmsucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAoc3RlcHMsIHN0b3AsIGkpIHtcbiAgICAgICAgaWYgKHN0b3AgPT09IHZvaWQgMCkgeyBzdG9wID0gc3RlcHMubGVuZ3RoOyB9XG4gICAgICAgIGlmIChpID09PSB2b2lkIDApIHsgaSA9IDA7IH1cbiAgICAgICAgaWYgKGkgPj0gc3RlcHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChpID49IHN0b3ApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tpXTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldENoaWxkKHN0ZXApO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxpbmsud2FsayhzdGVwcywgc3RvcCwgaSArIDEpO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RlcHM6IHRoaXMuc3RlcHMsXG4gICAgICAgICAgICBpbm86IHRoaXMuaW5vLFxuICAgICAgICAgICAgY2hpbGRyZW46IE9iamVjdC5rZXlzKHRoaXMuY2hpbGRyZW4pLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIExpbms7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5MaW5rID0gTGluaztcbi8qKlxuICogUmVwcmVzZW50cyBhbiBvcGVuIGZpbGUgKGZpbGUgZGVzY3JpcHRvcikgdGhhdCBwb2ludHMgdG8gYSBgTGlua2AgKEhhcmQtbGluaykgYW5kIGEgYE5vZGVgLlxuICovXG52YXIgRmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBPcGVuIGEgTGluay1Ob2RlIHBhaXIuIGBub2RlYCBpcyBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHRoYXQgbWlnaHQgYmUgYSBkaWZmZXJlbnQgbm9kZVxuICAgICAqIHJhdGhlciB0aGUgb25lIGBsaW5rYCBwb2ludHMgdG8sIGJlY2F1c2UgaXQgbWlnaHQgYmUgYSBzeW1saW5rLlxuICAgICAqIEBwYXJhbSBsaW5rXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKiBAcGFyYW0gZmxhZ3NcbiAgICAgKiBAcGFyYW0gZmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBGaWxlKGxpbmssIG5vZGUsIGZsYWdzLCBmZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFyZCBsaW5rIHRoYXQgdGhpcyBmaWxlIG9wZW5lZC5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluayA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gYSBgTm9kZWAuXG4gICAgICAgICAqIEB0eXBlIHtOb2RlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY3Vyc29yL29mZnNldCBwb3NpdGlvbiBpbiBhIGZpbGUsIHdoZXJlIGRhdGEgd2lsbCBiZSB3cml0dGVuIG9uIHdyaXRlLlxuICAgICAgICAgKiBVc2VyIGNhbiBcInNlZWtcIiB0aGlzIHBvc2l0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGluayA9IGxpbms7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5mZCA9IGZkO1xuICAgIH1cbiAgICBGaWxlLnByb3RvdHlwZS5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSAndXRmOCc7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRTdHJpbmcoKTtcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLnNldFN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNldFN0cmluZyhzdHIpO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldEJ1ZmZlcigpO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuc2V0QnVmZmVyID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QnVmZmVyKGJ1Zik7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFNpemUoKTtcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICB0aGlzLm5vZGUudHJ1bmNhdGUobGVuKTtcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLnNlZWtUbyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5zdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFN0YXRzXzEuZGVmYXVsdC5idWlsZCh0aGlzLm5vZGUpO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IDA7IH1cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gdm9pZCAwKSB7IGxlbmd0aCA9IGJ1Zi5sZW5ndGg7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmZsYWdzICYgT19BUFBFTkQpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLm5vZGUud3JpdGUoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gKyBieXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gYnVmLmJ5dGVMZW5ndGg7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMubm9kZS5yZWFkKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uICsgYnl0ZXM7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLmNobW9kID0gZnVuY3Rpb24gKHBlcm0pIHtcbiAgICAgICAgdGhpcy5ub2RlLmNobW9kKHBlcm0pO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuY2hvd24gPSBmdW5jdGlvbiAodWlkLCBnaWQpIHtcbiAgICAgICAgdGhpcy5ub2RlLmNob3duKHVpZCwgZ2lkKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWxlO1xufSgpKTtcbmV4cG9ydHMuRmlsZSA9IEZpbGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL25vZGUuanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBgc2V0VGltZW91dFVucmVmYCBpcyBqdXN0IGxpa2UgYHNldFRpbWVvdXRgLFxuICogb25seSBpbiBOb2RlJ3MgZW52aXJvbm1lbnQgaXQgd2lsbCBcInVucmVmXCIgaXRzIG1hY3JvIHRhc2suXG4gKi9cbmZ1bmN0aW9uIHNldFRpbWVvdXRVbnJlZihjYWxsYmFjaywgdGltZSwgYXJncykge1xuICAgIHZhciByZWYgPSBzZXRUaW1lb3V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHJlZiAmJiB0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVmLnVucmVmID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZWYudW5yZWYoKTtcbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2V0VGltZW91dFVucmVmO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9zZXRUaW1lb3V0VW5yZWYuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyB1dGlsIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwiXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvcih2YXIga2V5IGluIGIpIGFba2V5XSA9IGJba2V5XTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgM1xuICAgICAgICA/IGFcbiAgICAgICAgOiBleHRlbmQuYXBwbHkobnVsbCwgW2FdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmFzdC1leHRlbmQvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcHJvbWlzaWZ5KHZvbCwgZm4sIGdldFJlc3VsdCkge1xuICAgIGlmIChnZXRSZXN1bHQgPT09IHZvaWQgMCkgeyBnZXRSZXN1bHQgPSBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0OyB9OyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdm9sW2ZuXS5iaW5kKHZvbCkuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5cyhhcmdzLCBbZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldFJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxudmFyIEZpbGVIYW5kbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsZUhhbmRsZSh2b2wsIGZkKSB7XG4gICAgICAgIHRoaXMudm9sID0gdm9sO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgfVxuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLmFwcGVuZEZpbGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnYXBwZW5kRmlsZScpKHRoaXMuZmQsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuY2htb2QgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZmNobW9kJykodGhpcy5mZCwgbW9kZSk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5jaG93biA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZmNob3duJykodGhpcy5mZCwgdWlkLCBnaWQpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsICdjbG9zZScpKHRoaXMuZmQpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuZGF0YXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsICdmZGF0YXN5bmMnKSh0aGlzLmZkKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3JlYWQnLCBmdW5jdGlvbiAoYnl0ZXNSZWFkKSB7IHJldHVybiAoeyBieXRlc1JlYWQ6IGJ5dGVzUmVhZCwgYnVmZmVyOiBidWZmZXIgfSk7IH0pKHRoaXMuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnJlYWRGaWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3JlYWRGaWxlJykodGhpcy5mZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ2ZzdGF0JykodGhpcy5mZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZnN5bmMnKSh0aGlzLmZkKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZnRydW5jYXRlJykodGhpcy5mZCwgbGVuKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnV0aW1lcyA9IGZ1bmN0aW9uIChhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ2Z1dGltZXMnKSh0aGlzLmZkLCBhdGltZSwgbXRpbWUpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3dyaXRlJywgZnVuY3Rpb24gKGJ5dGVzV3JpdHRlbikgeyByZXR1cm4gKHsgYnl0ZXNXcml0dGVuOiBieXRlc1dyaXR0ZW4sIGJ1ZmZlcjogYnVmZmVyIH0pOyB9KSh0aGlzLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS53cml0ZUZpbGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnd3JpdGVGaWxlJykodGhpcy5mZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZUhhbmRsZTtcbn0oKSk7XG5leHBvcnRzLkZpbGVIYW5kbGUgPSBGaWxlSGFuZGxlO1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZXNBcGkodm9sKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgRmlsZUhhbmRsZTogRmlsZUhhbmRsZSxcbiAgICAgICAgYWNjZXNzOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdhY2Nlc3MnKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kRmlsZTogZnVuY3Rpb24gKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnYXBwZW5kRmlsZScpKHBhdGggaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gcGF0aC5mZCA6IHBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnY2htb2QnKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hvd246IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdjaG93bicpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29weUZpbGU6IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2NvcHlGaWxlJykoc3JjLCBkZXN0LCBmbGFncyk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnbGNobW9kJykocGF0aCwgbW9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG93bjogZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2xjaG93bicpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24gKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdsaW5rJykoZXhpc3RpbmdQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbHN0YXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2xzdGF0JykocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1rZGlyOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdta2RpcicpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBta2R0ZW1wOiBmdW5jdGlvbiAocHJlZml4LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ21rZHRlbXAnKShwcmVmaXgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbiAocGF0aCwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnb3BlbicsIGZ1bmN0aW9uIChmZCkgeyByZXR1cm4gbmV3IEZpbGVIYW5kbGUodm9sLCBmZCk7IH0pKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAncmVhZGRpcicpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkRmlsZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3JlYWRGaWxlJykoaWQgaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gaWQuZmQgOiBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRsaW5rOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdyZWFkbGluaycpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFscGF0aDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAncmVhbHBhdGgnKShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdyZW5hbWUnKShvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3JtZGlyJykocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3N0YXQnKShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHRhcmdldCwgcGF0aCwgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdzeW1saW5rJykodGFyZ2V0LCBwYXRoLCB0eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1bmNhdGU6IGZ1bmN0aW9uIChwYXRoLCBsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAndHJ1bmNhdGUnKShwYXRoLCBsZW4pO1xuICAgICAgICB9LFxuICAgICAgICB1bmxpbms6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3VubGluaycpKHBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICB1dGltZXM6IGZ1bmN0aW9uIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAndXRpbWVzJykocGF0aCwgYXRpbWUsIG10aW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVGaWxlOiBmdW5jdGlvbiAoaWQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnd3JpdGVGaWxlJykoaWQgaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gaWQuZmQgOiBpZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVByb21pc2VzQXBpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9wcm9taXNlcy5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy51bml4aWZ5ID0gdW5peGlmeTtcbmV4cG9ydHMuY29ycmVjdFBhdGggPSBjb3JyZWN0UGF0aDtcbnZhciBpc1dpbiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHN0cikge1xuICB2YXIgaSA9IHN0ci5sZW5ndGggLSAxO1xuICBpZiAoaSA8IDIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHdoaWxlIChpc1NlcGFyYXRvcihzdHIsIGkpKSB7XG4gICAgaS0tO1xuICB9XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGkgKyAxKTtcbn1cblxuZnVuY3Rpb24gaXNTZXBhcmF0b3Ioc3RyLCBpKSB7XG4gIHZhciBjaGFyID0gc3RyW2ldO1xuICByZXR1cm4gaSA+IDAgJiYgKGNoYXIgPT09ICcvJyB8fCBpc1dpbiAmJiBjaGFyID09PSAnXFxcXCcpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHN0ciwgc3RyaXBUcmFpbGluZykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcL10rL2csICcvJyk7XG4gIGlmIChzdHJpcFRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgIHN0ciA9IHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdW5peGlmeShmaWxlcGF0aCkge1xuICB2YXIgc3RyaXBUcmFpbGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcblxuICBpZiAoaXNXaW4pIHtcbiAgICBmaWxlcGF0aCA9IG5vcm1hbGl6ZVBhdGgoZmlsZXBhdGgsIHN0cmlwVHJhaWxpbmcpO1xuICAgIHJldHVybiBmaWxlcGF0aC5yZXBsYWNlKC9eKFthLXpBLVpdKzp8XFwuXFwvKS8sICcnKTtcbiAgfVxuICByZXR1cm4gZmlsZXBhdGg7XG59XG5cbmZ1bmN0aW9uIGNvcnJlY3RQYXRoKGZpbGVwYXRoKSB7XG4gIHJldHVybiB1bml4aWZ5KGZpbGVwYXRoLnJlcGxhY2UoL15cXFxcXFxcXFxcP1xcXFwuOlxcXFwvLCAnXFxcXCcpKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZnMtbW9ua2V5L2xpYi9jb3JyZWN0UGF0aC5qcyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xudmFyIGZzUHJvcHMgPSBleHBvcnRzLmZzUHJvcHMgPSBbJ2NvbnN0YW50cycsICdGX09LJywgJ1JfT0snLCAnV19PSycsICdYX09LJywgJ1N0YXRzJ107XG5cbnZhciBmc1N5bmNNZXRob2RzID0gZXhwb3J0cy5mc1N5bmNNZXRob2RzID0gWydyZW5hbWVTeW5jJywgJ2Z0cnVuY2F0ZVN5bmMnLCAndHJ1bmNhdGVTeW5jJywgJ2Nob3duU3luYycsICdmY2hvd25TeW5jJywgJ2xjaG93blN5bmMnLCAnY2htb2RTeW5jJywgJ2ZjaG1vZFN5bmMnLCAnbGNobW9kU3luYycsICdzdGF0U3luYycsICdsc3RhdFN5bmMnLCAnZnN0YXRTeW5jJywgJ2xpbmtTeW5jJywgJ3N5bWxpbmtTeW5jJywgJ3JlYWRsaW5rU3luYycsICdyZWFscGF0aFN5bmMnLCAndW5saW5rU3luYycsICdybWRpclN5bmMnLCAnbWtkaXJTeW5jJywgJ21rZGlycFN5bmMnLCAncmVhZGRpclN5bmMnLCAnY2xvc2VTeW5jJywgJ29wZW5TeW5jJywgJ3V0aW1lc1N5bmMnLCAnZnV0aW1lc1N5bmMnLCAnZnN5bmNTeW5jJywgJ3dyaXRlU3luYycsICdyZWFkU3luYycsICdyZWFkRmlsZVN5bmMnLCAnd3JpdGVGaWxlU3luYycsICdhcHBlbmRGaWxlU3luYycsICdleGlzdHNTeW5jJywgJ2FjY2Vzc1N5bmMnLCAnZmRhdGFzeW5jU3luYycsICdta2R0ZW1wU3luYycsICdjb3B5RmlsZVN5bmMnLCAnY3JlYXRlUmVhZFN0cmVhbScsICdjcmVhdGVXcml0ZVN0cmVhbSddO1xuXG52YXIgZnNBc3luY01ldGhvZHMgPSBleHBvcnRzLmZzQXN5bmNNZXRob2RzID0gWydyZW5hbWUnLCAnZnRydW5jYXRlJywgJ3RydW5jYXRlJywgJ2Nob3duJywgJ2ZjaG93bicsICdsY2hvd24nLCAnY2htb2QnLCAnZmNobW9kJywgJ2xjaG1vZCcsICdzdGF0JywgJ2xzdGF0JywgJ2ZzdGF0JywgJ2xpbmsnLCAnc3ltbGluaycsICdyZWFkbGluaycsICdyZWFscGF0aCcsICd1bmxpbmsnLCAncm1kaXInLCAnbWtkaXInLCAnbWtkaXJwJywgJ3JlYWRkaXInLCAnY2xvc2UnLCAnb3BlbicsICd1dGltZXMnLCAnZnV0aW1lcycsICdmc3luYycsICd3cml0ZScsICdyZWFkJywgJ3JlYWRGaWxlJywgJ3dyaXRlRmlsZScsICdhcHBlbmRGaWxlJywgJ2V4aXN0cycsICdhY2Nlc3MnLCAnZmRhdGFzeW5jJywgJ21rZHRlbXAnLCAnY29weUZpbGUnLCAnd2F0Y2hGaWxlJywgJ3Vud2F0Y2hGaWxlJywgJ3dhdGNoJ107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZzLW1vbmtleS9saWIvdXRpbC9saXN0cy5qcyJdLCJzb3VyY2VSb290IjoiIn0=