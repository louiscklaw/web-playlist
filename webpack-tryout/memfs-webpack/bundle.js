/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 28);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(9);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

var Readable = __webpack_require__(22);
var Writable = __webpack_require__(14);

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
exports.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var R = (typeof Reflect === 'undefined' ? 'undefined' : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};

var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + (typeof listener === 'undefined' ? 'undefined' : _typeof(listener)));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {

  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }var doError = type === 'error';

  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  checkListener(listener);

  events = this._events;
  if (events === undefined) return this;

  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;

    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }

    if (list.length === 1) events[type] = list[0];

    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;

  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined) return [];

  var evlistener = events[type];
  if (evlistener === undefined) return [];

  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(31);
var ieee754 = __webpack_require__(32);
var isArray = __webpack_require__(17);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};
  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }
  return descriptors;
};

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(33);

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(34);

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args).then(function (ret) {
      process.nextTick(cb, null, ret);
    }, function (rej) {
      process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(4);
var getBigInt_1 = __webpack_require__(30);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK;
/**
 * Statistics about a file/directory, like `fs.Stats`.
 */
var Stats = /** @class */function () {
    function Stats() {}
    Stats.build = function (node, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var stats = new Stats();
        var uid = node.uid,
            gid = node.gid,
            atime = node.atime,
            mtime = node.mtime,
            ctime = node.ctime;
        var getStatNumber = !bigint ? function (number) {
            return number;
        } : getBigInt_1.default;
        // Copy all values on Stats from Node, so that if Node values
        // change, values on Stats would still be the old ones,
        // just like in Node fs.
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
    };
    Stats.prototype._checkModeProperty = function (property) {
        return (Number(this.mode) & S_IFMT) === property;
    };
    Stats.prototype.isDirectory = function () {
        return this._checkModeProperty(S_IFDIR);
    };
    Stats.prototype.isFile = function () {
        return this._checkModeProperty(S_IFREG);
    };
    Stats.prototype.isBlockDevice = function () {
        return this._checkModeProperty(S_IFBLK);
    };
    Stats.prototype.isCharacterDevice = function () {
        return this._checkModeProperty(S_IFCHR);
    };
    Stats.prototype.isSymbolicLink = function () {
        return this._checkModeProperty(S_IFLNK);
    };
    Stats.prototype.isFIFO = function () {
        return this._checkModeProperty(S_IFIFO);
    };
    Stats.prototype.isSocket = function () {
        return this._checkModeProperty(S_IFSOCK);
    };
    return Stats;
}();
exports.Stats = Stats;
exports.default = Stats;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(7);
exports.Buffer = buffer_1.Buffer;
function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArrays([void 0, arg0], args)))();
}
var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
exports.bufferAllocUnsafe = bufferAllocUnsafe;
var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
exports.bufferFrom = bufferFrom;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports = module.exports = __webpack_require__(22);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(14);
exports.Duplex = __webpack_require__(2);
exports.Transform = __webpack_require__(26);
exports.PassThrough = __webpack_require__(48);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(7);
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(9);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(46)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(23);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(13).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(24);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(2);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(2);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(21).setImmediate, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(4);
var encoding_1 = __webpack_require__(16);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK;
/**
 * A directory entry, like `fs.Dirent`.
 */
var Dirent = /** @class */function () {
    function Dirent() {
        this.name = '';
        this.mode = 0;
    }
    Dirent.build = function (link, encoding) {
        var dirent = new Dirent();
        var mode = link.getNode().mode;
        dirent.name = encoding_1.strToEncoding(link.getName(), encoding);
        dirent.mode = mode;
        return dirent;
    };
    Dirent.prototype._checkModeProperty = function (property) {
        return (this.mode & S_IFMT) === property;
    };
    Dirent.prototype.isDirectory = function () {
        return this._checkModeProperty(S_IFDIR);
    };
    Dirent.prototype.isFile = function () {
        return this._checkModeProperty(S_IFREG);
    };
    Dirent.prototype.isBlockDevice = function () {
        return this._checkModeProperty(S_IFBLK);
    };
    Dirent.prototype.isCharacterDevice = function () {
        return this._checkModeProperty(S_IFCHR);
    };
    Dirent.prototype.isSymbolicLink = function () {
        return this._checkModeProperty(S_IFLNK);
    };
    Dirent.prototype.isFIFO = function () {
        return this._checkModeProperty(S_IFIFO);
    };
    Dirent.prototype.isSocket = function () {
        return this._checkModeProperty(S_IFSOCK);
    };
    return Dirent;
}();
exports.Dirent = Dirent;
exports.default = Dirent;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var buffer_1 = __webpack_require__(11);
var errors = __webpack_require__(18);
exports.ENCODING_UTF8 = 'utf8';
function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError('ERR_INVALID_OPT_VALUE_ENCODING', encoding);
}
exports.assertEncoding = assertEncoding;
function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports.ENCODING_UTF8) return str; // UTF-8
    if (encoding === 'buffer') return new buffer_1.Buffer(str); // `buffer` encoding
    return new buffer_1.Buffer(str).toString(encoding); // Custom encoding
}
exports.strToEncoding = strToEncoding;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
// The whole point behind this internal module is to allow Node.js to no
// longer be forced to treat every error message change as a semver-major
// change. The NodeError classes here all expose a `code` property whose
// value statically and permanently identifies the error. While the error
// message may change, the code should not.

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var kCode = typeof Symbol === 'undefined' ? '_kCode' : Symbol('code');
var messages = {}; // new Map();
// Lazily loaded
var assert = null;
var util = null;
function makeNodeError(Base) {
    return (/** @class */function (_super) {
            __extends(NodeError, _super);
            function NodeError(key) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var _this = _super.call(this, message(key, args)) || this;
                _this.code = key;
                _this[kCode] = key;
                _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
                return _this;
            }
            return NodeError;
        }(Base)
    );
}
var AssertionError = /** @class */function (_super) {
    __extends(AssertionError, _super);
    function AssertionError(options) {
        var _this = this;
        if ((typeof options === "undefined" ? "undefined" : _typeof(options)) !== 'object' || options === null) {
            throw new exports.TypeError('ERR_INVALID_ARG_TYPE', 'options', 'object');
        }
        if (options.message) {
            _this = _super.call(this, options.message) || this;
        } else {
            if (util === null) {
                util = __webpack_require__(8);
            }
            _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = 'AssertionError [ERR_ASSERTION]';
        _this.code = 'ERR_ASSERTION';
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
    }
    return AssertionError;
}(global.Error);
exports.AssertionError = AssertionError;
function message(key, args) {
    if (assert === null) {
        assert = __webpack_require__(35);
    }
    assert.strictEqual(typeof key === "undefined" ? "undefined" : _typeof(key), 'string');
    // const msg = messages.get(key);
    var msg = messages[key];
    assert(msg, "An invalid error message key was used: " + key + ".");
    var fmt;
    if (typeof msg === 'function') {
        fmt = msg;
    } else {
        if (util === null) {
            util = __webpack_require__(8);
        }
        fmt = util.format;
        if (args === undefined || args.length === 0) return msg;
        args.unshift(msg);
    }
    return String(fmt.apply(null, args));
}
exports.message = message;
// Utility function for registering the error codes. Only used here. Exported
// *only* to allow for testing.
function E(sym, val) {
    messages[sym] = typeof val === 'function' ? val : String(val);
}
exports.E = E;
exports.Error = makeNodeError(global.Error);
exports.TypeError = makeNodeError(global.TypeError);
exports.RangeError = makeNodeError(global.RangeError);
// To declare an error message, use the E(sym, val) function above. The sym
// must be an upper case string. The val can be either a function or a string.
// The return value of the function must be a string.
// Examples:
// E('EXAMPLE_KEY1', 'This is the error value');
// E('EXAMPLE_KEY2', (a, b) => return `${a} ${b}`);
//
// Once an error code has been assigned, the code itself MUST NOT change and
// any given error code must never be reused to identify a different error.
//
// Any error code added here should also be added to the documentation
//
// Note: Please try to keep these in alphabetical order
E('ERR_ARG_NOT_ITERABLE', '%s must be iterable');
E('ERR_ASSERTION', '%s');
E('ERR_BUFFER_OUT_OF_BOUNDS', bufferOutOfBounds);
E('ERR_CHILD_CLOSED_BEFORE_REPLY', 'Child closed before reply received');
E('ERR_CONSOLE_WRITABLE_STREAM', 'Console expects a writable stream instance for %s');
E('ERR_CPU_USAGE', 'Unable to obtain cpu usage %s');
E('ERR_DNS_SET_SERVERS_FAILED', function (err, servers) {
    return "c-ares failed to set servers: \"" + err + "\" [" + servers + "]";
});
E('ERR_FALSY_VALUE_REJECTION', 'Promise was rejected with falsy value');
E('ERR_ENCODING_NOT_SUPPORTED', function (enc) {
    return "The \"" + enc + "\" encoding is not supported";
});
E('ERR_ENCODING_INVALID_ENCODED_DATA', function (enc) {
    return "The encoded data was not valid for encoding " + enc;
});
E('ERR_HTTP_HEADERS_SENT', 'Cannot render headers after they are sent to the client');
E('ERR_HTTP_INVALID_STATUS_CODE', 'Invalid status code: %s');
E('ERR_HTTP_TRAILER_INVALID', 'Trailers are invalid with this transfer encoding');
E('ERR_INDEX_OUT_OF_RANGE', 'Index out of range');
E('ERR_INVALID_ARG_TYPE', invalidArgType);
E('ERR_INVALID_ARRAY_LENGTH', function (name, len, actual) {
    assert.strictEqual(typeof actual === "undefined" ? "undefined" : _typeof(actual), 'number');
    return "The array \"" + name + "\" (length " + actual + ") must be of length " + len + ".";
});
E('ERR_INVALID_BUFFER_SIZE', 'Buffer size must be a multiple of %s');
E('ERR_INVALID_CALLBACK', 'Callback must be a function');
E('ERR_INVALID_CHAR', 'Invalid character in %s');
E('ERR_INVALID_CURSOR_POS', 'Cannot set cursor row without setting its column');
E('ERR_INVALID_FD', '"fd" must be a positive integer: %s');
E('ERR_INVALID_FILE_URL_HOST', 'File URL host must be "localhost" or empty on %s');
E('ERR_INVALID_FILE_URL_PATH', 'File URL path %s');
E('ERR_INVALID_HANDLE_TYPE', 'This handle type cannot be sent');
E('ERR_INVALID_IP_ADDRESS', 'Invalid IP address: %s');
E('ERR_INVALID_OPT_VALUE', function (name, value) {
    return "The value \"" + String(value) + "\" is invalid for option \"" + name + "\"";
});
E('ERR_INVALID_OPT_VALUE_ENCODING', function (value) {
    return "The value \"" + String(value) + "\" is invalid for option \"encoding\"";
});
E('ERR_INVALID_REPL_EVAL_CONFIG', 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
E('ERR_INVALID_SYNC_FORK_INPUT', 'Asynchronous forks do not support Buffer, Uint8Array or string input: %s');
E('ERR_INVALID_THIS', 'Value of "this" must be of type %s');
E('ERR_INVALID_TUPLE', '%s must be an iterable %s tuple');
E('ERR_INVALID_URL', 'Invalid URL: %s');
E('ERR_INVALID_URL_SCHEME', function (expected) {
    return "The URL must be " + oneOf(expected, 'scheme');
});
E('ERR_IPC_CHANNEL_CLOSED', 'Channel closed');
E('ERR_IPC_DISCONNECTED', 'IPC channel is already disconnected');
E('ERR_IPC_ONE_PIPE', 'Child process can have only one IPC pipe');
E('ERR_IPC_SYNC_FORK', 'IPC cannot be used with synchronous forks');
E('ERR_MISSING_ARGS', missingArgs);
E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
E('ERR_NAPI_CONS_FUNCTION', 'Constructor must be a function');
E('ERR_NAPI_CONS_PROTOTYPE_OBJECT', 'Constructor.prototype must be an object');
E('ERR_NO_CRYPTO', 'Node.js is not compiled with OpenSSL crypto support');
E('ERR_NO_LONGER_SUPPORTED', '%s is no longer supported');
E('ERR_PARSE_HISTORY_DATA', 'Could not parse history data in %s');
E('ERR_SOCKET_ALREADY_BOUND', 'Socket is already bound');
E('ERR_SOCKET_BAD_PORT', 'Port should be > 0 and < 65536');
E('ERR_SOCKET_BAD_TYPE', 'Bad socket type specified. Valid types are: udp4, udp6');
E('ERR_SOCKET_CANNOT_SEND', 'Unable to send data');
E('ERR_SOCKET_CLOSED', 'Socket is closed');
E('ERR_SOCKET_DGRAM_NOT_RUNNING', 'Not running');
E('ERR_STDERR_CLOSE', 'process.stderr cannot be closed');
E('ERR_STDOUT_CLOSE', 'process.stdout cannot be closed');
E('ERR_STREAM_WRAP', 'Stream has StringDecoder set or is in objectMode');
E('ERR_TLS_CERT_ALTNAME_INVALID', "Hostname/IP does not match certificate's altnames: %s");
E('ERR_TLS_DH_PARAM_SIZE', function (size) {
    return "DH parameter size " + size + " is less than 2048";
});
E('ERR_TLS_HANDSHAKE_TIMEOUT', 'TLS handshake timeout');
E('ERR_TLS_RENEGOTIATION_FAILED', 'Failed to renegotiate');
E('ERR_TLS_REQUIRED_SERVER_NAME', '"servername" is required parameter for Server.addContext');
E('ERR_TLS_SESSION_ATTACK', 'TSL session renegotiation attack detected');
E('ERR_TRANSFORM_ALREADY_TRANSFORMING', 'Calling transform done when still transforming');
E('ERR_TRANSFORM_WITH_LENGTH_0', 'Calling transform done when writableState.length != 0');
E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s');
E('ERR_UNKNOWN_SIGNAL', 'Unknown signal: %s');
E('ERR_UNKNOWN_STDIN_TYPE', 'Unknown stdin file type');
E('ERR_UNKNOWN_STREAM_TYPE', 'Unknown stream file type');
E('ERR_V8BREAKITERATOR', 'Full ICU data not installed. ' + 'See https://github.com/nodejs/node/wiki/Intl');
function invalidArgType(name, expected, actual) {
    assert(name, 'name is required');
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (expected.includes('not ')) {
        determiner = 'must not be';
        expected = expected.split('not ')[1];
    } else {
        determiner = 'must be';
    }
    var msg;
    if (Array.isArray(name)) {
        var names = name.map(function (val) {
            return "\"" + val + "\"";
        }).join(', ');
        msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, 'type');
    } else if (name.includes(' argument')) {
        // for the case like 'first argument'
        msg = "The " + name + " " + determiner + " " + oneOf(expected, 'type');
    } else {
        var type = name.includes('.') ? 'property' : 'argument';
        msg = "The \"" + name + "\" " + type + " " + determiner + " " + oneOf(expected, 'type');
    }
    // if actual value received, output it
    if (arguments.length >= 3) {
        msg += ". Received type " + (actual !== null ? typeof actual === "undefined" ? "undefined" : _typeof(actual) : 'null');
    }
    return msg;
}
function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    assert(args.length > 0, 'At least one arg needs to be specified');
    var msg = 'The ';
    var len = args.length;
    args = args.map(function (a) {
        return "\"" + a + "\"";
    });
    switch (len) {
        case 1:
            msg += args[0] + " argument";
            break;
        case 2:
            msg += args[0] + " and " + args[1] + " arguments";
            break;
        default:
            msg += args.slice(0, len - 1).join(', ');
            msg += ", and " + args[len - 1] + " arguments";
            break;
    }
    return msg + " must be specified";
}
function oneOf(expected, thing) {
    assert(expected, 'expected is required');
    assert(typeof thing === 'string', 'thing is required');
    if (Array.isArray(expected)) {
        var len = expected.length;
        assert(len > 0, 'At least one expected value needs to be specified');
        // tslint:disable-next-line
        expected = expected.map(function (i) {
            return String(i);
        });
        if (len > 2) {
            return "one of " + thing + " " + expected.slice(0, len - 1).join(', ') + ", or " + expected[len - 1];
        } else if (len === 2) {
            return "one of " + thing + " " + expected[0] + " or " + expected[1];
        } else {
            return "of " + thing + " " + expected[0];
        }
    } else {
        return "of " + thing + " " + String(expected);
    }
}
function bufferOutOfBounds(name, isWriting) {
    if (isWriting) {
        return 'Attempt to write outside buffer bounds';
    } else {
        return "\"" + name + "\" is outside of buffer bounds";
    }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
// Here we mock the global `process` variable in case we are not in Node's environment.

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Looks to return a `process` object, if one is available.
 *
 * The global `process` is returned if defined;
 * otherwise `require('process')` is attempted.
 *
 * If that fails, `undefined` is returned.
 *
 * @return {IProcess | undefined}
 */
var maybeReturnProcess = function maybeReturnProcess() {
    if (typeof process !== 'undefined') {
        return process;
    }
    try {
        return __webpack_require__(1);
    } catch (_a) {
        return undefined;
    }
};
function createProcess() {
    var p = maybeReturnProcess() || {};
    if (!p.getuid) p.getuid = function () {
        return 0;
    };
    if (!p.getgid) p.getgid = function () {
        return 0;
    };
    if (!p.cwd) p.cwd = function () {
        return '/';
    };
    if (!p.nextTick) p.nextTick = __webpack_require__(20).default;
    if (!p.emitWarning) p.emitWarning = function (message, type) {
        // tslint:disable-next-line:no-console
        console.warn("" + type + (type ? ': ' : '') + message);
    };
    if (!p.env) p.env = {};
    return p;
}
exports.createProcess = createProcess;
exports.default = createProcess();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate, global) {

Object.defineProperty(exports, "__esModule", { value: true });
var _setImmediate;
if (typeof setImmediate === 'function') _setImmediate = setImmediate.bind(global);else _setImmediate = setTimeout.bind(global);
exports.default = _setImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21).setImmediate, __webpack_require__(0)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(40);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || undefined && undefined.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || undefined && undefined.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(9);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(17);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(5).EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(23);
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(13).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(43);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = __webpack_require__(44);
var destroyImpl = __webpack_require__(24);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(2);

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(25).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(2);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(25).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(5).EventEmitter;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(9);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(47).Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\uFFFD';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\uFFFD';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\uFFFD';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\uFFFD';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(2);

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 27 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _fs = __webpack_require__(29);

(0, _fs.writeFileSync)('/text.txt', 'Hello world!');
console.log((0, _fs.readFileSync)('/text.txt', 'utf8'));
console.log(_fs.vol.toJSON());

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = undefined && undefined.__assign || function () {
    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) {
                if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var Stats_1 = __webpack_require__(10);
var Dirent_1 = __webpack_require__(15);
var volume_1 = __webpack_require__(37);
var _a = __webpack_require__(63),
    fsSyncMethods = _a.fsSyncMethods,
    fsAsyncMethods = _a.fsAsyncMethods;
var constants_1 = __webpack_require__(4);
var F_OK = constants_1.constants.F_OK,
    R_OK = constants_1.constants.R_OK,
    W_OK = constants_1.constants.W_OK,
    X_OK = constants_1.constants.X_OK;
exports.Volume = volume_1.Volume;
// Default volume.
exports.vol = new volume_1.Volume();
function createFsFromVolume(vol) {
    var fs = { F_OK: F_OK, R_OK: R_OK, W_OK: W_OK, X_OK: X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
    // Bind FS methods.
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
    }
    for (var _a = 0, fsAsyncMethods_1 = fsAsyncMethods; _a < fsAsyncMethods_1.length; _a++) {
        var method = fsAsyncMethods_1[_a];
        if (typeof vol[method] === 'function') fs[method] = vol[method].bind(vol);
    }
    fs.StatWatcher = vol.StatWatcher;
    fs.FSWatcher = vol.FSWatcher;
    fs.WriteStream = vol.WriteStream;
    fs.ReadStream = vol.ReadStream;
    fs.promises = vol.promises;
    fs._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs;
}
exports.createFsFromVolume = createFsFromVolume;
exports.fs = createFsFromVolume(exports.vol);
module.exports = __assign(__assign({}, module.exports), exports.fs);
module.exports.semantic = true;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof BigInt === 'function') exports.default = BigInt;else exports.default = function BigIntNotSupported() {
  throw new Error('BigInt is not supported in this environment.');
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;

  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;

  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;

  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function isBuffer(arg) {
  return arg && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var objectAssign = __webpack_require__(36);

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = __webpack_require__(8);
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

    // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

    // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) !== 'object') && (expected === null || (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) !== 'object')) {
    return strict ? actual === expected : actual == expected;

    // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

    // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || { actual: [], expected: [] };

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var pathModule = __webpack_require__(38);
var node_1 = __webpack_require__(39);
var Stats_1 = __webpack_require__(10);
var Dirent_1 = __webpack_require__(15);
var buffer_1 = __webpack_require__(11);
var setImmediate_1 = __webpack_require__(20);
var process_1 = __webpack_require__(19);
var setTimeoutUnref_1 = __webpack_require__(41);
var stream_1 = __webpack_require__(42);
var constants_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var encoding_1 = __webpack_require__(16);
var errors = __webpack_require__(18);
var extend = __webpack_require__(53);
var util = __webpack_require__(8);
var promises_1 = __webpack_require__(54);
var resolveCrossPlatform = pathModule.resolve;
var O_RDONLY = constants_1.constants.O_RDONLY,
    O_WRONLY = constants_1.constants.O_WRONLY,
    O_RDWR = constants_1.constants.O_RDWR,
    O_CREAT = constants_1.constants.O_CREAT,
    O_EXCL = constants_1.constants.O_EXCL,
    O_TRUNC = constants_1.constants.O_TRUNC,
    O_APPEND = constants_1.constants.O_APPEND,
    O_SYNC = constants_1.constants.O_SYNC,
    F_OK = constants_1.constants.F_OK,
    COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL,
    COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
var sep;
var relative;
if (pathModule.posix) {
    var posix = pathModule.posix;
    sep = posix.sep;
    relative = posix.relative;
} else {
    sep = pathModule.sep;
    relative = pathModule.relative;
}
var isWin = process_1.default.platform === 'win32';
var kMinPoolSpace = 128;
// const kMaxLength = require('buffer').kMaxLength;
// ---------------------------------------- Error messages
// TODO: Use `internal/errors.js` in the future.
var ERRSTR = {
    PATH_STR: 'path must be a string or Buffer',
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: 'fd must be a file descriptor',
    MODE_INT: 'mode must be an int',
    CB: 'callback must be a function',
    UID: 'uid must be an unsigned int',
    GID: 'gid must be an unsigned int',
    LEN: 'len must be an integer',
    ATIME: 'atime must be an integer',
    MTIME: 'mtime must be an integer',
    PREFIX: 'filename prefix is required',
    BUFFER: 'buffer must be an instance of Buffer or StaticBuffer',
    OFFSET: 'offset must be an integer',
    LENGTH: 'length must be an integer',
    POSITION: 'position must be an integer'
};
var ERRSTR_OPTS = function ERRSTR_OPTS(tipeof) {
    return "Expected options to be either an object or a string, but got " + tipeof + " instead";
};
// const ERRSTR_FLAG = flag => `Unknown file open flag: ${flag}`;
var ENOENT = 'ENOENT';
var EBADF = 'EBADF';
var EINVAL = 'EINVAL';
var EPERM = 'EPERM';
var EPROTO = 'EPROTO';
var EEXIST = 'EEXIST';
var ENOTDIR = 'ENOTDIR';
var EMFILE = 'EMFILE';
var EACCES = 'EACCES';
var EISDIR = 'EISDIR';
var ENOTEMPTY = 'ENOTEMPTY';
var ENOSYS = 'ENOSYS';
function formatError(errorCode, func, path, path2) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    var pathFormatted = '';
    if (path) pathFormatted = " '" + path + "'";
    if (path2) pathFormatted += " -> '" + path2 + "'";
    switch (errorCode) {
        case ENOENT:
            return "ENOENT: no such file or directory, " + func + pathFormatted;
        case EBADF:
            return "EBADF: bad file descriptor, " + func + pathFormatted;
        case EINVAL:
            return "EINVAL: invalid argument, " + func + pathFormatted;
        case EPERM:
            return "EPERM: operation not permitted, " + func + pathFormatted;
        case EPROTO:
            return "EPROTO: protocol error, " + func + pathFormatted;
        case EEXIST:
            return "EEXIST: file already exists, " + func + pathFormatted;
        case ENOTDIR:
            return "ENOTDIR: not a directory, " + func + pathFormatted;
        case EISDIR:
            return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
        case EACCES:
            return "EACCES: permission denied, " + func + pathFormatted;
        case ENOTEMPTY:
            return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
        case EMFILE:
            return "EMFILE: too many open files, " + func + pathFormatted;
        case ENOSYS:
            return "ENOSYS: function not implemented, " + func + pathFormatted;
        default:
            return errorCode + ": error occurred, " + func + pathFormatted;
    }
}
function createError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    if (Constructor === void 0) {
        Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path, path2));
    error.code = errorCode;
    return error;
}
function throwError(errorCode, func, path, path2, Constructor) {
    if (func === void 0) {
        func = '';
    }
    if (path === void 0) {
        path = '';
    }
    if (path2 === void 0) {
        path2 = '';
    }
    if (Constructor === void 0) {
        Constructor = Error;
    }
    throw createError(errorCode, func, path, path2, Constructor);
}
// ---------------------------------------- Flags
// List of file `flags` as defined by Node.
var FLAGS;
(function (FLAGS) {
    // Open file for reading. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r"] = O_RDONLY] = "r";
    // Open file for reading and writing. An exception occurs if the file does not exist.
    FLAGS[FLAGS["r+"] = O_RDWR] = "r+";
    // Open file for reading in synchronous mode. Instructs the operating system to bypass the local file system cache.
    FLAGS[FLAGS["rs"] = O_RDONLY | O_SYNC] = "rs";
    FLAGS[FLAGS["sr"] = FLAGS.rs] = "sr";
    // Open file for reading and writing, telling the OS to open it synchronously. See notes for 'rs' about using this with caution.
    FLAGS[FLAGS["rs+"] = O_RDWR | O_SYNC] = "rs+";
    FLAGS[FLAGS["sr+"] = FLAGS['rs+']] = "sr+";
    // Open file for writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
    // Like 'w' but fails if path exists.
    FLAGS[FLAGS["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
    FLAGS[FLAGS["xw"] = FLAGS.wx] = "xw";
    // Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).
    FLAGS[FLAGS["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
    // Like 'w+' but fails if path exists.
    FLAGS[FLAGS["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
    FLAGS[FLAGS["xw+"] = FLAGS['wx+']] = "xw+";
    // Open file for appending. The file is created if it does not exist.
    FLAGS[FLAGS["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
    // Like 'a' but fails if path exists.
    FLAGS[FLAGS["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
    FLAGS[FLAGS["xa"] = FLAGS.ax] = "xa";
    // Open file for reading and appending. The file is created if it does not exist.
    FLAGS[FLAGS["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
    // Like 'a+' but fails if path exists.
    FLAGS[FLAGS["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
    FLAGS[FLAGS["xa+"] = FLAGS['ax+']] = "xa+";
})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
function flagsToNumber(flags) {
    if (typeof flags === 'number') return flags;
    if (typeof flags === 'string') {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== 'undefined') return flagsNum;
    }
    // throw new TypeError(formatError(ERRSTR_FLAG(flags)));
    throw new errors.TypeError('ERR_INVALID_OPT_VALUE', 'flags', flags);
}
exports.flagsToNumber = flagsToNumber;
// ---------------------------------------- Options
function getOptions(defaults, options) {
    var opts;
    if (!options) return defaults;else {
        var tipeof = typeof options === "undefined" ? "undefined" : _typeof(options);
        switch (tipeof) {
            case 'string':
                opts = extend({}, defaults, { encoding: options });
                break;
            case 'object':
                opts = extend({}, defaults, options);
                break;
            default:
                throw TypeError(ERRSTR_OPTS(tipeof));
        }
    }
    if (opts.encoding !== 'buffer') encoding_1.assertEncoding(opts.encoding);
    return opts;
}
function optsGenerator(defaults) {
    return function (options) {
        return getOptions(defaults, options);
    };
}
function validateCallback(callback) {
    if (typeof callback !== 'function') throw TypeError(ERRSTR.CB);
    return callback;
}
function optsAndCbGenerator(getOpts) {
    return function (options, callback) {
        return typeof options === 'function' ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
}
var optsDefaults = {
    encoding: 'utf8'
};
var getDefaultOpts = optsGenerator(optsDefaults);
var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
var readFileOptsDefaults = {
    flag: 'r'
};
var getReadFileOptions = optsGenerator(readFileOptsDefaults);
var writeFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* DEFAULT */
    , flag: FLAGS[FLAGS.w]
};
var getWriteFileOptions = optsGenerator(writeFileDefaults);
var appendFileDefaults = {
    encoding: 'utf8',
    mode: 438 /* DEFAULT */
    , flag: FLAGS[FLAGS.a]
};
var getAppendFileOpts = optsGenerator(appendFileDefaults);
var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
var realpathDefaults = optsDefaults;
var getRealpathOptions = optsGenerator(realpathDefaults);
var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
var mkdirDefaults = {
    mode: 511 /* DIR */
    , recursive: false
};
var getMkdirOptions = function getMkdirOptions(options) {
    if (typeof options === 'number') return extend({}, mkdirDefaults, { mode: options });
    return extend({}, mkdirDefaults, options);
};
var readdirDefaults = {
    encoding: 'utf8',
    withFileTypes: false
};
var getReaddirOptions = optsGenerator(readdirDefaults);
var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
var statDefaults = {
    bigint: false
};
var getStatOptions = function getStatOptions(options) {
    if (options === void 0) {
        options = {};
    }
    return extend({}, statDefaults, options);
};
var getStatOptsAndCb = function getStatOptsAndCb(options, callback) {
    return typeof options === 'function' ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
};
// ---------------------------------------- Utility functions
function getPathFromURLPosix(url) {
    if (url.hostname !== '') {
        throw new errors.TypeError('ERR_INVALID_FILE_URL_HOST', process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === '%') {
            var third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === '2' && third === 102) {
                throw new errors.TypeError('ERR_INVALID_FILE_URL_PATH', 'must not include encoded / characters');
            }
        }
    }
    return decodeURIComponent(pathname);
}
function pathToFilename(path) {
    if (typeof path !== 'string' && !buffer_1.Buffer.isBuffer(path)) {
        try {
            if (!(path instanceof __webpack_require__(55).URL)) throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
            throw new TypeError(ERRSTR.PATH_STR);
        }
        path = getPathFromURLPosix(path);
    }
    var pathString = String(path);
    nullCheck(pathString);
    // return slash(pathString);
    return pathString;
}
exports.pathToFilename = pathToFilename;
var resolve = function resolve(filename, base) {
    if (base === void 0) {
        base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
};
if (isWin) {
    var _resolve_1 = resolve;
    var unixify_1 = __webpack_require__(62).unixify;
    resolve = function resolve(filename, base) {
        return unixify_1(_resolve_1(filename, base));
    };
}
function filenameToSteps(filename, base) {
    var fullPath = resolve(filename, base);
    var fullPathSansSlash = fullPath.substr(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep);
}
exports.filenameToSteps = filenameToSteps;
function pathToSteps(path) {
    return filenameToSteps(pathToFilename(path));
}
exports.pathToSteps = pathToSteps;
function dataToStr(data, encoding) {
    if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);else if (data instanceof Uint8Array) return buffer_1.bufferFrom(data).toString(encoding);else return String(data);
}
exports.dataToStr = dataToStr;
function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data;else if (data instanceof Uint8Array) return buffer_1.bufferFrom(data);else return buffer_1.bufferFrom(String(data), encoding);
}
exports.dataToBuffer = dataToBuffer;
function bufferToEncoding(buffer, encoding) {
    if (!encoding || encoding === 'buffer') return buffer;else return buffer.toString(encoding);
}
exports.bufferToEncoding = bufferToEncoding;
function nullCheck(path, callback) {
    if (('' + path).indexOf("\0") !== -1) {
        var er = new Error('Path must be a string without null bytes');
        er.code = ENOENT;
        if (typeof callback !== 'function') throw er;
        process_1.default.nextTick(callback, er);
        return false;
    }
    return true;
}
function _modeToNumber(mode, def) {
    if (typeof mode === 'number') return mode;
    if (typeof mode === 'string') return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return undefined;
}
function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== 'number' || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
}
function isFd(path) {
    return path >>> 0 === path;
}
function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
}
// converts Date or number to a fractional UNIX timestamp
function toUnixTimestamp(time) {
    // tslint:disable-next-line triple-equals
    if (typeof time === 'string' && +time == time) {
        return +time;
    }
    if (time instanceof Date) {
        return time.getTime() / 1000;
    }
    if (isFinite(time)) {
        if (time < 0) {
            return Date.now() / 1000;
        }
        return time;
    }
    throw new Error('Cannot parse time: ' + time);
}
exports.toUnixTimestamp = toUnixTimestamp;
/**
 * Returns optional argument and callback
 * @param arg Argument or callback value
 * @param callback Callback or undefined
 * @param def Default argument value
 */
function getArgAndCb(arg, callback, def) {
    return typeof arg === 'function' ? [def, arg] : [arg, callback];
}
function validateUid(uid) {
    if (typeof uid !== 'number') throw TypeError(ERRSTR.UID);
}
function validateGid(gid) {
    if (typeof gid !== 'number') throw TypeError(ERRSTR.GID);
}
/**
 * `Volume` represents a file system.
 */
var Volume = /** @class */function () {
    function Volume(props) {
        if (props === void 0) {
            props = {};
        }
        // I-node number counter.
        this.ino = 0;
        // A mapping for i-node numbers to i-nodes (`Node`);
        this.inodes = {};
        // List of released i-node numbers, for reuse.
        this.releasedInos = [];
        // A mapping for file descriptors to `File`s.
        this.fds = {};
        // A list of reusable (opened and closed) file descriptors, that should be
        // used first before creating a new file descriptor.
        this.releasedFds = [];
        // Max number of open files.
        this.maxFiles = 10000;
        // Current number of open files.
        this.openFiles = 0;
        this.promisesApi = promises_1.default(this);
        this.statWatchers = {};
        this.props = extend({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self = this; // tslint:disable-line no-this-assignment
        this.StatWatcher = /** @class */function (_super) {
            __extends(StatWatcher, _super);
            function StatWatcher() {
                return _super.call(this, self) || this;
            }
            return StatWatcher;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = /** @class */function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spreadArrays([self], args)) || this;
            }
            return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = /** @class */function (_super) {
            __extends(class_2, _super);
            function class_2() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _super.apply(this, __spreadArrays([self], args)) || this;
            }
            return class_2;
        }(_WriteStream);
        this.FSWatcher = /** @class */function (_super) {
            __extends(FSWatcher, _super);
            function FSWatcher() {
                return _super.call(this, self) || this;
            }
            return FSWatcher;
        }(FSWatcher);
        // root.setChild('.', root);
        // root.getNode().nlink++;
        // root.setChild('..', root);
        // root.getNode().nlink++;
        this.root = root;
    }
    Volume.fromJSON = function (json, cwd) {
        var vol = new Volume();
        vol.fromJSON(json, cwd);
        return vol;
    };
    Object.defineProperty(Volume.prototype, "promises", {
        get: function get() {
            if (this.promisesApi === null) throw new Error('Promise is not supported in this environment.');
            return this.promisesApi;
        },
        enumerable: true,
        configurable: true
    });
    Volume.prototype.createLink = function (parent, name, isDirectory, perm) {
        if (isDirectory === void 0) {
            isDirectory = false;
        }
        return parent ? parent.createChild(name, this.createNode(isDirectory, perm)) : new this.props.Link(this, null, '');
    };
    Volume.prototype.deleteLink = function (link) {
        var parent = link.parent;
        if (parent) {
            parent.deleteChild(link);
            link.vol = null;
            link.parent = null;
            return true;
        }
        return false;
    };
    Volume.prototype.newInoNumber = function () {
        if (this.releasedInos.length) return this.releasedInos.pop();else {
            this.ino = (this.ino + 1) % 0xffffffff;
            return this.ino;
        }
    };
    Volume.prototype.newFdNumber = function () {
        return this.releasedFds.length ? this.releasedFds.pop() : Volume.fd--;
    };
    Volume.prototype.createNode = function (isDirectory, perm) {
        if (isDirectory === void 0) {
            isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory) node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
    };
    Volume.prototype.getNode = function (ino) {
        return this.inodes[ino];
    };
    Volume.prototype.deleteNode = function (node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
    };
    // Generates 6 character long random string, used by `mkdtemp`.
    Volume.prototype.genRndStr = function () {
        var str = (Math.random() + 1).toString(36).substr(2, 6);
        if (str.length === 6) return str;else return this.genRndStr();
    };
    // Returns a `Link` (hard link) referenced by path "split" into steps.
    Volume.prototype.getLink = function (steps) {
        return this.root.walk(steps);
    };
    // Just link `getLink`, but throws a correct user error, if link to found.
    Volume.prototype.getLinkOrThrow = function (filename, funcName) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link) throwError(ENOENT, funcName, filename);
        return link;
    };
    // Just like `getLink`, but also dereference/resolves symbolic links.
    Volume.prototype.getResolvedLink = function (filenameOrSteps) {
        var steps = typeof filenameOrSteps === 'string' ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link = this.root;
        var i = 0;
        while (i < steps.length) {
            var step = steps[i];
            link = link.getChild(step);
            if (!link) return null;
            var node = link.getNode();
            if (node.isSymlink()) {
                steps = node.symlink.concat(steps.slice(i + 1));
                link = this.root;
                i = 0;
                continue;
            }
            i++;
        }
        return link;
    };
    // Just like `getLinkOrThrow`, but also dereference/resolves symbolic links.
    Volume.prototype.getResolvedLinkOrThrow = function (filename, funcName) {
        var link = this.getResolvedLink(filename);
        if (!link) throwError(ENOENT, funcName, filename);
        return link;
    };
    Volume.prototype.resolveSymlinks = function (link) {
        // let node: Node = link.getNode();
        // while(link && node.isSymlink()) {
        //     link = this.getLink(node.symlink);
        //     if(!link) return null;
        //     node = link.getNode();
        // }
        // return link;
        return this.getResolvedLink(link.steps.slice(1));
    };
    // Just like `getLinkOrThrow`, but also verifies that the link is a directory.
    Volume.prototype.getLinkAsDirOrThrow = function (filename, funcName) {
        var link = this.getLinkOrThrow(filename, funcName);
        if (!link.getNode().isDirectory()) throwError(ENOTDIR, funcName, filename);
        return link;
    };
    // Get the immediate parent directory of the link.
    Volume.prototype.getLinkParent = function (steps) {
        return this.root.walk(steps, steps.length - 1);
    };
    Volume.prototype.getLinkParentAsDirOrThrow = function (filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link = this.getLinkParent(steps);
        if (!link) throwError(ENOENT, funcName, sep + steps.join(sep));
        if (!link.getNode().isDirectory()) throwError(ENOTDIR, funcName, sep + steps.join(sep));
        return link;
    };
    Volume.prototype.getFileByFd = function (fd) {
        return this.fds[String(fd)];
    };
    Volume.prototype.getFileByFdOrThrow = function (fd, funcName) {
        if (!isFd(fd)) throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file) throwError(EBADF, funcName);
        return file;
    };
    Volume.prototype.getNodeByIdOrCreate = function (id, flags, perm) {
        if (typeof id === 'number') {
            var file = this.getFileByFd(id);
            if (!file) throw Error('File nto found');
            return file.node;
        } else {
            var steps = pathToSteps(id);
            var link = this.getLink(steps);
            if (link) return link.getNode();
            // Try creating a node if not found.
            if (flags & O_CREAT) {
                var dirLink = this.getLinkParent(steps);
                if (dirLink) {
                    var name_1 = steps[steps.length - 1];
                    link = this.createLink(dirLink, name_1, false, perm);
                    return link.getNode();
                }
            }
            throwError(ENOENT, 'getNodeByIdOrCreate', pathToFilename(id));
        }
    };
    Volume.prototype.wrapAsync = function (method, args, callback) {
        var _this = this;
        validateCallback(callback);
        setImmediate_1.default(function () {
            try {
                callback(null, method.apply(_this, args));
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype._toJSON = function (link, json, path) {
        var _a;
        if (link === void 0) {
            link = this.root;
        }
        if (json === void 0) {
            json = {};
        }
        var isEmpty = true;
        var children = link.children;
        if (link.getNode().isFile()) {
            children = (_a = {}, _a[link.getName()] = link.parent.getChild(link.getName()), _a);
            link = link.parent;
        }
        for (var name_2 in children) {
            isEmpty = false;
            var child = link.getChild(name_2);
            var node = child.getNode();
            if (node.isFile()) {
                var filename = child.getPath();
                if (path) filename = relative(path, filename);
                json[filename] = node.getString();
            } else if (node.isDirectory()) {
                this._toJSON(child, json, path);
            }
        }
        var dirPath = link.getPath();
        if (path) dirPath = relative(path, dirPath);
        if (dirPath && isEmpty) {
            json[dirPath] = null;
        }
        return json;
    };
    Volume.prototype.toJSON = function (paths, json, isRelative) {
        if (json === void 0) {
            json = {};
        }
        if (isRelative === void 0) {
            isRelative = false;
        }
        var links = [];
        if (paths) {
            if (!(paths instanceof Array)) paths = [paths];
            for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
                var path = paths_1[_i];
                var filename = pathToFilename(path);
                var link = this.getResolvedLink(filename);
                if (!link) continue;
                links.push(link);
            }
        } else {
            links.push(this.root);
        }
        if (!links.length) return json;
        for (var _a = 0, links_1 = links; _a < links_1.length; _a++) {
            var link = links_1[_a];
            this._toJSON(link, json, isRelative ? link.getPath() : '');
        }
        return json;
    };
    // fromJSON(json: {[filename: string]: string}, cwd: string = '/') {
    Volume.prototype.fromJSON = function (json, cwd) {
        if (cwd === void 0) {
            cwd = process_1.default.cwd();
        }
        for (var filename in json) {
            var data = json[filename];
            if (typeof data === 'string') {
                filename = resolve(filename, cwd);
                var steps = filenameToSteps(filename);
                if (steps.length > 1) {
                    var dirname = sep + steps.slice(0, steps.length - 1).join(sep);
                    this.mkdirpBase(dirname, 511 /* DIR */);
                }
                this.writeFileSync(filename, data);
            } else {
                this.mkdirpBase(filename, 511 /* DIR */);
            }
        }
    };
    Volume.prototype.reset = function () {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
    };
    // Legacy interface
    Volume.prototype.mountSync = function (mountpoint, json) {
        this.fromJSON(json, mountpoint);
    };
    Volume.prototype.openLink = function (link, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
            // Too many open files.
            throw createError(EMFILE, 'open', link.getPath());
        }
        // Resolve symlinks.
        var realLink = link;
        if (resolveSymlinks) realLink = this.resolveSymlinks(link);
        if (!realLink) throwError(ENOENT, 'open', link.getPath());
        var node = realLink.getNode();
        if (node.isDirectory() && flagsNum !== FLAGS.r) throwError(EISDIR, 'open', link.getPath());
        // Check node permissions
        if (!(flagsNum & O_WRONLY)) {
            if (!node.canRead()) {
                throwError(EACCES, 'open', link.getPath());
            }
        }
        if (flagsNum & O_RDWR) {}
        var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC) file.truncate();
        return file;
    };
    Volume.prototype.openFile = function (filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        // Try creating a new file, if it does not exist.
        if (!link && flagsNum & O_CREAT) {
            // const dirLink: Link = this.getLinkParent(steps);
            var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
            // if(!dirLink) throwError(ENOENT, 'open', filename);
            if (!dirLink) throwError(ENOENT, 'open', sep + steps.join(sep));
            if (flagsNum & O_CREAT && typeof modeNum === 'number') {
                link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
            }
        }
        if (link) return this.openLink(link, flagsNum, resolveSymlinks);
        throwError(ENOENT, 'open', filename);
    };
    Volume.prototype.openBase = function (filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file) throwError(ENOENT, 'open', filename);
        return file.fd;
    };
    Volume.prototype.openSync = function (path, flags, mode) {
        if (mode === void 0) {
            mode = 438 /* DEFAULT */;
        }
        // Validate (1) mode; (2) path; (3) flags - in that order.
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
    };
    Volume.prototype.open = function (path, flags, a, b) {
        var mode = a;
        var callback = b;
        if (typeof a === 'function') {
            mode = 438 /* DEFAULT */;
            callback = a;
        }
        mode = mode || 438 /* DEFAULT */;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
    };
    Volume.prototype.closeFile = function (file) {
        if (!this.fds[file.fd]) return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
    };
    Volume.prototype.closeSync = function (fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, 'close');
        this.closeFile(file);
    };
    Volume.prototype.close = function (fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
    };
    Volume.prototype.openFileOrGetById = function (id, flagsNum, modeNum) {
        if (typeof id === 'number') {
            var file = this.fds[id];
            if (!file) throw createError(ENOENT);
            return file;
        } else {
            return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
    };
    Volume.prototype.readBase = function (fd, buffer, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer, Number(offset), Number(length), position);
    };
    Volume.prototype.readSync = function (fd, buffer, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer, offset, length, position);
    };
    Volume.prototype.read = function (fd, buffer, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        // This `if` branch is from Node.js
        if (length === 0) {
            return process_1.default.nextTick(function () {
                if (callback) callback(null, 0, buffer);
            });
        }
        setImmediate_1.default(function () {
            try {
                var bytes = _this.readBase(fd, buffer, offset, length, position);
                callback(null, bytes, buffer);
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype.readFileBase = function (id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === 'number';
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd) fd = id;else {
            var filename = pathToFilename(id);
            var steps = filenameToSteps(filename);
            var link = this.getResolvedLink(steps);
            if (link) {
                var node = link.getNode();
                if (node.isDirectory()) throwError(EISDIR, 'open', link.getPath());
            }
            fd = this.openSync(id, flagsNum);
        }
        try {
            result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
            if (!userOwnsFd) {
                this.closeSync(fd);
            }
        }
        return result;
    };
    Volume.prototype.readFileSync = function (file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
    };
    Volume.prototype.readFile = function (id, a, b) {
        var _a = optsAndCbGenerator(getReadFileOptions)(a, b),
            opts = _a[0],
            callback = _a[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
    };
    Volume.prototype.writeBase = function (fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, 'write');
        return file.write(buf, offset, length, position);
    };
    Volume.prototype.writeSync = function (fd, a, b, c, d) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer = typeof a !== 'string';
        if (isBuffer) {
            offset = b | 0;
            length = c;
            position = d;
        } else {
            position = b;
            encoding = c;
        }
        var buf = dataToBuffer(a, encoding);
        if (isBuffer) {
            if (typeof length === 'undefined') {
                length = buf.length;
            }
        } else {
            offset = 0;
            length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
    };
    Volume.prototype.write = function (fd, a, b, c, d, e) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a === "undefined" ? "undefined" : _typeof(a);
        var tipb = typeof b === "undefined" ? "undefined" : _typeof(b);
        var tipc = typeof c === "undefined" ? "undefined" : _typeof(c);
        var tipd = typeof d === "undefined" ? "undefined" : _typeof(d);
        if (tipa !== 'string') {
            if (tipb === 'function') {
                callback = b;
            } else if (tipc === 'function') {
                offset = b | 0;
                callback = c;
            } else if (tipd === 'function') {
                offset = b | 0;
                length = c;
                callback = d;
            } else {
                offset = b | 0;
                length = c;
                position = d;
                callback = e;
            }
        } else {
            if (tipb === 'function') {
                callback = b;
            } else if (tipc === 'function') {
                position = b;
                callback = c;
            } else if (tipd === 'function') {
                position = b;
                encoding = c;
                callback = d;
            }
        }
        var buf = dataToBuffer(a, encoding);
        if (tipa !== 'string') {
            if (typeof length === 'undefined') length = buf.length;
        } else {
            offset = 0;
            length = buf.length;
        }
        validateCallback(callback);
        setImmediate_1.default(function () {
            try {
                var bytes = _this.writeBase(fd, buf, offset, length, position);
                if (tipa !== 'string') {
                    callback(null, bytes, buf);
                } else {
                    callback(null, bytes, a);
                }
            } catch (err) {
                callback(err);
            }
        });
    };
    Volume.prototype.writeFileBase = function (id, buf, flagsNum, modeNum) {
        // console.log('writeFileBase', id, buf, flagsNum, modeNum);
        // const node = this.getNodeByIdOrCreate(id, flagsNum, modeNum);
        // node.setBuffer(buf);
        var isUserFd = typeof id === 'number';
        var fd;
        if (isUserFd) fd = id;else {
            fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
            // fd = this.openSync(id as TFilePath, flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? null : 0;
        try {
            while (length > 0) {
                var written = this.writeSync(fd, buf, offset, length, position);
                offset += written;
                length -= written;
                if (position !== null) position += written;
            }
        } finally {
            if (!isUserFd) this.closeSync(fd);
        }
    };
    Volume.prototype.writeFileSync = function (id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
    };
    Volume.prototype.writeFile = function (id, data, a, b) {
        var options = a;
        var callback = b;
        if (typeof a === 'function') {
            options = writeFileDefaults;
            callback = a;
        }
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], callback);
    };
    Volume.prototype.linkBase = function (filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1) throwError(ENOENT, 'link', filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        // Check new link directory exists.
        var dir2 = this.getLinkParent(steps2);
        if (!dir2) throwError(ENOENT, 'link', filename1, filename2);
        var name = steps2[steps2.length - 1];
        // Check if new file already exists.
        if (dir2.getChild(name)) throwError(EEXIST, 'link', filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name, node);
    };
    Volume.prototype.copyFileBase = function (src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
                throwError(EEXIST, 'copyFile', src, dest);
            }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
            throwError(ENOSYS, 'copyFile', src, dest);
        }
        this.writeFileBase(dest, buf, FLAGS.w, 438 /* DEFAULT */);
    };
    Volume.prototype.copyFileSync = function (src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, flags | 0);
    };
    Volume.prototype.copyFile = function (src, dest, a, b) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a === 'function') {
            flags = 0;
            callback = a;
        } else {
            flags = a;
            callback = b;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
    };
    Volume.prototype.linkSync = function (existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
    };
    Volume.prototype.link = function (existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
    };
    Volume.prototype.unlinkBase = function (filename) {
        var steps = filenameToSteps(filename);
        var link = this.getLink(steps);
        if (!link) throwError(ENOENT, 'unlink', filename);
        // TODO: Check if it is file, dir, other...
        if (link.length) throw Error('Dir not empty...');
        this.deleteLink(link);
        var node = link.getNode();
        node.nlink--;
        // When all hard links to i-node are deleted, remove the i-node, too.
        if (node.nlink <= 0) {
            this.deleteNode(node);
        }
    };
    Volume.prototype.unlinkSync = function (path) {
        var filename = pathToFilename(path);
        this.unlinkBase(filename);
    };
    Volume.prototype.unlink = function (path, callback) {
        var filename = pathToFilename(path);
        this.wrapAsync(this.unlinkBase, [filename], callback);
    };
    Volume.prototype.symlinkBase = function (targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        // Check if directory exists, where we about to create a symlink.
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink) throwError(ENOENT, 'symlink', targetFilename, pathFilename);
        var name = pathSteps[pathSteps.length - 1];
        // Check if new file already exists.
        if (dirLink.getChild(name)) throwError(EEXIST, 'symlink', targetFilename, pathFilename);
        // Create symlink.
        var symlink = dirLink.createChild(name);
        symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink;
    };
    // `type` argument works only on Windows.
    Volume.prototype.symlinkSync = function (target, path, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.symlinkBase(targetFilename, pathFilename);
    };
    Volume.prototype.symlink = function (target, path, a, b) {
        var _a = getArgAndCb(a, b),
            type = _a[0],
            callback = _a[1];
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
    };
    Volume.prototype.realpathBase = function (filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink) throwError(ENOENT, 'realpath', filename);
        return encoding_1.strToEncoding(realLink.getPath(), encoding);
    };
    Volume.prototype.realpathSync = function (path, options) {
        return this.realpathBase(pathToFilename(path), getRealpathOptions(options).encoding);
    };
    Volume.prototype.realpath = function (path, a, b) {
        var _a = getRealpathOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        var pathFilename = pathToFilename(path);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
    };
    Volume.prototype.lstatBase = function (filename, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var link = this.getLink(filenameToSteps(filename));
        if (!link) throwError(ENOENT, 'lstat', filename);
        return Stats_1.default.build(link.getNode(), bigint);
    };
    Volume.prototype.lstatSync = function (path, options) {
        return this.lstatBase(pathToFilename(path), getStatOptions(options).bigint);
    };
    Volume.prototype.lstat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path), opts.bigint], callback);
    };
    Volume.prototype.statBase = function (filename, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var link = this.getResolvedLink(filenameToSteps(filename));
        if (!link) throwError(ENOENT, 'stat', filename);
        return Stats_1.default.build(link.getNode(), bigint);
    };
    Volume.prototype.statSync = function (path, options) {
        return this.statBase(pathToFilename(path), getStatOptions(options).bigint);
    };
    Volume.prototype.stat = function (path, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.statBase, [pathToFilename(path), opts.bigint], callback);
    };
    Volume.prototype.fstatBase = function (fd, bigint) {
        if (bigint === void 0) {
            bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file) throwError(EBADF, 'fstat');
        return Stats_1.default.build(file.node, bigint);
    };
    Volume.prototype.fstatSync = function (fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
    };
    Volume.prototype.fstat = function (fd, a, b) {
        var _a = getStatOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
    };
    Volume.prototype.renameBase = function (oldPathFilename, newPathFilename) {
        var link = this.getLink(filenameToSteps(oldPathFilename));
        if (!link) throwError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Check if it is directory, if non-empty, we cannot move it, right?
        var newPathSteps = filenameToSteps(newPathFilename);
        // Check directory exists for the new location.
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink) throwError(ENOENT, 'rename', oldPathFilename, newPathFilename);
        // TODO: Also treat cases with directories and symbolic links.
        // TODO: See: http://man7.org/linux/man-pages/man2/rename.2.html
        // Remove hard link from old folder.
        var oldLinkParent = link.parent;
        if (oldLinkParent) {
            oldLinkParent.deleteChild(link);
        }
        // Rename should overwrite the new path, if that exists.
        var name = newPathSteps[newPathSteps.length - 1];
        link.steps = __spreadArrays(newPathDirLink.steps, [name]);
        newPathDirLink.setChild(link.getName(), link);
    };
    Volume.prototype.renameSync = function (oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
    };
    Volume.prototype.rename = function (oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
    };
    Volume.prototype.existsBase = function (filename) {
        return !!this.statBase(filename);
    };
    Volume.prototype.existsSync = function (path) {
        try {
            return this.existsBase(pathToFilename(path));
        } catch (err) {
            return false;
        }
    };
    Volume.prototype.exists = function (path, callback) {
        var _this = this;
        var filename = pathToFilename(path);
        if (typeof callback !== 'function') throw Error(ERRSTR.CB);
        setImmediate_1.default(function () {
            try {
                callback(_this.existsBase(filename));
            } catch (err) {
                callback(false);
            }
        });
    };
    Volume.prototype.accessBase = function (filename, mode) {
        var link = this.getLinkOrThrow(filename, 'access');
        // TODO: Verify permissions
    };
    Volume.prototype.accessSync = function (path, mode) {
        if (mode === void 0) {
            mode = F_OK;
        }
        var filename = pathToFilename(path);
        mode = mode | 0;
        this.accessBase(filename, mode);
    };
    Volume.prototype.access = function (path, a, b) {
        var mode = a;
        var callback = b;
        if (typeof mode === 'function') {
            mode = F_OK;
            callback = a;
        }
        var filename = pathToFilename(path);
        mode = mode | 0;
        this.wrapAsync(this.accessBase, [filename, mode], callback);
    };
    Volume.prototype.appendFileSync = function (id, data, options) {
        if (options === void 0) {
            options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id)) opts.flag = 'a';
        this.writeFileSync(id, data, opts);
    };
    Volume.prototype.appendFile = function (id, data, a, b) {
        var _a = getAppendFileOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        // force append behavior when using a supplied file descriptor
        if (!opts.flag || isFd(id)) opts.flag = 'a';
        this.writeFile(id, data, opts, callback);
    };
    Volume.prototype.readdirBase = function (filename, options) {
        var steps = filenameToSteps(filename);
        var link = this.getResolvedLink(steps);
        if (!link) throwError(ENOENT, 'readdir', filename);
        var node = link.getNode();
        if (!node.isDirectory()) throwError(ENOTDIR, 'scandir', filename);
        if (options.withFileTypes) {
            var list_1 = [];
            for (var name_3 in link.children) {
                list_1.push(Dirent_1.default.build(link.children[name_3], options.encoding));
            }
            if (!isWin && options.encoding !== 'buffer') list_1.sort(function (a, b) {
                if (a.name < b.name) return -1;
                if (a.name > b.name) return 1;
                return 0;
            });
            return list_1;
        }
        var list = [];
        for (var name_4 in link.children) {
            list.push(encoding_1.strToEncoding(name_4, options.encoding));
        }
        if (!isWin && options.encoding !== 'buffer') list.sort();
        return list;
    };
    Volume.prototype.readdirSync = function (path, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path);
        return this.readdirBase(filename, opts);
    };
    Volume.prototype.readdir = function (path, a, b) {
        var _a = getReaddirOptsAndCb(a, b),
            options = _a[0],
            callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
    };
    Volume.prototype.readlinkBase = function (filename, encoding) {
        var link = this.getLinkOrThrow(filename, 'readlink');
        var node = link.getNode();
        if (!node.isSymlink()) throwError(EINVAL, 'readlink', filename);
        var str = sep + node.symlink.join(sep);
        return encoding_1.strToEncoding(str, encoding);
    };
    Volume.prototype.readlinkSync = function (path, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path);
        return this.readlinkBase(filename, opts.encoding);
    };
    Volume.prototype.readlink = function (path, a, b) {
        var _a = getDefaultOptsAndCb(a, b),
            opts = _a[0],
            callback = _a[1];
        var filename = pathToFilename(path);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
    };
    Volume.prototype.fsyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fsync');
    };
    Volume.prototype.fsyncSync = function (fd) {
        this.fsyncBase(fd);
    };
    Volume.prototype.fsync = function (fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
    };
    Volume.prototype.fdatasyncBase = function (fd) {
        this.getFileByFdOrThrow(fd, 'fdatasync');
    };
    Volume.prototype.fdatasyncSync = function (fd) {
        this.fdatasyncBase(fd);
    };
    Volume.prototype.fdatasync = function (fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
    };
    Volume.prototype.ftruncateBase = function (fd, len) {
        var file = this.getFileByFdOrThrow(fd, 'ftruncate');
        file.truncate(len);
    };
    Volume.prototype.ftruncateSync = function (fd, len) {
        this.ftruncateBase(fd, len);
    };
    Volume.prototype.ftruncate = function (fd, a, b) {
        var _a = getArgAndCb(a, b),
            len = _a[0],
            callback = _a[1];
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
    };
    Volume.prototype.truncateBase = function (path, len) {
        var fd = this.openSync(path, 'r+');
        try {
            this.ftruncateSync(fd, len);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.truncateSync = function (id, len) {
        if (isFd(id)) return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
    };
    Volume.prototype.truncate = function (id, a, b) {
        if (isFd(id)) return this.ftruncate(id, a, b);
        var _a = getArgAndCb(a, b, 0),
            len = _a[0],
            callback = _a[1];
        this.wrapAsync(this.truncateBase, [id, len], callback);
    };
    Volume.prototype.futimesBase = function (fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, 'futimes');
        var node = file.node;
        node.atime = new Date(atime * 1000);
        node.mtime = new Date(mtime * 1000);
    };
    Volume.prototype.futimesSync = function (fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.futimes = function (fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.utimesBase = function (filename, atime, mtime) {
        var fd = this.openSync(filename, 'r+');
        try {
            this.futimesBase(fd, atime, mtime);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.utimesSync = function (path, atime, mtime) {
        this.utimesBase(pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime));
    };
    Volume.prototype.utimes = function (path, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
    };
    Volume.prototype.mkdirBase = function (filename, modeNum) {
        var steps = filenameToSteps(filename);
        // This will throw if user tries to create root dir `fs.mkdirSync('/')`.
        if (!steps.length) {
            throwError(EISDIR, 'mkdir', filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, 'mkdir');
        // Check path already exists.
        var name = steps[steps.length - 1];
        if (dir.getChild(name)) throwError(EEXIST, 'mkdir', filename);
        dir.createChild(name, this.createNode(true, modeNum));
    };
    /**
     * Creates directory tree recursively.
     * @param filename
     * @param modeNum
     */
    Volume.prototype.mkdirpBase = function (filename, modeNum) {
        var steps = filenameToSteps(filename);
        var link = this.root;
        for (var i = 0; i < steps.length; i++) {
            var step = steps[i];
            if (!link.getNode().isDirectory()) throwError(ENOTDIR, 'mkdir', link.getPath());
            var child = link.getChild(step);
            if (child) {
                if (child.getNode().isDirectory()) link = child;else throwError(ENOTDIR, 'mkdir', child.getPath());
            } else {
                link = link.createChild(step, this.createNode(true, modeNum));
            }
        }
    };
    Volume.prototype.mkdirSync = function (path, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive) this.mkdirpBase(filename, modeNum);else this.mkdirBase(filename, modeNum);
    };
    Volume.prototype.mkdir = function (path, a, b) {
        var _a = getArgAndCb(a, b),
            options = _a[0],
            callback = _a[1];
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path);
        if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
    };
    // legacy interface
    Volume.prototype.mkdirpSync = function (path, mode) {
        this.mkdirSync(path, { mode: mode, recursive: true });
    };
    Volume.prototype.mkdirp = function (path, a, b) {
        var _a = getArgAndCb(a, b),
            mode = _a[0],
            callback = _a[1];
        this.mkdir(path, { mode: mode, recursive: true }, callback);
    };
    Volume.prototype.mkdtempBase = function (prefix, encoding, retry) {
        if (retry === void 0) {
            retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
            this.mkdirBase(filename, 511 /* DIR */);
            return encoding_1.strToEncoding(filename, encoding);
        } catch (err) {
            if (err.code === EEXIST) {
                if (retry > 1) this.mkdtempBase(prefix, encoding, retry - 1);else throw Error('Could not create temp dir.');
            } else throw err;
        }
    };
    Volume.prototype.mkdtempSync = function (prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
        if (!nullCheck(prefix)) return;
        return this.mkdtempBase(prefix, encoding);
    };
    Volume.prototype.mkdtemp = function (prefix, a, b) {
        var _a = getDefaultOptsAndCb(a, b),
            encoding = _a[0].encoding,
            callback = _a[1];
        if (!prefix || typeof prefix !== 'string') throw new TypeError('filename prefix is required');
        if (!nullCheck(prefix)) return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
    };
    Volume.prototype.rmdirBase = function (filename) {
        var link = this.getLinkAsDirOrThrow(filename, 'rmdir');
        // Check directory is empty.
        if (link.length) throwError(ENOTEMPTY, 'rmdir', filename);
        this.deleteLink(link);
    };
    Volume.prototype.rmdirSync = function (path) {
        this.rmdirBase(pathToFilename(path));
    };
    Volume.prototype.rmdir = function (path, callback) {
        this.wrapAsync(this.rmdirBase, [pathToFilename(path)], callback);
    };
    Volume.prototype.fchmodBase = function (fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, 'fchmod');
        file.chmod(modeNum);
    };
    Volume.prototype.fchmodSync = function (fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
    };
    Volume.prototype.fchmod = function (fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
    };
    Volume.prototype.chmodBase = function (filename, modeNum) {
        var fd = this.openSync(filename, 'r+');
        try {
            this.fchmodBase(fd, modeNum);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.chmodSync = function (path, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.chmodBase(filename, modeNum);
    };
    Volume.prototype.chmod = function (path, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
    };
    Volume.prototype.lchmodBase = function (filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
            this.fchmodBase(fd, modeNum);
        } finally {
            this.closeSync(fd);
        }
    };
    Volume.prototype.lchmodSync = function (path, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.lchmodBase(filename, modeNum);
    };
    Volume.prototype.lchmod = function (path, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
    };
    Volume.prototype.fchownBase = function (fd, uid, gid) {
        this.getFileByFdOrThrow(fd, 'fchown').chown(uid, gid);
    };
    Volume.prototype.fchownSync = function (fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
    };
    Volume.prototype.fchown = function (fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
    };
    Volume.prototype.chownBase = function (filename, uid, gid) {
        var link = this.getResolvedLinkOrThrow(filename, 'chown');
        var node = link.getNode();
        node.chown(uid, gid);
        // if(node.isFile() || node.isSymlink()) {
        //
        // } else if(node.isDirectory()) {
        //
        // } else {
        // TODO: What do we do here?
        // }
    };
    Volume.prototype.chownSync = function (path, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path), uid, gid);
    };
    Volume.prototype.chown = function (path, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path), uid, gid], callback);
    };
    Volume.prototype.lchownBase = function (filename, uid, gid) {
        this.getLinkOrThrow(filename, 'lchown').getNode().chown(uid, gid);
    };
    Volume.prototype.lchownSync = function (path, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path), uid, gid);
    };
    Volume.prototype.lchown = function (path, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path), uid, gid], callback);
    };
    Volume.prototype.watchFile = function (path, a, b) {
        var filename = pathToFilename(path);
        var options = a;
        var listener = b;
        if (typeof options === 'function') {
            listener = a;
            options = null;
        }
        if (typeof listener !== 'function') {
            throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && (typeof options === "undefined" ? "undefined" : _typeof(options)) === 'object') {
            if (typeof options.interval === 'number') interval = options.interval;
            if (typeof options.persistent === 'boolean') persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
            watcher = new this.StatWatcher();
            watcher.start(filename, persistent, interval);
            this.statWatchers[filename] = watcher;
        }
        watcher.addListener('change', listener);
        return watcher;
    };
    Volume.prototype.unwatchFile = function (path, listener) {
        var filename = pathToFilename(path);
        var watcher = this.statWatchers[filename];
        if (!watcher) return;
        if (typeof listener === 'function') {
            watcher.removeListener('change', listener);
        } else {
            watcher.removeAllListeners('change');
        }
        if (watcher.listenerCount('change') === 0) {
            watcher.stop();
            delete this.statWatchers[filename];
        }
    };
    Volume.prototype.createReadStream = function (path, options) {
        return new this.ReadStream(path, options);
    };
    Volume.prototype.createWriteStream = function (path, options) {
        return new this.WriteStream(path, options);
    };
    // watch(path: TFilePath): FSWatcher;
    // watch(path: TFilePath, options?: IWatchOptions | string): FSWatcher;
    Volume.prototype.watch = function (path, options, listener) {
        var filename = pathToFilename(path);
        if (typeof options === 'function') {
            listener = options;
            options = null;
        }
        // tslint:disable-next-line prefer-const
        var _a = getDefaultOpts(options),
            persistent = _a.persistent,
            recursive = _a.recursive,
            encoding = _a.encoding;
        if (persistent === undefined) persistent = true;
        if (recursive === undefined) recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
            watcher.addListener('change', listener);
        }
        return watcher;
    };
    /**
     * Global file descriptor counter. UNIX file descriptors start from 0 and go sequentially
     * up, so here, in order not to conflict with them, we choose some big number and descrease
     * the file descriptor of every new opened file.
     * @type {number}
     * @todo This should not be static, right?
     */
    Volume.fd = 0x7fffffff;
    return Volume;
}();
exports.Volume = Volume;
function emitStop(self) {
    self.emit('stop');
}
var StatWatcher = /** @class */function (_super) {
    __extends(StatWatcher, _super);
    function StatWatcher(vol) {
        var _this = _super.call(this) || this;
        _this.vol = null;
        _this.timeoutRef = null;
        _this.prev = null;
        _this.onInterval = function () {
            try {
                var stats = _this.vol.statSync(_this.filename);
                if (_this.hasChanged(stats)) {
                    _this.emit('change', stats, _this.prev);
                    _this.prev = stats;
                }
            } finally {
                _this.loop();
            }
        };
        _this.vol = vol;
        return _this;
    }
    StatWatcher.prototype.loop = function () {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
    };
    StatWatcher.prototype.hasChanged = function (stats) {
        // if(!this.prev) return false;
        if (stats.mtimeMs > this.prev.mtimeMs) return true;
        if (stats.nlink !== this.prev.nlink) return true;
        return false;
    };
    StatWatcher.prototype.start = function (path, persistent, interval) {
        if (persistent === void 0) {
            persistent = true;
        }
        if (interval === void 0) {
            interval = 5007;
        }
        this.filename = pathToFilename(path);
        this.setTimeout = persistent ? setTimeout : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
    };
    StatWatcher.prototype.stop = function () {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
    };
    return StatWatcher;
}(events_1.EventEmitter);
exports.StatWatcher = StatWatcher;
var pool;
function allocNewPool(poolSize) {
    pool = buffer_1.bufferAllocUnsafe(poolSize);
    pool.used = 0;
}
util.inherits(FsReadStream, stream_1.Readable);
exports.ReadStream = FsReadStream;
function FsReadStream(vol, path, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol, path, options);
    this._vol = vol;
    // a little bit bigger buffer and water marks by default
    options = extend({}, getOptions(options, {}));
    if (options.highWaterMark === undefined) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? 'r' : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === undefined ? true : options.autoClose;
    this.pos = undefined;
    this.bytesRead = 0;
    if (this.start !== undefined) {
        if (typeof this.start !== 'number') {
            throw new TypeError('"start" option must be a Number');
        }
        if (this.end === undefined) {
            this.end = Infinity;
        } else if (typeof this.end !== 'number') {
            throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
            throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
    }
    if (typeof this.fd !== 'number') this.open();
    this.on('end', function () {
        if (this.autoClose) {
            if (this.destroy) this.destroy();
        }
    });
}
FsReadStream.prototype.open = function () {
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
        if (er) {
            if (self.autoClose) {
                if (self.destroy) self.destroy();
            }
            self.emit('error', er);
            return;
        }
        self.fd = fd;
        self.emit('open', fd);
        // start the flow of data.
        self.read();
    });
};
FsReadStream.prototype._read = function (n) {
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._read(n);
        });
    }
    if (this.destroyed) return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
        // discard the old pool.
        allocNewPool(this._readableState.highWaterMark);
    }
    // Grab another reference to the pool in the case that while we're
    // in the thread pool another read() finishes up the pool, and
    // allocates a new one.
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n);
    var start = pool.used;
    if (this.pos !== undefined) toRead = Math.min(this.end - this.pos + 1, toRead);
    // already read everything we were supposed to read!
    // treat as EOF.
    if (toRead <= 0) return this.push(null);
    // the actual read.
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    // move the pool positions, and internal position for reading.
    if (this.pos !== undefined) this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
        if (er) {
            if (self.autoClose && self.destroy) {
                self.destroy();
            }
            self.emit('error', er);
        } else {
            var b = null;
            if (bytesRead > 0) {
                self.bytesRead += bytesRead;
                b = thisPool.slice(start, start + bytesRead);
            }
            self.push(b);
        }
    }
};
FsReadStream.prototype._destroy = function (err, cb) {
    this.close(function (err2) {
        cb(err || err2);
    });
};
FsReadStream.prototype.close = function (cb) {
    var _this = this;
    if (cb) this.once('close', cb);
    if (this.closed || typeof this.fd !== 'number') {
        if (typeof this.fd !== 'number') {
            this.once('open', closeOnOpen);
            return;
        }
        return process_1.default.nextTick(function () {
            return _this.emit('close');
        });
    }
    this.closed = true;
    this._vol.close(this.fd, function (er) {
        if (er) _this.emit('error', er);else _this.emit('close');
    });
    this.fd = null;
};
// needed because as it will be called with arguments
// that does not match this.close() signature
function closeOnOpen(fd) {
    this.close();
}
util.inherits(FsWriteStream, stream_1.Writable);
exports.WriteStream = FsWriteStream;
function FsWriteStream(vol, path, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol, path, options);
    this._vol = vol;
    options = extend({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path);
    this.fd = options.fd === undefined ? null : options.fd;
    this.flags = options.flags === undefined ? 'w' : options.flags;
    this.mode = options.mode === undefined ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === undefined ? true : !!options.autoClose;
    this.pos = undefined;
    this.bytesWritten = 0;
    if (this.start !== undefined) {
        if (typeof this.start !== 'number') {
            throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
            throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
    }
    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== 'number') this.open();
    // dispose on finish.
    this.once('finish', function () {
        if (this.autoClose) {
            this.close();
        }
    });
}
FsWriteStream.prototype.open = function () {
    this._vol.open(this.path, this.flags, this.mode, function (er, fd) {
        if (er) {
            if (this.autoClose && this.destroy) {
                this.destroy();
            }
            this.emit('error', er);
            return;
        }
        this.fd = fd;
        this.emit('open', fd);
    }.bind(this));
};
FsWriteStream.prototype._write = function (data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer)) return this.emit('error', new Error('Invalid data'));
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._write(data, encoding, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    this._vol.write(this.fd, data, 0, data.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.autoClose && self.destroy) {
                self.destroy();
            }
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) this.pos += data.length;
};
FsWriteStream.prototype._writev = function (data, cb) {
    if (typeof this.fd !== 'number') {
        return this.once('open', function () {
            this._writev(data, cb);
        });
    }
    var self = this; // tslint:disable-line no-this-assignment
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i = 0; i < len; i++) {
        var chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function (er, bytes) {
        if (er) {
            if (self.destroy) self.destroy();
            return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) this.pos += size;
};
FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
FsWriteStream.prototype.close = FsReadStream.prototype.close;
// There is no shutdown() for files.
FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
// ---------------------------------------- FSWatcher
var FSWatcher = /** @class */function (_super) {
    __extends(FSWatcher, _super);
    function FSWatcher(vol) {
        var _this = _super.call(this) || this;
        _this._filename = '';
        _this._steps = null;
        _this._filenameEncoded = '';
        // _persistent: boolean = true;
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._link = null;
        _this._onNodeChange = function () {
            _this._emit('change');
        };
        _this._onParentChild = function (link) {
            if (link.getName() === _this._getName()) {
                _this._emit('rename');
            }
        };
        _this._emit = function (type) {
            _this.emit('change', type, _this._filenameEncoded);
        };
        _this._persist = function () {
            _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol;
        return _this;
        // TODO: Emit "error" messages when watching.
        // this._handle.onchange = function(status, eventType, filename) {
        //     if (status < 0) {
        //         self._handle.close();
        //         const error = !filename ?
        //             errnoException(status, 'Error watching file for changes:') :
        //             errnoException(status, `Error watching file ${filename} for changes:`);
        //         error.filename = filename;
        //         self.emit('error', error);
        //     } else {
        //         self.emit('change', eventType, filename);
        //     }
        // };
    }
    FSWatcher.prototype._getName = function () {
        return this._steps[this._steps.length - 1];
    };
    FSWatcher.prototype.start = function (path, persistent, recursive, encoding) {
        if (persistent === void 0) {
            persistent = true;
        }
        if (recursive === void 0) {
            recursive = false;
        }
        if (encoding === void 0) {
            encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = encoding_1.strToEncoding(this._filename);
        // this._persistent = persistent;
        this._recursive = recursive;
        this._encoding = encoding;
        try {
            this._link = this._vol.getLinkOrThrow(this._filename, 'FSWatcher');
        } catch (err) {
            var error = new Error("watch " + this._filename + " " + err.code);
            error.code = err.code;
            error.errno = err.code;
            throw error;
        }
        this._link.getNode().on('change', this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
            // parent.on('child:add', this._onParentChild);
            parent.on('child:delete', this._onParentChild);
        }
        if (persistent) this._persist();
    };
    FSWatcher.prototype.close = function () {
        clearTimeout(this._timer);
        this._link.getNode().removeListener('change', this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
            // parent.removeListener('child:add', this._onParentChild);
            parent.removeListener('child:delete', this._onParentChild);
        }
    };
    return FSWatcher;
}(events_1.EventEmitter);
exports.FSWatcher = FSWatcher;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};

// path.relative(from, to)
// posix version
exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
  // We saw a non-dot character immediately before the dot
  preDotState === 0 ||
  // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __extends = undefined && undefined.__extends || function () {
    var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
            d.__proto__ = b;
        } || function (d, b) {
            for (var p in b) {
                if (b.hasOwnProperty(p)) d[p] = b[p];
            }
        };
        return _extendStatics(d, b);
    };
    return function (d, b) {
        _extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", { value: true });
var process_1 = __webpack_require__(19);
var buffer_1 = __webpack_require__(11);
var constants_1 = __webpack_require__(4);
var events_1 = __webpack_require__(5);
var Stats_1 = __webpack_require__(10);
var S_IFMT = constants_1.constants.S_IFMT,
    S_IFDIR = constants_1.constants.S_IFDIR,
    S_IFREG = constants_1.constants.S_IFREG,
    S_IFBLK = constants_1.constants.S_IFBLK,
    S_IFCHR = constants_1.constants.S_IFCHR,
    S_IFLNK = constants_1.constants.S_IFLNK,
    S_IFIFO = constants_1.constants.S_IFIFO,
    S_IFSOCK = constants_1.constants.S_IFSOCK,
    O_APPEND = constants_1.constants.O_APPEND;
exports.SEP = '/';
/**
 * Node in a file system (like i-node, v-node).
 */
var Node = /** @class */function (_super) {
    __extends(Node, _super);
    function Node(ino, perm) {
        if (perm === void 0) {
            perm = 438;
        }
        var _this = _super.call(this) || this;
        // User ID and group ID.
        _this.uid = process_1.default.getuid();
        _this.gid = process_1.default.getgid();
        _this.atime = new Date();
        _this.mtime = new Date();
        _this.ctime = new Date();
        // data: string = '';
        _this.buf = null;
        _this.perm = 438; // Permissions `chmod`, `fchmod`
        _this.mode = S_IFREG; // S_IFDIR, S_IFREG, etc.. (file by default?)
        // Number of hard links pointing at this Node.
        _this.nlink = 1;
        // Steps to another node, if this node is a symlink.
        _this.symlink = null;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
    }
    Node.prototype.getString = function (encoding) {
        if (encoding === void 0) {
            encoding = 'utf8';
        }
        return this.getBuffer().toString(encoding);
    };
    Node.prototype.setString = function (str) {
        // this.setBuffer(bufferFrom(str, 'utf8'));
        this.buf = buffer_1.bufferFrom(str, 'utf8');
        this.touch();
    };
    Node.prototype.getBuffer = function () {
        if (!this.buf) this.setBuffer(buffer_1.bufferAllocUnsafe(0));
        return buffer_1.bufferFrom(this.buf); // Return a copy.
    };
    Node.prototype.setBuffer = function (buf) {
        this.buf = buffer_1.bufferFrom(buf); // Creates a copy of data.
        this.touch();
    };
    Node.prototype.getSize = function () {
        return this.buf ? this.buf.length : 0;
    };
    Node.prototype.setModeProperty = function (property) {
        this.mode = this.mode & ~S_IFMT | property;
    };
    Node.prototype.setIsFile = function () {
        this.setModeProperty(S_IFREG);
    };
    Node.prototype.setIsDirectory = function () {
        this.setModeProperty(S_IFDIR);
    };
    Node.prototype.setIsSymlink = function () {
        this.setModeProperty(S_IFLNK);
    };
    Node.prototype.isFile = function () {
        return (this.mode & S_IFMT) === S_IFREG;
    };
    Node.prototype.isDirectory = function () {
        return (this.mode & S_IFMT) === S_IFDIR;
    };
    Node.prototype.isSymlink = function () {
        // return !!this.symlink;
        return (this.mode & S_IFMT) === S_IFLNK;
    };
    Node.prototype.makeSymlink = function (steps) {
        this.symlink = steps;
        this.setIsSymlink();
    };
    Node.prototype.write = function (buf, off, len, pos) {
        if (off === void 0) {
            off = 0;
        }
        if (len === void 0) {
            len = buf.length;
        }
        if (pos === void 0) {
            pos = 0;
        }
        if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
        if (pos + len > this.buf.length) {
            var newBuf = buffer_1.bufferAllocUnsafe(pos + len);
            this.buf.copy(newBuf, 0, 0, this.buf.length);
            this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off, off + len);
        this.touch();
        return len;
    };
    // Returns the number of bytes read.
    Node.prototype.read = function (buf, off, len, pos) {
        if (off === void 0) {
            off = 0;
        }
        if (len === void 0) {
            len = buf.byteLength;
        }
        if (pos === void 0) {
            pos = 0;
        }
        if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
            actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
            actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off, pos, pos + actualLen);
        return actualLen;
    };
    Node.prototype.truncate = function (len) {
        if (len === void 0) {
            len = 0;
        }
        if (!len) this.buf = buffer_1.bufferAllocUnsafe(0);else {
            if (!this.buf) this.buf = buffer_1.bufferAllocUnsafe(0);
            if (len <= this.buf.length) {
                this.buf = this.buf.slice(0, len);
            } else {
                var buf = buffer_1.bufferAllocUnsafe(0);
                this.buf.copy(buf);
                buf.fill(0, len);
            }
        }
        this.touch();
    };
    Node.prototype.chmod = function (perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
    };
    Node.prototype.chown = function (uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
    };
    Node.prototype.touch = function () {
        this.mtime = new Date();
        this.emit('change', this);
    };
    Node.prototype.canRead = function (uid, gid) {
        if (uid === void 0) {
            uid = process_1.default.getuid();
        }
        if (gid === void 0) {
            gid = process_1.default.getgid();
        }
        if (this.perm & 4 /* IROTH */) {
                return true;
            }
        if (gid === this.gid) {
            if (this.perm & 32 /* IRGRP */) {
                    return true;
                }
        }
        if (uid === this.uid) {
            if (this.perm & 256 /* IRUSR */) {
                    return true;
                }
        }
        return false;
    };
    Node.prototype.canWrite = function (uid, gid) {
        if (uid === void 0) {
            uid = process_1.default.getuid();
        }
        if (gid === void 0) {
            gid = process_1.default.getgid();
        }
        if (this.perm & 2 /* IWOTH */) {
                return true;
            }
        if (gid === this.gid) {
            if (this.perm & 16 /* IWGRP */) {
                    return true;
                }
        }
        if (uid === this.uid) {
            if (this.perm & 128 /* IWUSR */) {
                    return true;
                }
        }
        return false;
    };
    Node.prototype.del = function () {
        this.emit('delete', this);
    };
    Node.prototype.toJSON = function () {
        return {
            ino: this.ino,
            uid: this.uid,
            gid: this.gid,
            atime: this.atime.getTime(),
            mtime: this.mtime.getTime(),
            ctime: this.ctime.getTime(),
            perm: this.perm,
            mode: this.mode,
            nlink: this.nlink,
            symlink: this.symlink,
            data: this.getString()
        };
    };
    return Node;
}(events_1.EventEmitter);
exports.Node = Node;
/**
 * Represents a hard link that points to an i-node `node`.
 */
var Link = /** @class */function (_super) {
    __extends(Link, _super);
    function Link(vol, parent, name) {
        var _this = _super.call(this) || this;
        _this.parent = null;
        _this.children = {};
        // Path to this node as Array: ['usr', 'bin', 'node'].
        _this.steps = [];
        // "i-node" of this hard link.
        _this.node = null;
        // "i-node" number of the node.
        _this.ino = 0;
        // Number of children.
        _this.length = 0;
        _this.vol = vol;
        _this.parent = parent;
        _this.steps = parent ? parent.steps.concat([name]) : [name];
        return _this;
    }
    Link.prototype.setNode = function (node) {
        this.node = node;
        this.ino = node.ino;
    };
    Link.prototype.getNode = function () {
        return this.node;
    };
    Link.prototype.createChild = function (name, node) {
        if (node === void 0) {
            node = this.vol.createNode();
        }
        var link = new Link(this.vol, this, name);
        link.setNode(node);
        if (node.isDirectory()) {
            // link.setChild('.', link);
            // link.getNode().nlink++;
            // link.setChild('..', this);
            // this.getNode().nlink++;
        }
        this.setChild(name, link);
        return link;
    };
    Link.prototype.setChild = function (name, link) {
        if (link === void 0) {
            link = new Link(this.vol, this, name);
        }
        this.children[name] = link;
        link.parent = this;
        this.length++;
        this.emit('child:add', link, this);
        return link;
    };
    Link.prototype.deleteChild = function (link) {
        delete this.children[link.getName()];
        this.length--;
        this.emit('child:delete', link, this);
    };
    Link.prototype.getChild = function (name) {
        if (Object.hasOwnProperty.call(this.children, name)) {
            return this.children[name];
        }
    };
    Link.prototype.getPath = function () {
        return this.steps.join(exports.SEP);
    };
    Link.prototype.getName = function () {
        return this.steps[this.steps.length - 1];
    };
    // del() {
    //     const parent = this.parent;
    //     if(parent) {
    //         parent.deleteChild(link);
    //     }
    //     this.parent = null;
    //     this.vol = null;
    // }
    /**
     * Walk the tree path and return the `Link` at that location, if any.
     * @param steps {string[]} Desired location.
     * @param stop {number} Max steps to go into.
     * @param i {number} Current step in the `steps` array.
     * @returns {any}
     */
    Link.prototype.walk = function (steps, stop, i) {
        if (stop === void 0) {
            stop = steps.length;
        }
        if (i === void 0) {
            i = 0;
        }
        if (i >= steps.length) return this;
        if (i >= stop) return this;
        var step = steps[i];
        var link = this.getChild(step);
        if (!link) return null;
        return link.walk(steps, stop, i + 1);
    };
    Link.prototype.toJSON = function () {
        return {
            steps: this.steps,
            ino: this.ino,
            children: Object.keys(this.children)
        };
    };
    return Link;
}(events_1.EventEmitter);
exports.Link = Link;
/**
 * Represents an open file (file descriptor) that points to a `Link` (Hard-link) and a `Node`.
 */
var File = /** @class */function () {
    /**
     * Open a Link-Node pair. `node` is provided separately as that might be a different node
     * rather the one `link` points to, because it might be a symlink.
     * @param link
     * @param node
     * @param flags
     * @param fd
     */
    function File(link, node, flags, fd) {
        /**
         * Hard link that this file opened.
         * @type {any}
         */
        this.link = null;
        /**
         * Reference to a `Node`.
         * @type {Node}
         */
        this.node = null;
        /**
         * A cursor/offset position in a file, where data will be written on write.
         * User can "seek" this position.
         */
        this.position = 0;
        this.link = link;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
    }
    File.prototype.getString = function (encoding) {
        if (encoding === void 0) {
            encoding = 'utf8';
        }
        return this.node.getString();
    };
    File.prototype.setString = function (str) {
        this.node.setString(str);
    };
    File.prototype.getBuffer = function () {
        return this.node.getBuffer();
    };
    File.prototype.setBuffer = function (buf) {
        this.node.setBuffer(buf);
    };
    File.prototype.getSize = function () {
        return this.node.getSize();
    };
    File.prototype.truncate = function (len) {
        this.node.truncate(len);
    };
    File.prototype.seekTo = function (position) {
        this.position = position;
    };
    File.prototype.stats = function () {
        return Stats_1.default.build(this.node);
    };
    File.prototype.write = function (buf, offset, length, position) {
        if (offset === void 0) {
            offset = 0;
        }
        if (length === void 0) {
            length = buf.length;
        }
        if (typeof position !== 'number') position = this.position;
        if (this.flags & O_APPEND) position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
    };
    File.prototype.read = function (buf, offset, length, position) {
        if (offset === void 0) {
            offset = 0;
        }
        if (length === void 0) {
            length = buf.byteLength;
        }
        if (typeof position !== 'number') position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
    };
    File.prototype.chmod = function (perm) {
        this.node.chmod(perm);
    };
    File.prototype.chown = function (uid, gid) {
        this.node.chown(uid, gid);
    };
    return File;
}();
exports.File = File;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(1)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * `setTimeoutUnref` is just like `setTimeout`,
 * only in Node's environment it will "unref" its macro task.
 */
function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(null, arguments);
    if (ref && (typeof ref === "undefined" ? "undefined" : _typeof(ref)) === 'object' && typeof ref.unref === 'function') ref.unref();
    return ref;
}
exports.default = setTimeoutUnref;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = __webpack_require__(5).EventEmitter;
var inherits = __webpack_require__(3);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(12);
Stream.Writable = __webpack_require__(49);
Stream.Duplex = __webpack_require__(50);
Stream.Transform = __webpack_require__(51);
Stream.PassThrough = __webpack_require__(52);

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

/***/ }),
/* 43 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(13).Buffer;
var util = __webpack_require__(45);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(7);
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype);

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(26);

/*<replacement>*/
var util = Object.create(__webpack_require__(6));
util.inherits = __webpack_require__(3);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(14);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(2);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(12).Transform;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(12).PassThrough;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;

function extend(a, b) {
    for (var key in b) {
        a[key] = b[key];
    }return arguments.length < 3 ? a : extend.apply(null, [a].concat(slice.call(arguments, 2)));
}

module.exports = extend;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
        s += arguments[i].length;
    }for (var r = Array(s), k = 0, i = 0; i < il; i++) {
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
        }
    }return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
function promisify(vol, fn, getResult) {
    if (getResult === void 0) {
        getResult = function getResult(input) {
            return input;
        };
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve, reject) {
            vol[fn].bind(vol).apply(void 0, __spreadArrays(args, [function (error, result) {
                if (error) return reject(error);
                return resolve(getResult(result));
            }]));
        });
    };
}
var FileHandle = /** @class */function () {
    function FileHandle(vol, fd) {
        this.vol = vol;
        this.fd = fd;
    }
    FileHandle.prototype.appendFile = function (data, options) {
        return promisify(this.vol, 'appendFile')(this.fd, data, options);
    };
    FileHandle.prototype.chmod = function (mode) {
        return promisify(this.vol, 'fchmod')(this.fd, mode);
    };
    FileHandle.prototype.chown = function (uid, gid) {
        return promisify(this.vol, 'fchown')(this.fd, uid, gid);
    };
    FileHandle.prototype.close = function () {
        return promisify(this.vol, 'close')(this.fd);
    };
    FileHandle.prototype.datasync = function () {
        return promisify(this.vol, 'fdatasync')(this.fd);
    };
    FileHandle.prototype.read = function (buffer, offset, length, position) {
        return promisify(this.vol, 'read', function (bytesRead) {
            return { bytesRead: bytesRead, buffer: buffer };
        })(this.fd, buffer, offset, length, position);
    };
    FileHandle.prototype.readFile = function (options) {
        return promisify(this.vol, 'readFile')(this.fd, options);
    };
    FileHandle.prototype.stat = function (options) {
        return promisify(this.vol, 'fstat')(this.fd, options);
    };
    FileHandle.prototype.sync = function () {
        return promisify(this.vol, 'fsync')(this.fd);
    };
    FileHandle.prototype.truncate = function (len) {
        return promisify(this.vol, 'ftruncate')(this.fd, len);
    };
    FileHandle.prototype.utimes = function (atime, mtime) {
        return promisify(this.vol, 'futimes')(this.fd, atime, mtime);
    };
    FileHandle.prototype.write = function (buffer, offset, length, position) {
        return promisify(this.vol, 'write', function (bytesWritten) {
            return { bytesWritten: bytesWritten, buffer: buffer };
        })(this.fd, buffer, offset, length, position);
    };
    FileHandle.prototype.writeFile = function (data, options) {
        return promisify(this.vol, 'writeFile')(this.fd, data, options);
    };
    return FileHandle;
}();
exports.FileHandle = FileHandle;
function createPromisesApi(vol) {
    if (typeof Promise === 'undefined') return null;
    return {
        FileHandle: FileHandle,
        access: function access(path, mode) {
            return promisify(vol, 'access')(path, mode);
        },
        appendFile: function appendFile(path, data, options) {
            return promisify(vol, 'appendFile')(path instanceof FileHandle ? path.fd : path, data, options);
        },
        chmod: function chmod(path, mode) {
            return promisify(vol, 'chmod')(path, mode);
        },
        chown: function chown(path, uid, gid) {
            return promisify(vol, 'chown')(path, uid, gid);
        },
        copyFile: function copyFile(src, dest, flags) {
            return promisify(vol, 'copyFile')(src, dest, flags);
        },
        lchmod: function lchmod(path, mode) {
            return promisify(vol, 'lchmod')(path, mode);
        },
        lchown: function lchown(path, uid, gid) {
            return promisify(vol, 'lchown')(path, uid, gid);
        },
        link: function link(existingPath, newPath) {
            return promisify(vol, 'link')(existingPath, newPath);
        },
        lstat: function lstat(path, options) {
            return promisify(vol, 'lstat')(path, options);
        },
        mkdir: function mkdir(path, options) {
            return promisify(vol, 'mkdir')(path, options);
        },
        mkdtemp: function mkdtemp(prefix, options) {
            return promisify(vol, 'mkdtemp')(prefix, options);
        },
        open: function open(path, flags, mode) {
            return promisify(vol, 'open', function (fd) {
                return new FileHandle(vol, fd);
            })(path, flags, mode);
        },
        readdir: function readdir(path, options) {
            return promisify(vol, 'readdir')(path, options);
        },
        readFile: function readFile(id, options) {
            return promisify(vol, 'readFile')(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function readlink(path, options) {
            return promisify(vol, 'readlink')(path, options);
        },
        realpath: function realpath(path, options) {
            return promisify(vol, 'realpath')(path, options);
        },
        rename: function rename(oldPath, newPath) {
            return promisify(vol, 'rename')(oldPath, newPath);
        },
        rmdir: function rmdir(path) {
            return promisify(vol, 'rmdir')(path);
        },
        stat: function stat(path, options) {
            return promisify(vol, 'stat')(path, options);
        },
        symlink: function symlink(target, path, type) {
            return promisify(vol, 'symlink')(target, path, type);
        },
        truncate: function truncate(path, len) {
            return promisify(vol, 'truncate')(path, len);
        },
        unlink: function unlink(path) {
            return promisify(vol, 'unlink')(path);
        },
        utimes: function utimes(path, atime, mtime) {
            return promisify(vol, 'utimes')(path, atime, mtime);
        },
        writeFile: function writeFile(id, data, options) {
            return promisify(vol, 'writeFile')(id instanceof FileHandle ? id.fd : id, data, options);
        }
    };
}
exports.default = createPromisesApi;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var punycode = __webpack_require__(56);
var util = __webpack_require__(58);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,


// Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


// RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


// RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


// Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),

// Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

// protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},

// protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(59);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + (typeof url === 'undefined' ? 'undefined' : _typeof(url)));
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift())) {}
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function (root) {

	/** Detect free variables */
	var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
	var freeModule = ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;
	var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
		root = freeGlobal;
	}

	/**
  * The `punycode` object.
  * @name punycode
  * @type Object
  */
	var punycode,


	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647,
	    // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	    tMin = 1,
	    tMax = 26,
	    skew = 38,
	    damp = 700,
	    initialBias = 72,
	    initialN = 128,
	    // 0x80
	delimiter = '-',
	    // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	    regexNonASCII = /[^\x20-\x7E]/,
	    // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
	    // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},


	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	    floor = Math.floor,
	    stringFromCharCode = String.fromCharCode,


	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
  * A generic error utility function.
  * @private
  * @param {String} type The error type.
  * @returns {Error} Throws a `RangeError` with the applicable error message.
  */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
  * A generic `Array#map` utility function.
  * @private
  * @param {Array} array The array to iterate over.
  * @param {Function} callback The function that gets called for every array
  * item.
  * @returns {Array} A new array of values returned by the callback function.
  */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
  * A simple `Array#map`-like wrapper to work with domain name strings or email
  * addresses.
  * @private
  * @param {String} domain The domain name or email address.
  * @param {Function} callback The function that gets called for every
  * character.
  * @returns {Array} A new string of characters returned by the callback
  * function.
  */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
  * Creates an array containing the numeric code points of each Unicode
  * character in the string. While JavaScript uses UCS-2 internally,
  * this function will convert a pair of surrogate halves (each of which
  * UCS-2 exposes as separate characters) into a single code point,
  * matching UTF-16.
  * @see `punycode.ucs2.encode`
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode.ucs2
  * @name decode
  * @param {String} string The Unicode input string (UCS-2).
  * @returns {Array} The new array of code points.
  */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) {
					// low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
  * Creates a string based on an array of numeric code points.
  * @see `punycode.ucs2.decode`
  * @memberOf punycode.ucs2
  * @name encode
  * @param {Array} codePoints The array of numeric code points.
  * @returns {String} The new Unicode string (UCS-2).
  */
	function ucs2encode(array) {
		return map(array, function (value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
  * Converts a basic code point into a digit/integer.
  * @see `digitToBasic()`
  * @private
  * @param {Number} codePoint The basic numeric code point value.
  * @returns {Number} The numeric value of a basic code point (for use in
  * representing integers) in the range `0` to `base - 1`, or `base` if
  * the code point does not represent a value.
  */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
  * Converts a digit/integer into a basic code point.
  * @see `basicToDigit()`
  * @private
  * @param {Number} digit The numeric value of a basic code point.
  * @returns {Number} The basic code point whose value (when used for
  * representing integers) is `digit`, which needs to be in the range
  * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
  * used; else, the lowercase form is used. The behavior is undefined
  * if `flag` is non-zero and `digit` has no uppercase form.
  */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
  * Bias adaptation function as per section 3.4 of RFC 3492.
  * https://tools.ietf.org/html/rfc3492#section-3.4
  * @private
  */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
  * Converts a Punycode string of ASCII-only symbols to a string of Unicode
  * symbols.
  * @memberOf punycode
  * @param {String} input The Punycode string of ASCII-only symbols.
  * @returns {String} The resulting string of Unicode symbols.
  */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,

		/** Cached calculation results */
		baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;
			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);
		}

		return ucs2encode(output);
	}

	/**
  * Converts a string of Unicode symbols (e.g. a domain name label) to a
  * Punycode string of ASCII-only symbols.
  * @memberOf punycode
  * @param {String} input The string of Unicode symbols.
  * @returns {String} The resulting Punycode string of ASCII-only symbols.
  */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],

		/** `inputLength` will hold the number of code points in `input`. */
		inputLength,

		/** Cached calculation results */
		handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base;; /* no condition */k += base) {
						t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;
		}
		return output.join('');
	}

	/**
  * Converts a Punycode string representing a domain name or an email address
  * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
  * it doesn't matter if you call it on a string that has already been
  * converted to Unicode.
  * @memberOf punycode
  * @param {String} input The Punycoded domain name or email address to
  * convert to Unicode.
  * @returns {String} The Unicode representation of the given Punycode
  * string.
  */
	function toUnicode(input) {
		return mapDomain(input, function (string) {
			return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
		});
	}

	/**
  * Converts a Unicode string representing a domain name or an email address to
  * Punycode. Only the non-ASCII parts of the domain name will be converted,
  * i.e. it doesn't matter if you call it with a domain that's already in
  * ASCII.
  * @memberOf punycode
  * @param {String} input The domain name or email address to convert, as a
  * Unicode string.
  * @returns {String} The Punycode representation of the given domain name or
  * email address.
  */
	function toASCII(input) {
		return mapDomain(input, function (string) {
			return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
		'version': '1.4.1',
		/**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if ("function" == 'function' && _typeof(__webpack_require__(27)) == 'object' && __webpack_require__(27)) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)(module), __webpack_require__(0)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(60);
exports.encode = exports.stringify = __webpack_require__(61);

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v === 'undefined' ? 'undefined' : _typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unixify = unixify;
exports.correctPath = correctPath;
var isWin = process.platform === 'win32';

function removeTrailingSeparator(str) {
  var i = str.length - 1;
  if (i < 2) {
    return str;
  }
  while (isSeparator(str, i)) {
    i--;
  }
  return str.substr(0, i + 1);
}

function isSeparator(str, i) {
  var char = str[i];
  return i > 0 && (char === '/' || isWin && char === '\\');
}

function normalizePath(str, stripTrailing) {
  if (typeof str !== 'string') {
    throw new TypeError('expected a string');
  }
  str = str.replace(/[\\\/]+/g, '/');
  if (stripTrailing !== false) {
    str = removeTrailingSeparator(str);
  }
  return str;
}

function unixify(filepath) {
  var stripTrailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (isWin) {
    filepath = normalizePath(filepath, stripTrailing);
    return filepath.replace(/^([a-zA-Z]+:|\.\/)/, '');
  }
  return filepath;
}

function correctPath(filepath) {
  return unixify(filepath.replace(/^\\\\\?\\.:\\/, '\\'));
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var fsProps = exports.fsProps = ['constants', 'F_OK', 'R_OK', 'W_OK', 'X_OK', 'Stats'];

var fsSyncMethods = exports.fsSyncMethods = ['renameSync', 'ftruncateSync', 'truncateSync', 'chownSync', 'fchownSync', 'lchownSync', 'chmodSync', 'fchmodSync', 'lchmodSync', 'statSync', 'lstatSync', 'fstatSync', 'linkSync', 'symlinkSync', 'readlinkSync', 'realpathSync', 'unlinkSync', 'rmdirSync', 'mkdirSync', 'mkdirpSync', 'readdirSync', 'closeSync', 'openSync', 'utimesSync', 'futimesSync', 'fsyncSync', 'writeSync', 'readSync', 'readFileSync', 'writeFileSync', 'appendFileSync', 'existsSync', 'accessSync', 'fdatasyncSync', 'mkdtempSync', 'copyFileSync', 'createReadStream', 'createWriteStream'];

var fsAsyncMethods = exports.fsAsyncMethods = ['rename', 'ftruncate', 'truncate', 'chown', 'fchown', 'lchown', 'chmod', 'fchmod', 'lchmod', 'stat', 'lstat', 'fstat', 'link', 'symlink', 'readlink', 'realpath', 'unlink', 'rmdir', 'mkdir', 'mkdirp', 'readdir', 'close', 'open', 'utimes', 'futimes', 'fsync', 'write', 'read', 'readFile', 'writeFile', 'appendFile', 'exists', 'access', 'fdatasync', 'mkdtemp', 'copyFile', 'watchFile', 'unwatchFile', 'watch'];

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTA0ZGExYWU0ZTY3OGJhNTBjZmYiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL1N0YXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW50ZXJuYWwvYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvRGlyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvZW5jb2RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9pbnRlcm5hbC9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9wcm9jZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2dldEJpZ0ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvdm9sdW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvc2V0VGltZW91dFVucmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwid2VicGFjazovLy91dGlsIChpZ25vcmVkKT84NDQzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Zhc3QtZXh0ZW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZzLW1vbmtleS9saWIvY29ycmVjdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZzLW1vbmtleS9saWIvdXRpbC9saXN0cy5qcyJdLCJuYW1lcyI6WyJnIiwiRnVuY3Rpb24iLCJldmFsIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiLCJwcm9jZXNzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImxlbmd0aCIsImNvbmNhdCIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwibGVuIiwicnVuIiwibmV4dFRpY2siLCJhcmdzIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJpIiwicHVzaCIsIkl0ZW0iLCJhcnJheSIsInByb3RvdHlwZSIsImFwcGx5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJuYW1lIiwiYmluZGluZyIsImN3ZCIsImNoZGlyIiwiZGlyIiwidW1hc2siLCJwbmEiLCJyZXF1aXJlIiwib2JqZWN0S2V5cyIsIk9iamVjdCIsImtleXMiLCJvYmoiLCJrZXkiLCJEdXBsZXgiLCJ1dGlsIiwiY3JlYXRlIiwiaW5oZXJpdHMiLCJSZWFkYWJsZSIsIldyaXRhYmxlIiwidiIsIm1ldGhvZCIsIm9wdGlvbnMiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiYWxsb3dIYWxmT3BlbiIsIm9uZW5kIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX3dyaXRhYmxlU3RhdGUiLCJoaWdoV2F0ZXJNYXJrIiwiZW5kZWQiLCJvbkVuZE5UIiwic2VsZiIsImVuZCIsIl9yZWFkYWJsZVN0YXRlIiwidW5kZWZpbmVkIiwiZGVzdHJveWVkIiwic2V0IiwidmFsdWUiLCJfZGVzdHJveSIsImVyciIsImNiIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwiY29uZmlndXJhYmxlIiwiVGVtcEN0b3IiLCJjb25zdGFudHMiLCJPX1JET05MWSIsIk9fV1JPTkxZIiwiT19SRFdSIiwiU19JRk1UIiwiU19JRlJFRyIsIlNfSUZESVIiLCJTX0lGQ0hSIiwiU19JRkJMSyIsIlNfSUZJRk8iLCJTX0lGTE5LIiwiU19JRlNPQ0siLCJPX0NSRUFUIiwiT19FWENMIiwiT19OT0NUVFkiLCJPX1RSVU5DIiwiT19BUFBFTkQiLCJPX0RJUkVDVE9SWSIsIk9fTk9BVElNRSIsIk9fTk9GT0xMT1ciLCJPX1NZTkMiLCJPX0RJUkVDVCIsIk9fTk9OQkxPQ0siLCJTX0lSV1hVIiwiU19JUlVTUiIsIlNfSVdVU1IiLCJTX0lYVVNSIiwiU19JUldYRyIsIlNfSVJHUlAiLCJTX0lXR1JQIiwiU19JWEdSUCIsIlNfSVJXWE8iLCJTX0lST1RIIiwiU19JV09USCIsIlNfSVhPVEgiLCJGX09LIiwiUl9PSyIsIldfT0siLCJYX09LIiwiVVZfRlNfU1lNTElOS19ESVIiLCJVVl9GU19TWU1MSU5LX0pVTkNUSU9OIiwiVVZfRlNfQ09QWUZJTEVfRVhDTCIsIlVWX0ZTX0NPUFlGSUxFX0ZJQ0xPTkUiLCJVVl9GU19DT1BZRklMRV9GSUNMT05FX0ZPUkNFIiwiQ09QWUZJTEVfRVhDTCIsIkNPUFlGSUxFX0ZJQ0xPTkUiLCJDT1BZRklMRV9GSUNMT05FX0ZPUkNFIiwiUiIsIlJlZmxlY3QiLCJSZWZsZWN0QXBwbHkiLCJ0YXJnZXQiLCJyZWNlaXZlciIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJOdW1iZXJJc05hTiIsIk51bWJlciIsImlzTmFOIiwiRXZlbnRFbWl0dGVyIiwiaW5pdCIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImNoZWNrTGlzdGVuZXIiLCJsaXN0ZW5lciIsIlR5cGVFcnJvciIsImFyZyIsIlJhbmdlRXJyb3IiLCJnZXRQcm90b3R5cGVPZiIsInNldE1heExpc3RlbmVycyIsIm4iLCJfZ2V0TWF4TGlzdGVuZXJzIiwidGhhdCIsImdldE1heExpc3RlbmVycyIsInR5cGUiLCJkb0Vycm9yIiwiZXZlbnRzIiwiZXJyb3IiLCJlciIsIm1lc3NhZ2UiLCJjb250ZXh0IiwiaGFuZGxlciIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwibSIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ1bnNoaWZ0Iiwid2FybmVkIiwidyIsIlN0cmluZyIsImVtaXR0ZXIiLCJjb3VudCIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJ3cmFwRm4iLCJfb25jZVdyYXAiLCJzdGF0ZSIsIndyYXBwZWQiLCJiaW5kIiwibGlzdCIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImFyciIsImNvcHkiLCJpbmRleCIsInBvcCIsInJldCIsImlzQXJyYXkiLCJvYmplY3RUb1N0cmluZyIsImlzQm9vbGVhbiIsImlzTnVsbCIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzU3ltYm9sIiwiaXNVbmRlZmluZWQiLCJpc1JlZ0V4cCIsInJlIiwiaXNPYmplY3QiLCJpc0RhdGUiLCJkIiwiaXNFcnJvciIsImlzRnVuY3Rpb24iLCJpc1ByaW1pdGl2ZSIsImlzQnVmZmVyIiwiQnVmZmVyIiwibyIsInRvU3RyaW5nIiwiYmFzZTY0IiwiaWVlZTc1NCIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJnbG9iYWwiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJVaW50OEFycmF5IiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJieXRlTGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwiZnJvbSIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJBcnJheUJ1ZmZlciIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0IiwiU3ltYm9sIiwic3BlY2llcyIsImFzc2VydFNpemUiLCJzaXplIiwiYWxsb2MiLCJmaWxsIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwic2xpY2UiLCJmcm9tQXJyYXlMaWtlIiwiYnl0ZU9mZnNldCIsImJ1ZmZlciIsImlzbmFuIiwiZGF0YSIsImIiLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwiYSIsIngiLCJ5IiwiTWF0aCIsIm1pbiIsInRvTG93ZXJDYXNlIiwicG9zIiwiYnVmIiwiaXNWaWV3IiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJzdGFydCIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwiaW5zcGVjdCIsInN0ciIsIm1heCIsIm1hdGNoIiwiam9pbiIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsInZhbCIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIm9mZnNldCIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsInN1YiIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiY29kZSIsImNoYXJDb2RlQXQiLCJJTlZBTElEX0JBU0U2NF9SRSIsImJhc2U2NGNsZWFuIiwic3RyaW5ndHJpbSIsInJlcGxhY2UiLCJ0cmltIiwidW5pdHMiLCJJbmZpbml0eSIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJjIiwiaGkiLCJsbyIsInRvQnl0ZUFycmF5Iiwic3JjIiwiZHN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZm9ybWF0UmVnRXhwIiwiZm9ybWF0IiwiZiIsIm9iamVjdHMiLCJKU09OIiwic3RyaW5naWZ5IiwiXyIsImRlcHJlY2F0ZSIsImZuIiwibXNnIiwibm9EZXByZWNhdGlvbiIsImRlcHJlY2F0ZWQiLCJ0aHJvd0RlcHJlY2F0aW9uIiwidHJhY2VEZXByZWNhdGlvbiIsInRyYWNlIiwiZGVidWdzIiwiZGVidWdFbnZpcm9uIiwiZGVidWdsb2ciLCJOT0RFX0RFQlVHIiwidG9VcHBlckNhc2UiLCJSZWdFeHAiLCJ0ZXN0IiwicGlkIiwib3B0cyIsImN0eCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJkZXB0aCIsImNvbG9ycyIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiY3VzdG9tSW5zcGVjdCIsInN0eWxpemVXaXRoQ29sb3IiLCJmb3JtYXRWYWx1ZSIsInN0eWxlcyIsInN0eWxlVHlwZSIsInN0eWxlIiwiYXJyYXlUb0hhc2giLCJoYXNoIiwiZm9yRWFjaCIsImlkeCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJEYXRlIiwiYmFzZSIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJtYXAiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwibCIsImhhc093blByb3BlcnR5IiwiZGVzYyIsInNwbGl0IiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImN1ciIsImFyIiwicGFkIiwibW9udGhzIiwidGltZXN0YW1wIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJsb2ciLCJvcmlnaW4iLCJhZGQiLCJwcm9wIiwia0N1c3RvbVByb21pc2lmaWVkU3ltYm9sIiwicHJvbWlzaWZ5Iiwib3JpZ2luYWwiLCJwcm9taXNlUmVzb2x2ZSIsInByb21pc2VSZWplY3QiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJzZXRQcm90b3R5cGVPZiIsImRlZmluZVByb3BlcnRpZXMiLCJjdXN0b20iLCJjYWxsYmFja2lmeU9uUmVqZWN0ZWQiLCJyZWFzb24iLCJuZXdSZWFzb24iLCJjYWxsYmFja2lmeSIsImNhbGxiYWNraWZpZWQiLCJtYXliZUNiIiwidGhlbiIsInJlaiIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFmdGVyVGlja09uZSIsImFmdGVyVGlja1R3byIsImFmdGVyVGlja1RocmVlIiwiYWZ0ZXJUaWNrIiwiY29uc3RhbnRzXzEiLCJnZXRCaWdJbnRfMSIsIlN0YXRzIiwiYnVpbGQiLCJub2RlIiwiYmlnaW50Iiwic3RhdHMiLCJ1aWQiLCJnaWQiLCJhdGltZSIsIm10aW1lIiwiY3RpbWUiLCJnZXRTdGF0TnVtYmVyIiwibnVtYmVyIiwiZGVmYXVsdCIsInJkZXYiLCJibGtzaXplIiwiaW5vIiwiZ2V0U2l6ZSIsImJsb2NrcyIsImJpcnRodGltZSIsImF0aW1lTXMiLCJnZXRUaW1lIiwibXRpbWVNcyIsImN0aW1lTXMiLCJiaXJ0aHRpbWVNcyIsImRldiIsIm1vZGUiLCJubGluayIsIl9jaGVja01vZGVQcm9wZXJ0eSIsInByb3BlcnR5IiwiaXNEaXJlY3RvcnkiLCJpc0ZpbGUiLCJpc0Jsb2NrRGV2aWNlIiwiaXNDaGFyYWN0ZXJEZXZpY2UiLCJpc1N5bWJvbGljTGluayIsImlzRklGTyIsImlzU29ja2V0IiwiX19zcHJlYWRBcnJheXMiLCJzIiwiaWwiLCJyIiwiayIsImpsIiwiYnVmZmVyXzEiLCJidWZmZXJWMFAxMlBvbnlmaWxsIiwiYXJnMCIsIl9pIiwiYnVmZmVyQWxsb2NVbnNhZmUiLCJidWZmZXJGcm9tIiwiU3RyZWFtIiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiV3JpdGVSZXEiLCJjaHVuayIsImNhbGxiYWNrIiwibmV4dCIsIkNvcmtlZFJlcXVlc3QiLCJfdGhpcyIsImVudHJ5IiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwic2V0SW1tZWRpYXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlc3Ryb3lJbXBsIiwibm9wIiwic3RyZWFtIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwiaHdtIiwid3JpdGFibGVId20iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwiZmluYWxDYWxsZWQiLCJuZWVkRHJhaW4iLCJlbmRpbmciLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsImRlZmF1bHRFbmNvZGluZyIsIndyaXRpbmciLCJjb3JrZWQiLCJzeW5jIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwicHJlZmluaXNoZWQiLCJlcnJvckVtaXR0ZWQiLCJidWZmZXJlZFJlcXVlc3RDb3VudCIsImNvcmtlZFJlcXVlc3RzRnJlZSIsImdldEJ1ZmZlciIsImN1cnJlbnQiLCJyZWFsSGFzSW5zdGFuY2UiLCJoYXNJbnN0YW5jZSIsIm9iamVjdCIsIl93cml0ZSIsIndyaXRldiIsIl93cml0ZXYiLCJkZXN0cm95IiwiZmluYWwiLCJfZmluYWwiLCJwaXBlIiwid3JpdGVBZnRlckVuZCIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsImlzQnVmIiwid3JpdGVPckJ1ZmZlciIsImNvcmsiLCJ1bmNvcmsiLCJjbGVhckJ1ZmZlciIsInNldERlZmF1bHRFbmNvZGluZyIsImRlY29kZUNodW5rIiwibmV3Q2h1bmsiLCJsYXN0IiwiZG9Xcml0ZSIsIm9ud3JpdGVFcnJvciIsImZpbmlzaE1heWJlIiwib253cml0ZVN0YXRlVXBkYXRlIiwibmVlZEZpbmlzaCIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJob2xkZXIiLCJhbGxCdWZmZXJzIiwiZW5kV3JpdGFibGUiLCJjYWxsRmluYWwiLCJwcmVmaW5pc2giLCJuZWVkIiwiY29ya1JlcSIsIl91bmRlc3Ryb3kiLCJ1bmRlc3Ryb3kiLCJlbmNvZGluZ18xIiwiRGlyZW50IiwibGluayIsImRpcmVudCIsImdldE5vZGUiLCJzdHJUb0VuY29kaW5nIiwiZ2V0TmFtZSIsImVycm9ycyIsIkVOQ09ESU5HX1VURjgiLCJhc3NlcnRFbmNvZGluZyIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJwIiwiX18iLCJrQ29kZSIsIm1lc3NhZ2VzIiwiYXNzZXJ0IiwibWFrZU5vZGVFcnJvciIsIkJhc2UiLCJfc3VwZXIiLCJOb2RlRXJyb3IiLCJBc3NlcnRpb25FcnJvciIsIm9wZXJhdG9yIiwiZXhwZWN0ZWQiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzdGFja1N0YXJ0RnVuY3Rpb24iLCJzdHJpY3RFcXVhbCIsImZtdCIsIkUiLCJzeW0iLCJidWZmZXJPdXRPZkJvdW5kcyIsInNlcnZlcnMiLCJlbmMiLCJpbnZhbGlkQXJnVHlwZSIsIm9uZU9mIiwibWlzc2luZ0FyZ3MiLCJkZXRlcm1pbmVyIiwibmFtZXMiLCJ0aGluZyIsImlzV3JpdGluZyIsIm1heWJlUmV0dXJuUHJvY2VzcyIsIl9hIiwiY3JlYXRlUHJvY2VzcyIsImdldHVpZCIsImdldGdpZCIsImVtaXRXYXJuaW5nIiwiX3NldEltbWVkaWF0ZSIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiaWQiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsInJlZiIsImVucm9sbCIsIml0ZW0iLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJSZWFkYWJsZVN0YXRlIiwiRUUiLCJFRWxpc3RlbmVyQ291bnQiLCJkZWJ1Z1V0aWwiLCJkZWJ1ZyIsIkJ1ZmZlckxpc3QiLCJTdHJpbmdEZWNvZGVyIiwia1Byb3h5RXZlbnRzIiwiZXZlbnQiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJyZWFkYWJsZUh3bSIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsInBpcGVzIiwicGlwZXNDb3VudCIsImZsb3dpbmciLCJlbmRFbWl0dGVkIiwicmVhZGluZyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsIl9yZWFkIiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJuZWVkTW9yZURhdGEiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsImhlYWQiLCJuT3JpZyIsImVuZFJlYWRhYmxlIiwiZG9SZWFkIiwiZnJvbUxpc3QiLCJlbWl0UmVhZGFibGVfIiwiZmxvdyIsIm1heWJlUmVhZE1vcmVfIiwiZGVzdCIsInBpcGVPcHRzIiwiZG9FbmQiLCJzdGRvdXQiLCJzdGRlcnIiLCJlbmRGbiIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwib25kcmFpbiIsInBpcGVPbkRyYWluIiwiY2xlYW5lZFVwIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25lcnJvciIsIm9uZGF0YSIsImluY3JlYXNlZEF3YWl0RHJhaW4iLCJwYXVzZSIsInJlc3VtZSIsImRlc3RzIiwic3BsaWNlIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsIndyYXAiLCJwYXVzZWQiLCJfZnJvbUxpc3QiLCJjbGVhciIsImZyb21MaXN0UGFydGlhbCIsImhhc1N0cmluZ3MiLCJjb3B5RnJvbUJ1ZmZlclN0cmluZyIsImNvcHlGcm9tQnVmZmVyIiwibmIiLCJ0YWlsIiwiZW5kUmVhZGFibGVOVCIsInhzIiwicmVhZGFibGVEZXN0cm95ZWQiLCJ3cml0YWJsZURlc3Ryb3llZCIsImVtaXRFcnJvck5UIiwiX25vcm1hbGl6ZUVuY29kaW5nIiwicmV0cmllZCIsIm5vcm1hbGl6ZUVuY29kaW5nIiwibmVuYyIsInRleHQiLCJ1dGYxNlRleHQiLCJ1dGYxNkVuZCIsImZpbGxMYXN0IiwidXRmOEZpbGxMYXN0IiwiYmFzZTY0VGV4dCIsImJhc2U2NEVuZCIsInNpbXBsZVdyaXRlIiwic2ltcGxlRW5kIiwibGFzdE5lZWQiLCJsYXN0VG90YWwiLCJsYXN0Q2hhciIsInV0ZjhFbmQiLCJ1dGY4VGV4dCIsInV0ZjhDaGVja0J5dGUiLCJieXRlIiwidXRmOENoZWNrSW5jb21wbGV0ZSIsInV0ZjhDaGVja0V4dHJhQnl0ZXMiLCJ0b3RhbCIsImFmdGVyVHJhbnNmb3JtIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNodW5rIiwicnMiLCJuZWVkVHJhbnNmb3JtIiwid3JpdGVlbmNvZGluZyIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsImRvbmUiLCJfdGhpczIiLCJlcnIyIiwidm9sIiwiX19hc3NpZ24iLCJhc3NpZ24iLCJ0IiwiU3RhdHNfMSIsIkRpcmVudF8xIiwidm9sdW1lXzEiLCJmc1N5bmNNZXRob2RzIiwiZnNBc3luY01ldGhvZHMiLCJWb2x1bWUiLCJjcmVhdGVGc0Zyb21Wb2x1bWUiLCJmcyIsImZzU3luY01ldGhvZHNfMSIsImZzQXN5bmNNZXRob2RzXzEiLCJTdGF0V2F0Y2hlciIsIkZTV2F0Y2hlciIsIldyaXRlU3RyZWFtIiwiUmVhZFN0cmVhbSIsInByb21pc2VzIiwiX3RvVW5peFRpbWVzdGFtcCIsInRvVW5peFRpbWVzdGFtcCIsInNlbWFudGljIiwiQmlnSW50IiwiQmlnSW50Tm90U3VwcG9ydGVkIiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJleHRyYUJ5dGVzIiwicGFydHMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiYWJzIiwiTE4yIiwib2JqZWN0QXNzaWduIiwiaGFzT3duIiwicFNsaWNlIiwiZnVuY3Rpb25zSGF2ZU5hbWVzIiwicFRvU3RyaW5nIiwiYXJyYnVmIiwiRGF0YVZpZXciLCJvayIsInJlZ2V4IiwiZnVuYyIsImdldE1lc3NhZ2UiLCJmYWlsIiwic3RhY2siLCJmbl9uYW1lIiwibmV4dF9saW5lIiwic3Vic3RyaW5nIiwidHJ1bmNhdGUiLCJzb21ldGhpbmciLCJyYXduYW1lIiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIl9kZWVwRXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3QiLCJtZW1vcyIsInNvdXJjZSIsIm11bHRpbGluZSIsImxhc3RJbmRleCIsImlnbm9yZUNhc2UiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJhY3R1YWxJbmRleCIsIm9iakVxdWl2IiwiaXNBcmd1bWVudHMiLCJhY3R1YWxWaXNpdGVkT2JqZWN0cyIsImFJc0FyZ3MiLCJiSXNBcmdzIiwia2EiLCJrYiIsInNvcnQiLCJub3REZWVwRXF1YWwiLCJub3REZWVwU3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImV4cGVjdGVkRXhjZXB0aW9uIiwiaXNQcm90b3R5cGVPZiIsIl90cnlCbG9jayIsImJsb2NrIiwiX3Rocm93cyIsInNob3VsZFRocm93IiwidXNlclByb3ZpZGVkTWVzc2FnZSIsImlzVW53YW50ZWRFeGNlcHRpb24iLCJpc1VuZXhwZWN0ZWRFeGNlcHRpb24iLCJ0aHJvd3MiLCJkb2VzTm90VGhyb3ciLCJpZkVycm9yIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsInRlc3QyIiwib3JkZXIyIiwidGVzdDMiLCJsZXR0ZXIiLCJ0byIsInN5bWJvbHMiLCJwYXRoTW9kdWxlIiwibm9kZV8xIiwic2V0SW1tZWRpYXRlXzEiLCJwcm9jZXNzXzEiLCJzZXRUaW1lb3V0VW5yZWZfMSIsInN0cmVhbV8xIiwiZXZlbnRzXzEiLCJleHRlbmQiLCJwcm9taXNlc18xIiwicmVzb2x2ZUNyb3NzUGxhdGZvcm0iLCJzZXAiLCJyZWxhdGl2ZSIsInBvc2l4IiwiaXNXaW4iLCJwbGF0Zm9ybSIsImtNaW5Qb29sU3BhY2UiLCJFUlJTVFIiLCJQQVRIX1NUUiIsIkZEIiwiTU9ERV9JTlQiLCJDQiIsIlVJRCIsIkdJRCIsIkxFTiIsIkFUSU1FIiwiTVRJTUUiLCJQUkVGSVgiLCJCVUZGRVIiLCJPRkZTRVQiLCJMRU5HVEgiLCJQT1NJVElPTiIsIkVSUlNUUl9PUFRTIiwidGlwZW9mIiwiRU5PRU5UIiwiRUJBREYiLCJFSU5WQUwiLCJFUEVSTSIsIkVQUk9UTyIsIkVFWElTVCIsIkVOT1RESVIiLCJFTUZJTEUiLCJFQUNDRVMiLCJFSVNESVIiLCJFTk9URU1QVFkiLCJFTk9TWVMiLCJlcnJvckNvZGUiLCJwYXRoIiwicGF0aDIiLCJwYXRoRm9ybWF0dGVkIiwiY3JlYXRlRXJyb3IiLCJDb25zdHJ1Y3RvciIsInRocm93RXJyb3IiLCJGTEFHUyIsInd4IiwiYXgiLCJmbGFnc1RvTnVtYmVyIiwiZmxhZ3MiLCJmbGFnc051bSIsImdldE9wdGlvbnMiLCJkZWZhdWx0cyIsIm9wdHNHZW5lcmF0b3IiLCJ2YWxpZGF0ZUNhbGxiYWNrIiwib3B0c0FuZENiR2VuZXJhdG9yIiwiZ2V0T3B0cyIsIm9wdHNEZWZhdWx0cyIsImdldERlZmF1bHRPcHRzIiwiZ2V0RGVmYXVsdE9wdHNBbmRDYiIsInJlYWRGaWxlT3B0c0RlZmF1bHRzIiwiZmxhZyIsImdldFJlYWRGaWxlT3B0aW9ucyIsIndyaXRlRmlsZURlZmF1bHRzIiwiZ2V0V3JpdGVGaWxlT3B0aW9ucyIsImFwcGVuZEZpbGVEZWZhdWx0cyIsImdldEFwcGVuZEZpbGVPcHRzIiwiZ2V0QXBwZW5kRmlsZU9wdHNBbmRDYiIsInJlYWxwYXRoRGVmYXVsdHMiLCJnZXRSZWFscGF0aE9wdGlvbnMiLCJnZXRSZWFscGF0aE9wdHNBbmRDYiIsIm1rZGlyRGVmYXVsdHMiLCJyZWN1cnNpdmUiLCJnZXRNa2Rpck9wdGlvbnMiLCJyZWFkZGlyRGVmYXVsdHMiLCJ3aXRoRmlsZVR5cGVzIiwiZ2V0UmVhZGRpck9wdGlvbnMiLCJnZXRSZWFkZGlyT3B0c0FuZENiIiwic3RhdERlZmF1bHRzIiwiZ2V0U3RhdE9wdGlvbnMiLCJnZXRTdGF0T3B0c0FuZENiIiwiZ2V0UGF0aEZyb21VUkxQb3NpeCIsInVybCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJ0aGlyZCIsImNvZGVQb2ludEF0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicGF0aFRvRmlsZW5hbWUiLCJVUkwiLCJwYXRoU3RyaW5nIiwibnVsbENoZWNrIiwiZmlsZW5hbWUiLCJfcmVzb2x2ZV8xIiwidW5peGlmeV8xIiwidW5peGlmeSIsImZpbGVuYW1lVG9TdGVwcyIsImZ1bGxQYXRoIiwiZnVsbFBhdGhTYW5zU2xhc2giLCJwYXRoVG9TdGVwcyIsImRhdGFUb1N0ciIsImRhdGFUb0J1ZmZlciIsImJ1ZmZlclRvRW5jb2RpbmciLCJfbW9kZVRvTnVtYmVyIiwiZGVmIiwibW9kZVRvTnVtYmVyIiwicmVzdWx0IiwiaXNGZCIsInZhbGlkYXRlRmQiLCJmZCIsIm5vdyIsImdldEFyZ0FuZENiIiwidmFsaWRhdGVVaWQiLCJ2YWxpZGF0ZUdpZCIsInByb3BzIiwiaW5vZGVzIiwicmVsZWFzZWRJbm9zIiwiZmRzIiwicmVsZWFzZWRGZHMiLCJtYXhGaWxlcyIsIm9wZW5GaWxlcyIsInByb21pc2VzQXBpIiwic3RhdFdhdGNoZXJzIiwiTm9kZSIsIkxpbmsiLCJGaWxlIiwicm9vdCIsImNyZWF0ZUxpbmsiLCJzZXROb2RlIiwiY3JlYXRlTm9kZSIsIl9SZWFkU3RyZWFtIiwiRnNSZWFkU3RyZWFtIiwiY2xhc3NfMSIsIl9Xcml0ZVN0cmVhbSIsIkZzV3JpdGVTdHJlYW0iLCJjbGFzc18yIiwiZnJvbUpTT04iLCJqc29uIiwicGFyZW50IiwicGVybSIsImNyZWF0ZUNoaWxkIiwiZGVsZXRlTGluayIsImRlbGV0ZUNoaWxkIiwibmV3SW5vTnVtYmVyIiwibmV3RmROdW1iZXIiLCJzZXRJc0RpcmVjdG9yeSIsImRlbGV0ZU5vZGUiLCJkZWwiLCJnZW5SbmRTdHIiLCJyYW5kb20iLCJnZXRMaW5rIiwic3RlcHMiLCJ3YWxrIiwiZ2V0TGlua09yVGhyb3ciLCJmdW5jTmFtZSIsImdldFJlc29sdmVkTGluayIsImZpbGVuYW1lT3JTdGVwcyIsInN0ZXAiLCJnZXRDaGlsZCIsImlzU3ltbGluayIsInN5bWxpbmsiLCJnZXRSZXNvbHZlZExpbmtPclRocm93IiwicmVzb2x2ZVN5bWxpbmtzIiwiZ2V0TGlua0FzRGlyT3JUaHJvdyIsImdldExpbmtQYXJlbnQiLCJnZXRMaW5rUGFyZW50QXNEaXJPclRocm93IiwiZ2V0RmlsZUJ5RmQiLCJnZXRGaWxlQnlGZE9yVGhyb3ciLCJmaWxlIiwiZ2V0Tm9kZUJ5SWRPckNyZWF0ZSIsImRpckxpbmsiLCJuYW1lXzEiLCJ3cmFwQXN5bmMiLCJfdG9KU09OIiwiaXNFbXB0eSIsImNoaWxkcmVuIiwibmFtZV8yIiwiY2hpbGQiLCJnZXRQYXRoIiwiZ2V0U3RyaW5nIiwiZGlyUGF0aCIsInBhdGhzIiwiaXNSZWxhdGl2ZSIsImxpbmtzIiwicGF0aHNfMSIsImxpbmtzXzEiLCJkaXJuYW1lIiwibWtkaXJwQmFzZSIsIndyaXRlRmlsZVN5bmMiLCJyZXNldCIsIm1vdW50U3luYyIsIm1vdW50cG9pbnQiLCJvcGVuTGluayIsInJlYWxMaW5rIiwiY2FuUmVhZCIsIm9wZW5GaWxlIiwibW9kZU51bSIsIm9wZW5CYXNlIiwib3BlblN5bmMiLCJmaWxlTmFtZSIsIm9wZW4iLCJjbG9zZUZpbGUiLCJjbG9zZVN5bmMiLCJvcGVuRmlsZU9yR2V0QnlJZCIsInJlYWRCYXNlIiwicmVhZFN5bmMiLCJyZWFkRmlsZUJhc2UiLCJpc1VzZXJGZCIsInVzZXJPd25zRmQiLCJyZWFkRmlsZVN5bmMiLCJyZWFkRmlsZSIsIndyaXRlQmFzZSIsIndyaXRlU3luYyIsInRpcGEiLCJ0aXBiIiwidGlwYyIsInRpcGQiLCJ3cml0ZUZpbGVCYXNlIiwid3JpdHRlbiIsIndyaXRlRmlsZSIsImxpbmtCYXNlIiwiZmlsZW5hbWUxIiwiZmlsZW5hbWUyIiwic3RlcHMxIiwibGluazEiLCJzdGVwczIiLCJkaXIyIiwiY29weUZpbGVCYXNlIiwiZXhpc3RzU3luYyIsImNvcHlGaWxlU3luYyIsInNyY0ZpbGVuYW1lIiwiZGVzdEZpbGVuYW1lIiwiY29weUZpbGUiLCJsaW5rU3luYyIsImV4aXN0aW5nUGF0aCIsIm5ld1BhdGgiLCJleGlzdGluZ1BhdGhGaWxlbmFtZSIsIm5ld1BhdGhGaWxlbmFtZSIsInVubGlua0Jhc2UiLCJ1bmxpbmtTeW5jIiwidW5saW5rIiwic3ltbGlua0Jhc2UiLCJ0YXJnZXRGaWxlbmFtZSIsInBhdGhGaWxlbmFtZSIsInBhdGhTdGVwcyIsIm1ha2VTeW1saW5rIiwic3ltbGlua1N5bmMiLCJyZWFscGF0aEJhc2UiLCJyZWFscGF0aFN5bmMiLCJyZWFscGF0aCIsImxzdGF0QmFzZSIsImxzdGF0U3luYyIsImxzdGF0Iiwic3RhdEJhc2UiLCJzdGF0U3luYyIsInN0YXQiLCJmc3RhdEJhc2UiLCJmc3RhdFN5bmMiLCJmc3RhdCIsInJlbmFtZUJhc2UiLCJvbGRQYXRoRmlsZW5hbWUiLCJuZXdQYXRoU3RlcHMiLCJuZXdQYXRoRGlyTGluayIsIm9sZExpbmtQYXJlbnQiLCJzZXRDaGlsZCIsInJlbmFtZVN5bmMiLCJvbGRQYXRoIiwicmVuYW1lIiwiZXhpc3RzQmFzZSIsImV4aXN0cyIsImFjY2Vzc0Jhc2UiLCJhY2Nlc3NTeW5jIiwiYWNjZXNzIiwiYXBwZW5kRmlsZVN5bmMiLCJhcHBlbmRGaWxlIiwicmVhZGRpckJhc2UiLCJsaXN0XzEiLCJuYW1lXzMiLCJuYW1lXzQiLCJyZWFkZGlyU3luYyIsInJlYWRkaXIiLCJyZWFkbGlua0Jhc2UiLCJyZWFkbGlua1N5bmMiLCJyZWFkbGluayIsImZzeW5jQmFzZSIsImZzeW5jU3luYyIsImZzeW5jIiwiZmRhdGFzeW5jQmFzZSIsImZkYXRhc3luY1N5bmMiLCJmZGF0YXN5bmMiLCJmdHJ1bmNhdGVCYXNlIiwiZnRydW5jYXRlU3luYyIsImZ0cnVuY2F0ZSIsInRydW5jYXRlQmFzZSIsInRydW5jYXRlU3luYyIsImZ1dGltZXNCYXNlIiwiZnV0aW1lc1N5bmMiLCJmdXRpbWVzIiwidXRpbWVzQmFzZSIsInV0aW1lc1N5bmMiLCJ1dGltZXMiLCJta2RpckJhc2UiLCJta2RpclN5bmMiLCJta2RpciIsIm1rZGlycFN5bmMiLCJta2RpcnAiLCJta2R0ZW1wQmFzZSIsInByZWZpeCIsInJldHJ5IiwibWtkdGVtcFN5bmMiLCJta2R0ZW1wIiwicm1kaXJCYXNlIiwicm1kaXJTeW5jIiwicm1kaXIiLCJmY2htb2RCYXNlIiwiY2htb2QiLCJmY2htb2RTeW5jIiwiZmNobW9kIiwiY2htb2RCYXNlIiwiY2htb2RTeW5jIiwibGNobW9kQmFzZSIsImxjaG1vZFN5bmMiLCJsY2htb2QiLCJmY2hvd25CYXNlIiwiY2hvd24iLCJmY2hvd25TeW5jIiwiZmNob3duIiwiY2hvd25CYXNlIiwiY2hvd25TeW5jIiwibGNob3duQmFzZSIsImxjaG93blN5bmMiLCJsY2hvd24iLCJ3YXRjaEZpbGUiLCJpbnRlcnZhbCIsInBlcnNpc3RlbnQiLCJ3YXRjaGVyIiwidW53YXRjaEZpbGUiLCJzdG9wIiwiY3JlYXRlUmVhZFN0cmVhbSIsImNyZWF0ZVdyaXRlU3RyZWFtIiwid2F0Y2giLCJlbWl0U3RvcCIsInRpbWVvdXRSZWYiLCJvbkludGVydmFsIiwiaGFzQ2hhbmdlZCIsImxvb3AiLCJwb29sIiwiYWxsb2NOZXdQb29sIiwidXNlZCIsIl92b2wiLCJhdXRvQ2xvc2UiLCJieXRlc1JlYWQiLCJ0aGlzUG9vbCIsInRvUmVhZCIsIm9ucmVhZCIsImNsb3NlZCIsImNsb3NlT25PcGVuIiwiYnl0ZXNXcml0dGVuIiwiY2h1bmtzIiwiZGVzdHJveVNvb24iLCJfZmlsZW5hbWUiLCJfc3RlcHMiLCJfZmlsZW5hbWVFbmNvZGVkIiwiX3JlY3Vyc2l2ZSIsIl9lbmNvZGluZyIsIl9saW5rIiwiX29uTm9kZUNoYW5nZSIsIl9lbWl0IiwiX29uUGFyZW50Q2hpbGQiLCJfZ2V0TmFtZSIsIl9wZXJzaXN0IiwiX3RpbWVyIiwiZXJybm8iLCJub3JtYWxpemVBcnJheSIsImFsbG93QWJvdmVSb290IiwidXAiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwiY2hhckF0IiwiZmlsdGVyIiwibm9ybWFsaXplIiwiaXNBYnNvbHV0ZSIsInRyYWlsaW5nU2xhc2giLCJmcm9tUGFydHMiLCJ0b1BhcnRzIiwic2FtZVBhcnRzTGVuZ3RoIiwib3V0cHV0UGFydHMiLCJkZWxpbWl0ZXIiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJleHRuYW1lIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSIsIlNFUCIsInNldFN0cmluZyIsInRvdWNoIiwic2V0QnVmZmVyIiwic2V0TW9kZVByb3BlcnR5Iiwic2V0SXNGaWxlIiwic2V0SXNTeW1saW5rIiwiYWN0dWFsTGVuIiwiY2FuV3JpdGUiLCJzZWVrVG8iLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsImRvY3VtZW50IiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJ0YXNrIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsInBvc3RNZXNzYWdlIiwiaW1wb3J0U2NyaXB0cyIsInBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMiLCJvbGRPbk1lc3NhZ2UiLCJvbm1lc3NhZ2UiLCJpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbiIsIm1lc3NhZ2VQcmVmaXgiLCJvbkdsb2JhbE1lc3NhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwic2V0VGltZW91dFVucmVmIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiY29weUJ1ZmZlciIsImNvbmZpZyIsImxvY2FsU3RvcmFnZSIsImdldFJlc3VsdCIsImlucHV0IiwiRmlsZUhhbmRsZSIsImRhdGFzeW5jIiwiY3JlYXRlUHJvbWlzZXNBcGkiLCJwdW55Y29kZSIsInBhcnNlIiwidXJsUGFyc2UiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJ1cmxGb3JtYXQiLCJVcmwiLCJwcm90b2NvbCIsInNsYXNoZXMiLCJhdXRoIiwiaG9zdCIsInBvcnQiLCJzZWFyY2giLCJxdWVyeSIsImhyZWYiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwicXVlcnlJbmRleCIsInNwbGl0dGVyIiwidVNwbGl0Iiwic2xhc2hSZWdleCIsInJlc3QiLCJzaW1wbGVQYXRoIiwiZXhlYyIsInByb3RvIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwidG9BU0NJSSIsImgiLCJhZSIsImVzYyIsImVuY29kZVVSSUNvbXBvbmVudCIsImVzY2FwZSIsInFtIiwicmVsIiwidGtleXMiLCJ0ayIsInRrZXkiLCJya2V5cyIsInJrIiwicmtleSIsInJlbFBhdGgiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwiYXV0aEluSG9zdCIsImhhc1RyYWlsaW5nU2xhc2giLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJtYXhJbnQiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsIm1hcERvbWFpbiIsImxhYmVscyIsImVuY29kZWQiLCJ1Y3MyZGVjb2RlIiwiY291bnRlciIsImV4dHJhIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImRlY29kZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJlbmNvZGUiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJkZWZpbmUiLCJ3ZWJwYWNrUG9seWZpbGwiLCJxcyIsImVxIiwicmVnZXhwIiwibWF4S2V5cyIsImtzdHIiLCJ2c3RyIiwic3RyaW5naWZ5UHJpbWl0aXZlIiwia3MiLCJjb3JyZWN0UGF0aCIsInJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yIiwiaXNTZXBhcmF0b3IiLCJjaGFyIiwibm9ybWFsaXplUGF0aCIsInN0cmlwVHJhaWxpbmciLCJmaWxlcGF0aCIsImZzUHJvcHMiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7O1FBRUE7UUFDQTs7Ozs7Ozs7Ozs7O0FDN0RBLElBQUlBLENBQUo7O0FBRUE7QUFDQUEsSUFBSyxZQUFXO0FBQ2YsUUFBTyxJQUFQO0FBQ0EsQ0FGRyxFQUFKOztBQUlBLElBQUk7QUFDSDtBQUNBQSxLQUFJQSxLQUFLQyxTQUFTLGFBQVQsR0FBTCxJQUFrQyxDQUFDLEdBQUVDLElBQUgsRUFBUyxNQUFULENBQXRDO0FBQ0EsQ0FIRCxDQUdFLE9BQU1DLENBQU4sRUFBUztBQUNWO0FBQ0EsS0FBRyxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXJCLEVBQ0NKLElBQUlJLE1BQUo7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUFDLE9BQU9DLE9BQVAsR0FBaUJOLENBQWpCLEM7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VyxVQUF2VyxFQUFtWCxXQUFuWCxFQUFnWSxhQUFoWSxFQUErWSxPQUEvWSxDQUE5QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlMDRkYTFhZTRlNjc4YmE1MGNmZiIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uc3RhbnRzID0ge1xuICAgIE9fUkRPTkxZOiAwLFxuICAgIE9fV1JPTkxZOiAxLFxuICAgIE9fUkRXUjogMixcbiAgICBTX0lGTVQ6IDYxNDQwLFxuICAgIFNfSUZSRUc6IDMyNzY4LFxuICAgIFNfSUZESVI6IDE2Mzg0LFxuICAgIFNfSUZDSFI6IDgxOTIsXG4gICAgU19JRkJMSzogMjQ1NzYsXG4gICAgU19JRklGTzogNDA5NixcbiAgICBTX0lGTE5LOiA0MDk2MCxcbiAgICBTX0lGU09DSzogNDkxNTIsXG4gICAgT19DUkVBVDogNjQsXG4gICAgT19FWENMOiAxMjgsXG4gICAgT19OT0NUVFk6IDI1NixcbiAgICBPX1RSVU5DOiA1MTIsXG4gICAgT19BUFBFTkQ6IDEwMjQsXG4gICAgT19ESVJFQ1RPUlk6IDY1NTM2LFxuICAgIE9fTk9BVElNRTogMjYyMTQ0LFxuICAgIE9fTk9GT0xMT1c6IDEzMTA3MixcbiAgICBPX1NZTkM6IDEwNTI2NzIsXG4gICAgT19ESVJFQ1Q6IDE2Mzg0LFxuICAgIE9fTk9OQkxPQ0s6IDIwNDgsXG4gICAgU19JUldYVTogNDQ4LFxuICAgIFNfSVJVU1I6IDI1NixcbiAgICBTX0lXVVNSOiAxMjgsXG4gICAgU19JWFVTUjogNjQsXG4gICAgU19JUldYRzogNTYsXG4gICAgU19JUkdSUDogMzIsXG4gICAgU19JV0dSUDogMTYsXG4gICAgU19JWEdSUDogOCxcbiAgICBTX0lSV1hPOiA3LFxuICAgIFNfSVJPVEg6IDQsXG4gICAgU19JV09USDogMixcbiAgICBTX0lYT1RIOiAxLFxuICAgIEZfT0s6IDAsXG4gICAgUl9PSzogNCxcbiAgICBXX09LOiAyLFxuICAgIFhfT0s6IDEsXG4gICAgVVZfRlNfU1lNTElOS19ESVI6IDEsXG4gICAgVVZfRlNfU1lNTElOS19KVU5DVElPTjogMixcbiAgICBVVl9GU19DT1BZRklMRV9FWENMOiAxLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgVVZfRlNfQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbiAgICBDT1BZRklMRV9FWENMOiAxLFxuICAgIENPUFlGSUxFX0ZJQ0xPTkU6IDIsXG4gICAgQ09QWUZJTEVfRklDTE9ORV9GT1JDRTogNCxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2NvbnN0YW50cy5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZ2V0QmlnSW50XzEgPSByZXF1aXJlKFwiLi9nZXRCaWdJbnRcIik7XG52YXIgU19JRk1UID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZNVCwgU19JRkRJUiA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGRElSLCBTX0lGUkVHID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZSRUcsIFNfSUZCTEsgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkJMSywgU19JRkNIUiA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGQ0hSLCBTX0lGTE5LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZMTkssIFNfSUZJRk8gPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRklGTywgU19JRlNPQ0sgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRlNPQ0s7XG4vKipcbiAqIFN0YXRpc3RpY3MgYWJvdXQgYSBmaWxlL2RpcmVjdG9yeSwgbGlrZSBgZnMuU3RhdHNgLlxuICovXG52YXIgU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdHMoKSB7XG4gICAgfVxuICAgIFN0YXRzLmJ1aWxkID0gZnVuY3Rpb24gKG5vZGUsIGJpZ2ludCkge1xuICAgICAgICBpZiAoYmlnaW50ID09PSB2b2lkIDApIHsgYmlnaW50ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHN0YXRzID0gbmV3IFN0YXRzKCk7XG4gICAgICAgIHZhciB1aWQgPSBub2RlLnVpZCwgZ2lkID0gbm9kZS5naWQsIGF0aW1lID0gbm9kZS5hdGltZSwgbXRpbWUgPSBub2RlLm10aW1lLCBjdGltZSA9IG5vZGUuY3RpbWU7XG4gICAgICAgIHZhciBnZXRTdGF0TnVtYmVyID0gIWJpZ2ludCA/IGZ1bmN0aW9uIChudW1iZXIpIHsgcmV0dXJuIG51bWJlcjsgfSA6IGdldEJpZ0ludF8xLmRlZmF1bHQ7XG4gICAgICAgIC8vIENvcHkgYWxsIHZhbHVlcyBvbiBTdGF0cyBmcm9tIE5vZGUsIHNvIHRoYXQgaWYgTm9kZSB2YWx1ZXNcbiAgICAgICAgLy8gY2hhbmdlLCB2YWx1ZXMgb24gU3RhdHMgd291bGQgc3RpbGwgYmUgdGhlIG9sZCBvbmVzLFxuICAgICAgICAvLyBqdXN0IGxpa2UgaW4gTm9kZSBmcy5cbiAgICAgICAgc3RhdHMudWlkID0gZ2V0U3RhdE51bWJlcih1aWQpO1xuICAgICAgICBzdGF0cy5naWQgPSBnZXRTdGF0TnVtYmVyKGdpZCk7XG4gICAgICAgIHN0YXRzLnJkZXYgPSBnZXRTdGF0TnVtYmVyKDApO1xuICAgICAgICBzdGF0cy5ibGtzaXplID0gZ2V0U3RhdE51bWJlcig0MDk2KTtcbiAgICAgICAgc3RhdHMuaW5vID0gZ2V0U3RhdE51bWJlcihub2RlLmlubyk7XG4gICAgICAgIHN0YXRzLnNpemUgPSBnZXRTdGF0TnVtYmVyKG5vZGUuZ2V0U2l6ZSgpKTtcbiAgICAgICAgc3RhdHMuYmxvY2tzID0gZ2V0U3RhdE51bWJlcigxKTtcbiAgICAgICAgc3RhdHMuYXRpbWUgPSBhdGltZTtcbiAgICAgICAgc3RhdHMubXRpbWUgPSBtdGltZTtcbiAgICAgICAgc3RhdHMuY3RpbWUgPSBjdGltZTtcbiAgICAgICAgc3RhdHMuYmlydGh0aW1lID0gY3RpbWU7XG4gICAgICAgIHN0YXRzLmF0aW1lTXMgPSBnZXRTdGF0TnVtYmVyKGF0aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIHN0YXRzLm10aW1lTXMgPSBnZXRTdGF0TnVtYmVyKG10aW1lLmdldFRpbWUoKSk7XG4gICAgICAgIHZhciBjdGltZU1zID0gZ2V0U3RhdE51bWJlcihjdGltZS5nZXRUaW1lKCkpO1xuICAgICAgICBzdGF0cy5jdGltZU1zID0gY3RpbWVNcztcbiAgICAgICAgc3RhdHMuYmlydGh0aW1lTXMgPSBjdGltZU1zO1xuICAgICAgICBzdGF0cy5kZXYgPSBnZXRTdGF0TnVtYmVyKDApO1xuICAgICAgICBzdGF0cy5tb2RlID0gZ2V0U3RhdE51bWJlcihub2RlLm1vZGUpO1xuICAgICAgICBzdGF0cy5ubGluayA9IGdldFN0YXROdW1iZXIobm9kZS5ubGluayk7XG4gICAgICAgIHJldHVybiBzdGF0cztcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5fY2hlY2tNb2RlUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIChOdW1iZXIodGhpcy5tb2RlKSAmIFNfSUZNVCkgPT09IHByb3BlcnR5O1xuICAgIH07XG4gICAgU3RhdHMucHJvdG90eXBlLmlzRGlyZWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkRJUik7XG4gICAgfTtcbiAgICBTdGF0cy5wcm90b3R5cGUuaXNGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRlJFRyk7XG4gICAgfTtcbiAgICBTdGF0cy5wcm90b3R5cGUuaXNCbG9ja0RldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZCTEspO1xuICAgIH07XG4gICAgU3RhdHMucHJvdG90eXBlLmlzQ2hhcmFjdGVyRGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tNb2RlUHJvcGVydHkoU19JRkNIUik7XG4gICAgfTtcbiAgICBTdGF0cy5wcm90b3R5cGUuaXNTeW1ib2xpY0xpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGTE5LKTtcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5pc0ZJRk8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGSUZPKTtcbiAgICB9O1xuICAgIFN0YXRzLnByb3RvdHlwZS5pc1NvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZTT0NLKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0cztcbn0oKSk7XG5leHBvcnRzLlN0YXRzID0gU3RhdHM7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvU3RhdHMuanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlclwiKTtcbmV4cG9ydHMuQnVmZmVyID0gYnVmZmVyXzEuQnVmZmVyO1xuZnVuY3Rpb24gYnVmZmVyVjBQMTJQb255ZmlsbChhcmcwKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChidWZmZXJfMS5CdWZmZXIuYmluZC5hcHBseShidWZmZXJfMS5CdWZmZXIsIF9fc3ByZWFkQXJyYXlzKFt2b2lkIDAsIGFyZzBdLCBhcmdzKSkpKCk7XG59XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2NVbnNhZmUgfHwgYnVmZmVyVjBQMTJQb255ZmlsbDtcbmV4cG9ydHMuYnVmZmVyQWxsb2NVbnNhZmUgPSBidWZmZXJBbGxvY1Vuc2FmZTtcbnZhciBidWZmZXJGcm9tID0gYnVmZmVyXzEuQnVmZmVyLmZyb20gfHwgYnVmZmVyVjBQMTJQb255ZmlsbDtcbmV4cG9ydHMuYnVmZmVyRnJvbSA9IGJ1ZmZlckZyb207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2ludGVybmFsL2J1ZmZlci5qcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuL2VuY29kaW5nXCIpO1xudmFyIFNfSUZNVCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGTVQsIFNfSUZESVIgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkRJUiwgU19JRlJFRyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGUkVHLCBTX0lGQkxLID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZCTEssIFNfSUZDSFIgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkNIUiwgU19JRkxOSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGTE5LLCBTX0lGSUZPID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZJRk8sIFNfSUZTT0NLID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZTT0NLO1xuLyoqXG4gKiBBIGRpcmVjdG9yeSBlbnRyeSwgbGlrZSBgZnMuRGlyZW50YC5cbiAqL1xudmFyIERpcmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXJlbnQoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLm1vZGUgPSAwO1xuICAgIH1cbiAgICBEaXJlbnQuYnVpbGQgPSBmdW5jdGlvbiAobGluaywgZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIGRpcmVudCA9IG5ldyBEaXJlbnQoKTtcbiAgICAgICAgdmFyIG1vZGUgPSBsaW5rLmdldE5vZGUoKS5tb2RlO1xuICAgICAgICBkaXJlbnQubmFtZSA9IGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZyhsaW5rLmdldE5hbWUoKSwgZW5jb2RpbmcpO1xuICAgICAgICBkaXJlbnQubW9kZSA9IG1vZGU7XG4gICAgICAgIHJldHVybiBkaXJlbnQ7XG4gICAgfTtcbiAgICBEaXJlbnQucHJvdG90eXBlLl9jaGVja01vZGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIFNfSUZNVCkgPT09IHByb3BlcnR5O1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5pc0RpcmVjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZESVIpO1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNCbG9ja0RldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZCTEspO1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5pc0NoYXJhY3RlckRldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZDSFIpO1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5pc1N5bWJvbGljTGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrTW9kZVByb3BlcnR5KFNfSUZMTkspO1xuICAgIH07XG4gICAgRGlyZW50LnByb3RvdHlwZS5pc0ZJRk8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGSUZPKTtcbiAgICB9O1xuICAgIERpcmVudC5wcm90b3R5cGUuaXNTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja01vZGVQcm9wZXJ0eShTX0lGU09DSyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGlyZW50O1xufSgpKTtcbmV4cG9ydHMuRGlyZW50ID0gRGlyZW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gRGlyZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9EaXJlbnQuanMiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2J1ZmZlclwiKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9lcnJvcnNcIik7XG5leHBvcnRzLkVOQ09ESU5HX1VURjggPSAndXRmOCc7XG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyAmJiAhYnVmZmVyXzEuQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfT1BUX1ZBTFVFX0VOQ09ESU5HJywgZW5jb2RpbmcpO1xufVxuZXhwb3J0cy5hc3NlcnRFbmNvZGluZyA9IGFzc2VydEVuY29kaW5nO1xuZnVuY3Rpb24gc3RyVG9FbmNvZGluZyhzdHIsIGVuY29kaW5nKSB7XG4gICAgaWYgKCFlbmNvZGluZyB8fCBlbmNvZGluZyA9PT0gZXhwb3J0cy5FTkNPRElOR19VVEY4KVxuICAgICAgICByZXR1cm4gc3RyOyAvLyBVVEYtOFxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicpXG4gICAgICAgIHJldHVybiBuZXcgYnVmZmVyXzEuQnVmZmVyKHN0cik7IC8vIGBidWZmZXJgIGVuY29kaW5nXG4gICAgcmV0dXJuIG5ldyBidWZmZXJfMS5CdWZmZXIoc3RyKS50b1N0cmluZyhlbmNvZGluZyk7IC8vIEN1c3RvbSBlbmNvZGluZ1xufVxuZXhwb3J0cy5zdHJUb0VuY29kaW5nID0gc3RyVG9FbmNvZGluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvZW5jb2RpbmcuanMiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUaGUgd2hvbGUgcG9pbnQgYmVoaW5kIHRoaXMgaW50ZXJuYWwgbW9kdWxlIGlzIHRvIGFsbG93IE5vZGUuanMgdG8gbm9cbi8vIGxvbmdlciBiZSBmb3JjZWQgdG8gdHJlYXQgZXZlcnkgZXJyb3IgbWVzc2FnZSBjaGFuZ2UgYXMgYSBzZW12ZXItbWFqb3Jcbi8vIGNoYW5nZS4gVGhlIE5vZGVFcnJvciBjbGFzc2VzIGhlcmUgYWxsIGV4cG9zZSBhIGBjb2RlYCBwcm9wZXJ0eSB3aG9zZVxuLy8gdmFsdWUgc3RhdGljYWxseSBhbmQgcGVybWFuZW50bHkgaWRlbnRpZmllcyB0aGUgZXJyb3IuIFdoaWxlIHRoZSBlcnJvclxuLy8gbWVzc2FnZSBtYXkgY2hhbmdlLCB0aGUgY29kZSBzaG91bGQgbm90LlxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIga0NvZGUgPSB0eXBlb2YgU3ltYm9sID09PSAndW5kZWZpbmVkJyA/ICdfa0NvZGUnIDogU3ltYm9sKCdjb2RlJyk7XG52YXIgbWVzc2FnZXMgPSB7fTsgLy8gbmV3IE1hcCgpO1xuLy8gTGF6aWx5IGxvYWRlZFxudmFyIGFzc2VydCA9IG51bGw7XG52YXIgdXRpbCA9IG51bGw7XG5mdW5jdGlvbiBtYWtlTm9kZUVycm9yKEJhc2UpIHtcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoTm9kZUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOb2RlRXJyb3Ioa2V5KSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZShrZXksIGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IGtleTtcbiAgICAgICAgICAgIF90aGlzW2tDb2RlXSA9IGtleTtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBfc3VwZXIucHJvdG90eXBlLm5hbWUgKyBcIiBbXCIgKyBfdGhpc1trQ29kZV0gKyBcIl1cIjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTm9kZUVycm9yO1xuICAgIH0oQmFzZSkpO1xufVxudmFyIEFzc2VydGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3NlcnRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4cG9ydHMuVHlwZUVycm9yKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsICdvcHRpb25zJywgJ29iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucy5tZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHV0aWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1dGlsLmluc3BlY3Qob3B0aW9ucy5hY3R1YWwpLnNsaWNlKDAsIDEyOCkgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMub3BlcmF0b3IgKyBcIiBcIiArIHV0aWwuaW5zcGVjdChvcHRpb25zLmV4cGVjdGVkKS5zbGljZSgwLCAxMjgpKSkgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gIW9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nO1xuICAgICAgICBfdGhpcy5jb2RlID0gJ0VSUl9BU1NFUlRJT04nO1xuICAgICAgICBfdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgICAgICAgX3RoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICAgICAgICBfdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gICAgICAgIGV4cG9ydHMuRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KGdsb2JhbC5FcnJvcikpO1xuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuZnVuY3Rpb24gbWVzc2FnZShrZXksIGFyZ3MpIHtcbiAgICBpZiAoYXNzZXJ0ID09PSBudWxsKSB7XG4gICAgICAgIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuICAgIH1cbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGtleSwgJ3N0cmluZycpO1xuICAgIC8vIGNvbnN0IG1zZyA9IG1lc3NhZ2VzLmdldChrZXkpO1xuICAgIHZhciBtc2cgPSBtZXNzYWdlc1trZXldO1xuICAgIGFzc2VydChtc2csIFwiQW4gaW52YWxpZCBlcnJvciBtZXNzYWdlIGtleSB3YXMgdXNlZDogXCIgKyBrZXkgKyBcIi5cIik7XG4gICAgdmFyIGZtdDtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbXQgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodXRpbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgICAgICAgfVxuICAgICAgICBmbXQgPSB1dGlsLmZvcm1hdDtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIGFyZ3MudW5zaGlmdChtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGZtdC5hcHBseShudWxsLCBhcmdzKSk7XG59XG5leHBvcnRzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLiBPbmx5IHVzZWQgaGVyZS4gRXhwb3J0ZWRcbi8vICpvbmx5KiB0byBhbGxvdyBmb3IgdGVzdGluZy5cbmZ1bmN0aW9uIEUoc3ltLCB2YWwpIHtcbiAgICBtZXNzYWdlc1tzeW1dID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCA6IFN0cmluZyh2YWwpO1xufVxuZXhwb3J0cy5FID0gRTtcbmV4cG9ydHMuRXJyb3IgPSBtYWtlTm9kZUVycm9yKGdsb2JhbC5FcnJvcik7XG5leHBvcnRzLlR5cGVFcnJvciA9IG1ha2VOb2RlRXJyb3IoZ2xvYmFsLlR5cGVFcnJvcik7XG5leHBvcnRzLlJhbmdlRXJyb3IgPSBtYWtlTm9kZUVycm9yKGdsb2JhbC5SYW5nZUVycm9yKTtcbi8vIFRvIGRlY2xhcmUgYW4gZXJyb3IgbWVzc2FnZSwgdXNlIHRoZSBFKHN5bSwgdmFsKSBmdW5jdGlvbiBhYm92ZS4gVGhlIHN5bVxuLy8gbXVzdCBiZSBhbiB1cHBlciBjYXNlIHN0cmluZy4gVGhlIHZhbCBjYW4gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuXG4vLyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGEgc3RyaW5nLlxuLy8gRXhhbXBsZXM6XG4vLyBFKCdFWEFNUExFX0tFWTEnLCAnVGhpcyBpcyB0aGUgZXJyb3IgdmFsdWUnKTtcbi8vIEUoJ0VYQU1QTEVfS0VZMicsIChhLCBiKSA9PiByZXR1cm4gYCR7YX0gJHtifWApO1xuLy9cbi8vIE9uY2UgYW4gZXJyb3IgY29kZSBoYXMgYmVlbiBhc3NpZ25lZCwgdGhlIGNvZGUgaXRzZWxmIE1VU1QgTk9UIGNoYW5nZSBhbmRcbi8vIGFueSBnaXZlbiBlcnJvciBjb2RlIG11c3QgbmV2ZXIgYmUgcmV1c2VkIHRvIGlkZW50aWZ5IGEgZGlmZmVyZW50IGVycm9yLlxuLy9cbi8vIEFueSBlcnJvciBjb2RlIGFkZGVkIGhlcmUgc2hvdWxkIGFsc28gYmUgYWRkZWQgdG8gdGhlIGRvY3VtZW50YXRpb25cbi8vXG4vLyBOb3RlOiBQbGVhc2UgdHJ5IHRvIGtlZXAgdGhlc2UgaW4gYWxwaGFiZXRpY2FsIG9yZGVyXG5FKCdFUlJfQVJHX05PVF9JVEVSQUJMRScsICclcyBtdXN0IGJlIGl0ZXJhYmxlJyk7XG5FKCdFUlJfQVNTRVJUSU9OJywgJyVzJyk7XG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLCBidWZmZXJPdXRPZkJvdW5kcyk7XG5FKCdFUlJfQ0hJTERfQ0xPU0VEX0JFRk9SRV9SRVBMWScsICdDaGlsZCBjbG9zZWQgYmVmb3JlIHJlcGx5IHJlY2VpdmVkJyk7XG5FKCdFUlJfQ09OU09MRV9XUklUQUJMRV9TVFJFQU0nLCAnQ29uc29sZSBleHBlY3RzIGEgd3JpdGFibGUgc3RyZWFtIGluc3RhbmNlIGZvciAlcycpO1xuRSgnRVJSX0NQVV9VU0FHRScsICdVbmFibGUgdG8gb2J0YWluIGNwdSB1c2FnZSAlcycpO1xuRSgnRVJSX0ROU19TRVRfU0VSVkVSU19GQUlMRUQnLCBmdW5jdGlvbiAoZXJyLCBzZXJ2ZXJzKSB7IHJldHVybiBcImMtYXJlcyBmYWlsZWQgdG8gc2V0IHNlcnZlcnM6IFxcXCJcIiArIGVyciArIFwiXFxcIiBbXCIgKyBzZXJ2ZXJzICsgXCJdXCI7IH0pO1xuRSgnRVJSX0ZBTFNZX1ZBTFVFX1JFSkVDVElPTicsICdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG5FKCdFUlJfRU5DT0RJTkdfTk9UX1NVUFBPUlRFRCcsIGZ1bmN0aW9uIChlbmMpIHsgcmV0dXJuIFwiVGhlIFxcXCJcIiArIGVuYyArIFwiXFxcIiBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXCI7IH0pO1xuRSgnRVJSX0VOQ09ESU5HX0lOVkFMSURfRU5DT0RFRF9EQVRBJywgZnVuY3Rpb24gKGVuYykgeyByZXR1cm4gXCJUaGUgZW5jb2RlZCBkYXRhIHdhcyBub3QgdmFsaWQgZm9yIGVuY29kaW5nIFwiICsgZW5jOyB9KTtcbkUoJ0VSUl9IVFRQX0hFQURFUlNfU0VOVCcsICdDYW5ub3QgcmVuZGVyIGhlYWRlcnMgYWZ0ZXIgdGhleSBhcmUgc2VudCB0byB0aGUgY2xpZW50Jyk7XG5FKCdFUlJfSFRUUF9JTlZBTElEX1NUQVRVU19DT0RFJywgJ0ludmFsaWQgc3RhdHVzIGNvZGU6ICVzJyk7XG5FKCdFUlJfSFRUUF9UUkFJTEVSX0lOVkFMSUQnLCAnVHJhaWxlcnMgYXJlIGludmFsaWQgd2l0aCB0aGlzIHRyYW5zZmVyIGVuY29kaW5nJyk7XG5FKCdFUlJfSU5ERVhfT1VUX09GX1JBTkdFJywgJ0luZGV4IG91dCBvZiByYW5nZScpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCBpbnZhbGlkQXJnVHlwZSk7XG5FKCdFUlJfSU5WQUxJRF9BUlJBWV9MRU5HVEgnLCBmdW5jdGlvbiAobmFtZSwgbGVuLCBhY3R1YWwpIHtcbiAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIGFjdHVhbCwgJ251bWJlcicpO1xuICAgIHJldHVybiBcIlRoZSBhcnJheSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIChsZW5ndGggXCIgKyBhY3R1YWwgKyBcIikgbXVzdCBiZSBvZiBsZW5ndGggXCIgKyBsZW4gKyBcIi5cIjtcbn0pO1xuRSgnRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUnLCAnQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9DQUxMQkFDSycsICdDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbkUoJ0VSUl9JTlZBTElEX0NIQVInLCAnSW52YWxpZCBjaGFyYWN0ZXIgaW4gJXMnKTtcbkUoJ0VSUl9JTlZBTElEX0NVUlNPUl9QT1MnLCAnQ2Fubm90IHNldCBjdXJzb3Igcm93IHdpdGhvdXQgc2V0dGluZyBpdHMgY29sdW1uJyk7XG5FKCdFUlJfSU5WQUxJRF9GRCcsICdcImZkXCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9IT1NUJywgJ0ZpbGUgVVJMIGhvc3QgbXVzdCBiZSBcImxvY2FsaG9zdFwiIG9yIGVtcHR5IG9uICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9GSUxFX1VSTF9QQVRIJywgJ0ZpbGUgVVJMIHBhdGggJXMnKTtcbkUoJ0VSUl9JTlZBTElEX0hBTkRMRV9UWVBFJywgJ1RoaXMgaGFuZGxlIHR5cGUgY2Fubm90IGJlIHNlbnQnKTtcbkUoJ0VSUl9JTlZBTElEX0lQX0FERFJFU1MnLCAnSW52YWxpZCBJUCBhZGRyZXNzOiAlcycpO1xuRSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiVGhlIHZhbHVlIFxcXCJcIiArIFN0cmluZyh2YWx1ZSkgKyBcIlxcXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIjtcbn0pO1xuRSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFX0VOQ09ESU5HJywgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBcIlRoZSB2YWx1ZSBcXFwiXCIgKyBTdHJpbmcodmFsdWUpICsgXCJcXFwiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcXFwiZW5jb2RpbmdcXFwiXCI7IH0pO1xuRSgnRVJSX0lOVkFMSURfUkVQTF9FVkFMX0NPTkZJRycsICdDYW5ub3Qgc3BlY2lmeSBib3RoIFwiYnJlYWtFdmFsT25TaWdpbnRcIiBhbmQgXCJldmFsXCIgZm9yIFJFUEwnKTtcbkUoJ0VSUl9JTlZBTElEX1NZTkNfRk9SS19JTlBVVCcsICdBc3luY2hyb25vdXMgZm9ya3MgZG8gbm90IHN1cHBvcnQgQnVmZmVyLCBVaW50OEFycmF5IG9yIHN0cmluZyBpbnB1dDogJXMnKTtcbkUoJ0VSUl9JTlZBTElEX1RISVMnLCAnVmFsdWUgb2YgXCJ0aGlzXCIgbXVzdCBiZSBvZiB0eXBlICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9UVVBMRScsICclcyBtdXN0IGJlIGFuIGl0ZXJhYmxlICVzIHR1cGxlJyk7XG5FKCdFUlJfSU5WQUxJRF9VUkwnLCAnSW52YWxpZCBVUkw6ICVzJyk7XG5FKCdFUlJfSU5WQUxJRF9VUkxfU0NIRU1FJywgZnVuY3Rpb24gKGV4cGVjdGVkKSB7IHJldHVybiBcIlRoZSBVUkwgbXVzdCBiZSBcIiArIG9uZU9mKGV4cGVjdGVkLCAnc2NoZW1lJyk7IH0pO1xuRSgnRVJSX0lQQ19DSEFOTkVMX0NMT1NFRCcsICdDaGFubmVsIGNsb3NlZCcpO1xuRSgnRVJSX0lQQ19ESVNDT05ORUNURUQnLCAnSVBDIGNoYW5uZWwgaXMgYWxyZWFkeSBkaXNjb25uZWN0ZWQnKTtcbkUoJ0VSUl9JUENfT05FX1BJUEUnLCAnQ2hpbGQgcHJvY2VzcyBjYW4gaGF2ZSBvbmx5IG9uZSBJUEMgcGlwZScpO1xuRSgnRVJSX0lQQ19TWU5DX0ZPUksnLCAnSVBDIGNhbm5vdCBiZSB1c2VkIHdpdGggc3luY2hyb25vdXMgZm9ya3MnKTtcbkUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBtaXNzaW5nQXJncyk7XG5FKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5FKCdFUlJfTkFQSV9DT05TX0ZVTkNUSU9OJywgJ0NvbnN0cnVjdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuRSgnRVJSX05BUElfQ09OU19QUk9UT1RZUEVfT0JKRUNUJywgJ0NvbnN0cnVjdG9yLnByb3RvdHlwZSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuRSgnRVJSX05PX0NSWVBUTycsICdOb2RlLmpzIGlzIG5vdCBjb21waWxlZCB3aXRoIE9wZW5TU0wgY3J5cHRvIHN1cHBvcnQnKTtcbkUoJ0VSUl9OT19MT05HRVJfU1VQUE9SVEVEJywgJyVzIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbkUoJ0VSUl9QQVJTRV9ISVNUT1JZX0RBVEEnLCAnQ291bGQgbm90IHBhcnNlIGhpc3RvcnkgZGF0YSBpbiAlcycpO1xuRSgnRVJSX1NPQ0tFVF9BTFJFQURZX0JPVU5EJywgJ1NvY2tldCBpcyBhbHJlYWR5IGJvdW5kJyk7XG5FKCdFUlJfU09DS0VUX0JBRF9QT1JUJywgJ1BvcnQgc2hvdWxkIGJlID4gMCBhbmQgPCA2NTUzNicpO1xuRSgnRVJSX1NPQ0tFVF9CQURfVFlQRScsICdCYWQgc29ja2V0IHR5cGUgc3BlY2lmaWVkLiBWYWxpZCB0eXBlcyBhcmU6IHVkcDQsIHVkcDYnKTtcbkUoJ0VSUl9TT0NLRVRfQ0FOTk9UX1NFTkQnLCAnVW5hYmxlIHRvIHNlbmQgZGF0YScpO1xuRSgnRVJSX1NPQ0tFVF9DTE9TRUQnLCAnU29ja2V0IGlzIGNsb3NlZCcpO1xuRSgnRVJSX1NPQ0tFVF9ER1JBTV9OT1RfUlVOTklORycsICdOb3QgcnVubmluZycpO1xuRSgnRVJSX1NUREVSUl9DTE9TRScsICdwcm9jZXNzLnN0ZGVyciBjYW5ub3QgYmUgY2xvc2VkJyk7XG5FKCdFUlJfU1RET1VUX0NMT1NFJywgJ3Byb2Nlc3Muc3Rkb3V0IGNhbm5vdCBiZSBjbG9zZWQnKTtcbkUoJ0VSUl9TVFJFQU1fV1JBUCcsICdTdHJlYW0gaGFzIFN0cmluZ0RlY29kZXIgc2V0IG9yIGlzIGluIG9iamVjdE1vZGUnKTtcbkUoJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnLCBcIkhvc3RuYW1lL0lQIGRvZXMgbm90IG1hdGNoIGNlcnRpZmljYXRlJ3MgYWx0bmFtZXM6ICVzXCIpO1xuRSgnRVJSX1RMU19ESF9QQVJBTV9TSVpFJywgZnVuY3Rpb24gKHNpemUpIHsgcmV0dXJuIFwiREggcGFyYW1ldGVyIHNpemUgXCIgKyBzaXplICsgXCIgaXMgbGVzcyB0aGFuIDIwNDhcIjsgfSk7XG5FKCdFUlJfVExTX0hBTkRTSEFLRV9USU1FT1VUJywgJ1RMUyBoYW5kc2hha2UgdGltZW91dCcpO1xuRSgnRVJSX1RMU19SRU5FR09USUFUSU9OX0ZBSUxFRCcsICdGYWlsZWQgdG8gcmVuZWdvdGlhdGUnKTtcbkUoJ0VSUl9UTFNfUkVRVUlSRURfU0VSVkVSX05BTUUnLCAnXCJzZXJ2ZXJuYW1lXCIgaXMgcmVxdWlyZWQgcGFyYW1ldGVyIGZvciBTZXJ2ZXIuYWRkQ29udGV4dCcpO1xuRSgnRVJSX1RMU19TRVNTSU9OX0FUVEFDSycsICdUU0wgc2Vzc2lvbiByZW5lZ290aWF0aW9uIGF0dGFjayBkZXRlY3RlZCcpO1xuRSgnRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORycsICdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5FKCdFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAnLCAnQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdyaXRhYmxlU3RhdGUubGVuZ3RoICE9IDAnKTtcbkUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgJ1Vua25vd24gZW5jb2Rpbmc6ICVzJyk7XG5FKCdFUlJfVU5LTk9XTl9TSUdOQUwnLCAnVW5rbm93biBzaWduYWw6ICVzJyk7XG5FKCdFUlJfVU5LTk9XTl9TVERJTl9UWVBFJywgJ1Vua25vd24gc3RkaW4gZmlsZSB0eXBlJyk7XG5FKCdFUlJfVU5LTk9XTl9TVFJFQU1fVFlQRScsICdVbmtub3duIHN0cmVhbSBmaWxlIHR5cGUnKTtcbkUoJ0VSUl9WOEJSRUFLSVRFUkFUT1InLCAnRnVsbCBJQ1UgZGF0YSBub3QgaW5zdGFsbGVkLiAnICsgJ1NlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvd2lraS9JbnRsJyk7XG5mdW5jdGlvbiBpbnZhbGlkQXJnVHlwZShuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gICAgYXNzZXJ0KG5hbWUsICduYW1lIGlzIHJlcXVpcmVkJyk7XG4gICAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgICB2YXIgZGV0ZXJtaW5lcjtcbiAgICBpZiAoZXhwZWN0ZWQuaW5jbHVkZXMoJ25vdCAnKSkge1xuICAgICAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICAgICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5zcGxpdCgnbm90ICcpWzFdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgICB9XG4gICAgdmFyIG1zZztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBcIlxcXCJcIiArIHZhbCArIFwiXFxcIlwiOyB9KS5qb2luKCcsICcpO1xuICAgICAgICBtc2cgPSBcIlRoZSBcIiArIG5hbWVzICsgXCIgYXJndW1lbnRzIFwiICsgZGV0ZXJtaW5lciArIFwiIFwiICsgb25lT2YoZXhwZWN0ZWQsICd0eXBlJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUuaW5jbHVkZXMoJyBhcmd1bWVudCcpKSB7XG4gICAgICAgIC8vIGZvciB0aGUgY2FzZSBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICAgICAgbXNnID0gXCJUaGUgXCIgKyBuYW1lICsgXCIgXCIgKyBkZXRlcm1pbmVyICsgXCIgXCIgKyBvbmVPZihleHBlY3RlZCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0eXBlID0gbmFtZS5pbmNsdWRlcygnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgICAgIG1zZyA9IFwiVGhlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgXCIgKyB0eXBlICsgXCIgXCIgKyBkZXRlcm1pbmVyICsgXCIgXCIgKyBvbmVPZihleHBlY3RlZCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgLy8gaWYgYWN0dWFsIHZhbHVlIHJlY2VpdmVkLCBvdXRwdXQgaXRcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIG1zZyArPSBcIi4gUmVjZWl2ZWQgdHlwZSBcIiArIChhY3R1YWwgIT09IG51bGwgPyB0eXBlb2YgYWN0dWFsIDogJ251bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn1cbmZ1bmN0aW9uIG1pc3NpbmdBcmdzKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBhc3NlcnQoYXJncy5sZW5ndGggPiAwLCAnQXQgbGVhc3Qgb25lIGFyZyBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICB2YXIgbXNnID0gJ1RoZSAnO1xuICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIFwiXFxcIlwiICsgYSArIFwiXFxcIlwiOyB9KTtcbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtc2cgKz0gYXJnc1swXSArIFwiIGFyZ3VtZW50XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbXNnICs9IGFyZ3NbMF0gKyBcIiBhbmQgXCIgKyBhcmdzWzFdICsgXCIgYXJndW1lbnRzXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICAgICAgICBtc2cgKz0gXCIsIGFuZCBcIiArIGFyZ3NbbGVuIC0gMV0gKyBcIiBhcmd1bWVudHNcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbXNnICsgXCIgbXVzdCBiZSBzcGVjaWZpZWRcIjtcbn1cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICAgIGFzc2VydChleHBlY3RlZCwgJ2V4cGVjdGVkIGlzIHJlcXVpcmVkJyk7XG4gICAgYXNzZXJ0KHR5cGVvZiB0aGluZyA9PT0gJ3N0cmluZycsICd0aGluZyBpcyByZXF1aXJlZCcpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgICAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgICAgICBhc3NlcnQobGVuID4gMCwgJ0F0IGxlYXN0IG9uZSBleHBlY3RlZCB2YWx1ZSBuZWVkcyB0byBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBTdHJpbmcoaSk7IH0pO1xuICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgcmV0dXJuIFwib25lIG9mIFwiICsgdGhpbmcgKyBcIiBcIiArIGV4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJykgKyBcIiwgb3IgXCIgKyBleHBlY3RlZFtsZW4gLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm9uZSBvZiBcIiArIHRoaW5nICsgXCIgXCIgKyBleHBlY3RlZFswXSArIFwiIG9yIFwiICsgZXhwZWN0ZWRbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJvZiBcIiArIHRoaW5nICsgXCIgXCIgKyBleHBlY3RlZFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwib2YgXCIgKyB0aGluZyArIFwiIFwiICsgU3RyaW5nKGV4cGVjdGVkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWZmZXJPdXRPZkJvdW5kcyhuYW1lLCBpc1dyaXRpbmcpIHtcbiAgICBpZiAoaXNXcml0aW5nKSB7XG4gICAgICAgIHJldHVybiAnQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIjtcbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL2ludGVybmFsL2Vycm9ycy5qcyIsIlwidXNlIHN0cmljdFwiO1xuLy8gSGVyZSB3ZSBtb2NrIHRoZSBnbG9iYWwgYHByb2Nlc3NgIHZhcmlhYmxlIGluIGNhc2Ugd2UgYXJlIG5vdCBpbiBOb2RlJ3MgZW52aXJvbm1lbnQuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIExvb2tzIHRvIHJldHVybiBhIGBwcm9jZXNzYCBvYmplY3QsIGlmIG9uZSBpcyBhdmFpbGFibGUuXG4gKlxuICogVGhlIGdsb2JhbCBgcHJvY2Vzc2AgaXMgcmV0dXJuZWQgaWYgZGVmaW5lZDtcbiAqIG90aGVyd2lzZSBgcmVxdWlyZSgncHJvY2VzcycpYCBpcyBhdHRlbXB0ZWQuXG4gKlxuICogSWYgdGhhdCBmYWlscywgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHJldHVybiB7SVByb2Nlc3MgfCB1bmRlZmluZWR9XG4gKi9cbnZhciBtYXliZVJldHVyblByb2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gcHJvY2VzcztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoJ3Byb2Nlc3MnKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb2Nlc3MoKSB7XG4gICAgdmFyIHAgPSBtYXliZVJldHVyblByb2Nlc3MoKSB8fCB7fTtcbiAgICBpZiAoIXAuZ2V0dWlkKVxuICAgICAgICBwLmdldHVpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH07XG4gICAgaWYgKCFwLmdldGdpZClcbiAgICAgICAgcC5nZXRnaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwOyB9O1xuICAgIGlmICghcC5jd2QpXG4gICAgICAgIHAuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nOyB9O1xuICAgIGlmICghcC5uZXh0VGljaylcbiAgICAgICAgcC5uZXh0VGljayA9IHJlcXVpcmUoJy4vc2V0SW1tZWRpYXRlJykuZGVmYXVsdDtcbiAgICBpZiAoIXAuZW1pdFdhcm5pbmcpXG4gICAgICAgIHAuZW1pdFdhcm5pbmcgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHlwZSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgdHlwZSArICh0eXBlID8gJzogJyA6ICcnKSArIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgIGlmICghcC5lbnYpXG4gICAgICAgIHAuZW52ID0ge307XG4gICAgcmV0dXJuIHA7XG59XG5leHBvcnRzLmNyZWF0ZVByb2Nlc3MgPSBjcmVhdGVQcm9jZXNzO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlUHJvY2VzcygpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9wcm9jZXNzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX3NldEltbWVkaWF0ZTtcbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKVxuICAgIF9zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGUuYmluZChnbG9iYWwpO1xuZWxzZVxuICAgIF9zZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0LmJpbmQoZ2xvYmFsKTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9zZXRJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3NldEltbWVkaWF0ZS5qcyIsInZhciBzY29wZSA9ICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCkgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxuICAgICAgICAgICAgd2luZG93O1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgc2NvcGUsIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwoc2NvcGUsIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHt2b2wsIHdyaXRlRmlsZVN5bmMsIHJlYWRGaWxlU3luY30gZnJvbSAnZnMnO1xuXG53cml0ZUZpbGVTeW5jKCcvdGV4dC50eHQnLCAnSGVsbG8gd29ybGQhJyk7XG5jb25zb2xlLmxvZyhyZWFkRmlsZVN5bmMoJy90ZXh0LnR4dCcsICd1dGY4JykpO1xuY29uc29sZS5sb2codm9sLnRvSlNPTigpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0YXRzXzEgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcbnZhciBEaXJlbnRfMSA9IHJlcXVpcmUoXCIuL0RpcmVudFwiKTtcbnZhciB2b2x1bWVfMSA9IHJlcXVpcmUoXCIuL3ZvbHVtZVwiKTtcbnZhciBfYSA9IHJlcXVpcmUoJ2ZzLW1vbmtleS9saWIvdXRpbC9saXN0cycpLCBmc1N5bmNNZXRob2RzID0gX2EuZnNTeW5jTWV0aG9kcywgZnNBc3luY01ldGhvZHMgPSBfYS5mc0FzeW5jTWV0aG9kcztcbnZhciBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBGX09LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLkZfT0ssIFJfT0sgPSBjb25zdGFudHNfMS5jb25zdGFudHMuUl9PSywgV19PSyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5XX09LLCBYX09LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlhfT0s7XG5leHBvcnRzLlZvbHVtZSA9IHZvbHVtZV8xLlZvbHVtZTtcbi8vIERlZmF1bHQgdm9sdW1lLlxuZXhwb3J0cy52b2wgPSBuZXcgdm9sdW1lXzEuVm9sdW1lKCk7XG5mdW5jdGlvbiBjcmVhdGVGc0Zyb21Wb2x1bWUodm9sKSB7XG4gICAgdmFyIGZzID0geyBGX09LOiBGX09LLCBSX09LOiBSX09LLCBXX09LOiBXX09LLCBYX09LOiBYX09LLCBjb25zdGFudHM6IGNvbnN0YW50c18xLmNvbnN0YW50cywgU3RhdHM6IFN0YXRzXzEuZGVmYXVsdCwgRGlyZW50OiBEaXJlbnRfMS5kZWZhdWx0IH07XG4gICAgLy8gQmluZCBGUyBtZXRob2RzLlxuICAgIGZvciAodmFyIF9pID0gMCwgZnNTeW5jTWV0aG9kc18xID0gZnNTeW5jTWV0aG9kczsgX2kgPCBmc1N5bmNNZXRob2RzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBmc1N5bmNNZXRob2RzXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHZvbFttZXRob2RdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZnNbbWV0aG9kXSA9IHZvbFttZXRob2RdLmJpbmQodm9sKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBmc0FzeW5jTWV0aG9kc18xID0gZnNBc3luY01ldGhvZHM7IF9hIDwgZnNBc3luY01ldGhvZHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IGZzQXN5bmNNZXRob2RzXzFbX2FdO1xuICAgICAgICBpZiAodHlwZW9mIHZvbFttZXRob2RdID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZnNbbWV0aG9kXSA9IHZvbFttZXRob2RdLmJpbmQodm9sKTtcbiAgICB9XG4gICAgZnMuU3RhdFdhdGNoZXIgPSB2b2wuU3RhdFdhdGNoZXI7XG4gICAgZnMuRlNXYXRjaGVyID0gdm9sLkZTV2F0Y2hlcjtcbiAgICBmcy5Xcml0ZVN0cmVhbSA9IHZvbC5Xcml0ZVN0cmVhbTtcbiAgICBmcy5SZWFkU3RyZWFtID0gdm9sLlJlYWRTdHJlYW07XG4gICAgZnMucHJvbWlzZXMgPSB2b2wucHJvbWlzZXM7XG4gICAgZnMuX3RvVW5peFRpbWVzdGFtcCA9IHZvbHVtZV8xLnRvVW5peFRpbWVzdGFtcDtcbiAgICByZXR1cm4gZnM7XG59XG5leHBvcnRzLmNyZWF0ZUZzRnJvbVZvbHVtZSA9IGNyZWF0ZUZzRnJvbVZvbHVtZTtcbmV4cG9ydHMuZnMgPSBjcmVhdGVGc0Zyb21Wb2x1bWUoZXhwb3J0cy52b2wpO1xubW9kdWxlLmV4cG9ydHMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbW9kdWxlLmV4cG9ydHMpLCBleHBvcnRzLmZzKTtcbm1vZHVsZS5leHBvcnRzLnNlbWFudGljID0gdHJ1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvaW5kZXguanMiLCJpZiAodHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJykgZXhwb3J0cy5kZWZhdWx0ID0gQmlnSW50O1xuZWxzZVxuICBleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBCaWdJbnROb3RTdXBwb3J0ZWQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LicpO1xuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9nZXRCaWdJbnQuanMiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9iamVjdEFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG4vLyBOQjogVGhlIFVSTCB0byB0aGUgQ29tbW9uSlMgc3BlYyBpcyBrZXB0IGp1c3QgZm9yIHRyYWRpdGlvbi5cbi8vICAgICBub2RlLWFzc2VydCBoYXMgZXZvbHZlZCBhIGxvdCBzaW5jZSB0aGVuLCBib3RoIGluIEFQSSBhbmQgYmVoYXZpb3IuXG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG4vLyBFeHBvc2UgYSBzdHJpY3Qgb25seSB2YXJpYW50IG9mIGFzc2VydFxuZnVuY3Rpb24gc3RyaWN0KHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIHN0cmljdCk7XG59XG5hc3NlcnQuc3RyaWN0ID0gb2JqZWN0QXNzaWduKHN0cmljdCwgYXNzZXJ0LCB7XG4gIGVxdWFsOiBhc3NlcnQuc3RyaWN0RXF1YWwsXG4gIGRlZXBFcXVhbDogYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCxcbiAgbm90RXF1YWw6IGFzc2VydC5ub3RTdHJpY3RFcXVhbCxcbiAgbm90RGVlcEVxdWFsOiBhc3NlcnQubm90RGVlcFN0cmljdEVxdWFsXG59KTtcbmFzc2VydC5zdHJpY3Quc3RyaWN0ID0gYXNzZXJ0LnN0cmljdDtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYXRoTW9kdWxlID0gcmVxdWlyZShcInBhdGhcIik7XG52YXIgbm9kZV8xID0gcmVxdWlyZShcIi4vbm9kZVwiKTtcbnZhciBTdGF0c18xID0gcmVxdWlyZShcIi4vU3RhdHNcIik7XG52YXIgRGlyZW50XzEgPSByZXF1aXJlKFwiLi9EaXJlbnRcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9idWZmZXJcIik7XG52YXIgc2V0SW1tZWRpYXRlXzEgPSByZXF1aXJlKFwiLi9zZXRJbW1lZGlhdGVcIik7XG52YXIgcHJvY2Vzc18xID0gcmVxdWlyZShcIi4vcHJvY2Vzc1wiKTtcbnZhciBzZXRUaW1lb3V0VW5yZWZfMSA9IHJlcXVpcmUoXCIuL3NldFRpbWVvdXRVbnJlZlwiKTtcbnZhciBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIGVuY29kaW5nXzEgPSByZXF1aXJlKFwiLi9lbmNvZGluZ1wiKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9lcnJvcnNcIik7XG52YXIgZXh0ZW5kID0gcmVxdWlyZShcImZhc3QtZXh0ZW5kXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbnZhciBwcm9taXNlc18xID0gcmVxdWlyZShcIi4vcHJvbWlzZXNcIik7XG52YXIgcmVzb2x2ZUNyb3NzUGxhdGZvcm0gPSBwYXRoTW9kdWxlLnJlc29sdmU7XG52YXIgT19SRE9OTFkgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19SRE9OTFksIE9fV1JPTkxZID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fV1JPTkxZLCBPX1JEV1IgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19SRFdSLCBPX0NSRUFUID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fQ1JFQVQsIE9fRVhDTCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5PX0VYQ0wsIE9fVFJVTkMgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19UUlVOQywgT19BUFBFTkQgPSBjb25zdGFudHNfMS5jb25zdGFudHMuT19BUFBFTkQsIE9fU1lOQyA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5PX1NZTkMsIEZfT0sgPSBjb25zdGFudHNfMS5jb25zdGFudHMuRl9PSywgQ09QWUZJTEVfRVhDTCA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5DT1BZRklMRV9FWENMLCBDT1BZRklMRV9GSUNMT05FX0ZPUkNFID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLkNPUFlGSUxFX0ZJQ0xPTkVfRk9SQ0U7XG52YXIgc2VwO1xudmFyIHJlbGF0aXZlO1xuaWYgKHBhdGhNb2R1bGUucG9zaXgpIHtcbiAgICB2YXIgcG9zaXggPSBwYXRoTW9kdWxlLnBvc2l4O1xuICAgIHNlcCA9IHBvc2l4LnNlcDtcbiAgICByZWxhdGl2ZSA9IHBvc2l4LnJlbGF0aXZlO1xufVxuZWxzZSB7XG4gICAgc2VwID0gcGF0aE1vZHVsZS5zZXA7XG4gICAgcmVsYXRpdmUgPSBwYXRoTW9kdWxlLnJlbGF0aXZlO1xufVxudmFyIGlzV2luID0gcHJvY2Vzc18xLmRlZmF1bHQucGxhdGZvcm0gPT09ICd3aW4zMic7XG52YXIga01pblBvb2xTcGFjZSA9IDEyODtcbi8vIGNvbnN0IGtNYXhMZW5ndGggPSByZXF1aXJlKCdidWZmZXInKS5rTWF4TGVuZ3RoO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFcnJvciBtZXNzYWdlc1xuLy8gVE9ETzogVXNlIGBpbnRlcm5hbC9lcnJvcnMuanNgIGluIHRoZSBmdXR1cmUuXG52YXIgRVJSU1RSID0ge1xuICAgIFBBVEhfU1RSOiAncGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIEJ1ZmZlcicsXG4gICAgLy8gRkQ6ICAgICAgICAgICAgICdmaWxlIGRlc2NyaXB0b3IgbXVzdCBiZSBhIHVuc2lnbmVkIDMyLWJpdCBpbnRlZ2VyJyxcbiAgICBGRDogJ2ZkIG11c3QgYmUgYSBmaWxlIGRlc2NyaXB0b3InLFxuICAgIE1PREVfSU5UOiAnbW9kZSBtdXN0IGJlIGFuIGludCcsXG4gICAgQ0I6ICdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nLFxuICAgIFVJRDogJ3VpZCBtdXN0IGJlIGFuIHVuc2lnbmVkIGludCcsXG4gICAgR0lEOiAnZ2lkIG11c3QgYmUgYW4gdW5zaWduZWQgaW50JyxcbiAgICBMRU46ICdsZW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICBBVElNRTogJ2F0aW1lIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgTVRJTUU6ICdtdGltZSBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgIFBSRUZJWDogJ2ZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZCcsXG4gICAgQlVGRkVSOiAnYnVmZmVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQnVmZmVyIG9yIFN0YXRpY0J1ZmZlcicsXG4gICAgT0ZGU0VUOiAnb2Zmc2V0IG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgTEVOR1RIOiAnbGVuZ3RoIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgUE9TSVRJT046ICdwb3NpdGlvbiBtdXN0IGJlIGFuIGludGVnZXInLFxufTtcbnZhciBFUlJTVFJfT1BUUyA9IGZ1bmN0aW9uICh0aXBlb2YpIHsgcmV0dXJuIFwiRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgc3RyaW5nLCBidXQgZ290IFwiICsgdGlwZW9mICsgXCIgaW5zdGVhZFwiOyB9O1xuLy8gY29uc3QgRVJSU1RSX0ZMQUcgPSBmbGFnID0+IGBVbmtub3duIGZpbGUgb3BlbiBmbGFnOiAke2ZsYWd9YDtcbnZhciBFTk9FTlQgPSAnRU5PRU5UJztcbnZhciBFQkFERiA9ICdFQkFERic7XG52YXIgRUlOVkFMID0gJ0VJTlZBTCc7XG52YXIgRVBFUk0gPSAnRVBFUk0nO1xudmFyIEVQUk9UTyA9ICdFUFJPVE8nO1xudmFyIEVFWElTVCA9ICdFRVhJU1QnO1xudmFyIEVOT1RESVIgPSAnRU5PVERJUic7XG52YXIgRU1GSUxFID0gJ0VNRklMRSc7XG52YXIgRUFDQ0VTID0gJ0VBQ0NFUyc7XG52YXIgRUlTRElSID0gJ0VJU0RJUic7XG52YXIgRU5PVEVNUFRZID0gJ0VOT1RFTVBUWSc7XG52YXIgRU5PU1lTID0gJ0VOT1NZUyc7XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvckNvZGUsIGZ1bmMsIHBhdGgsIHBhdGgyKSB7XG4gICAgaWYgKGZ1bmMgPT09IHZvaWQgMCkgeyBmdW5jID0gJyc7IH1cbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSAnJzsgfVxuICAgIGlmIChwYXRoMiA9PT0gdm9pZCAwKSB7IHBhdGgyID0gJyc7IH1cbiAgICB2YXIgcGF0aEZvcm1hdHRlZCA9ICcnO1xuICAgIGlmIChwYXRoKVxuICAgICAgICBwYXRoRm9ybWF0dGVkID0gXCIgJ1wiICsgcGF0aCArIFwiJ1wiO1xuICAgIGlmIChwYXRoMilcbiAgICAgICAgcGF0aEZvcm1hdHRlZCArPSBcIiAtPiAnXCIgKyBwYXRoMiArIFwiJ1wiO1xuICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XG4gICAgICAgIGNhc2UgRU5PRU5UOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVCQURGOlxuICAgICAgICAgICAgcmV0dXJuIFwiRUJBREY6IGJhZCBmaWxlIGRlc2NyaXB0b3IsIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRUlOVkFMOlxuICAgICAgICAgICAgcmV0dXJuIFwiRUlOVkFMOiBpbnZhbGlkIGFyZ3VtZW50LCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVQRVJNOlxuICAgICAgICAgICAgcmV0dXJuIFwiRVBFUk06IG9wZXJhdGlvbiBub3QgcGVybWl0dGVkLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVQUk9UTzpcbiAgICAgICAgICAgIHJldHVybiBcIkVQUk9UTzogcHJvdG9jb2wgZXJyb3IsIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRUVYSVNUOlxuICAgICAgICAgICAgcmV0dXJuIFwiRUVYSVNUOiBmaWxlIGFscmVhZHkgZXhpc3RzLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVOT1RESVI6XG4gICAgICAgICAgICByZXR1cm4gXCJFTk9URElSOiBub3QgYSBkaXJlY3RvcnksIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRUlTRElSOlxuICAgICAgICAgICAgcmV0dXJuIFwiRUlTRElSOiBpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeSwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFQUNDRVM6XG4gICAgICAgICAgICByZXR1cm4gXCJFQUNDRVM6IHBlcm1pc3Npb24gZGVuaWVkLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgICAgICBjYXNlIEVOT1RFTVBUWTpcbiAgICAgICAgICAgIHJldHVybiBcIkVOT1RFTVBUWTogZGlyZWN0b3J5IG5vdCBlbXB0eSwgXCIgKyBmdW5jICsgcGF0aEZvcm1hdHRlZDtcbiAgICAgICAgY2FzZSBFTUZJTEU6XG4gICAgICAgICAgICByZXR1cm4gXCJFTUZJTEU6IHRvbyBtYW55IG9wZW4gZmlsZXMsIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGNhc2UgRU5PU1lTOlxuICAgICAgICAgICAgcmV0dXJuIFwiRU5PU1lTOiBmdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQsIFwiICsgZnVuYyArIHBhdGhGb3JtYXR0ZWQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JDb2RlICsgXCI6IGVycm9yIG9jY3VycmVkLCBcIiArIGZ1bmMgKyBwYXRoRm9ybWF0dGVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKGVycm9yQ29kZSwgZnVuYywgcGF0aCwgcGF0aDIsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGZ1bmMgPT09IHZvaWQgMCkgeyBmdW5jID0gJyc7IH1cbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSAnJzsgfVxuICAgIGlmIChwYXRoMiA9PT0gdm9pZCAwKSB7IHBhdGgyID0gJyc7IH1cbiAgICBpZiAoQ29uc3RydWN0b3IgPT09IHZvaWQgMCkgeyBDb25zdHJ1Y3RvciA9IEVycm9yOyB9XG4gICAgdmFyIGVycm9yID0gbmV3IENvbnN0cnVjdG9yKGZvcm1hdEVycm9yKGVycm9yQ29kZSwgZnVuYywgcGF0aCwgcGF0aDIpKTtcbiAgICBlcnJvci5jb2RlID0gZXJyb3JDb2RlO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHRocm93RXJyb3IoZXJyb3JDb2RlLCBmdW5jLCBwYXRoLCBwYXRoMiwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoZnVuYyA9PT0gdm9pZCAwKSB7IGZ1bmMgPSAnJzsgfVxuICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9ICcnOyB9XG4gICAgaWYgKHBhdGgyID09PSB2b2lkIDApIHsgcGF0aDIgPSAnJzsgfVxuICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gdm9pZCAwKSB7IENvbnN0cnVjdG9yID0gRXJyb3I7IH1cbiAgICB0aHJvdyBjcmVhdGVFcnJvcihlcnJvckNvZGUsIGZ1bmMsIHBhdGgsIHBhdGgyLCBDb25zdHJ1Y3Rvcik7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEZsYWdzXG4vLyBMaXN0IG9mIGZpbGUgYGZsYWdzYCBhcyBkZWZpbmVkIGJ5IE5vZGUuXG52YXIgRkxBR1M7XG4oZnVuY3Rpb24gKEZMQUdTKSB7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nLiBBbiBleGNlcHRpb24gb2NjdXJzIGlmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LlxuICAgIEZMQUdTW0ZMQUdTW1wiclwiXSA9IE9fUkRPTkxZXSA9IFwiclwiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZy4gQW4gZXhjZXB0aW9uIG9jY3VycyBpZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdC5cbiAgICBGTEFHU1tGTEFHU1tcInIrXCJdID0gT19SRFdSXSA9IFwicitcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgaW4gc3luY2hyb25vdXMgbW9kZS4gSW5zdHJ1Y3RzIHRoZSBvcGVyYXRpbmcgc3lzdGVtIHRvIGJ5cGFzcyB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gY2FjaGUuXG4gICAgRkxBR1NbRkxBR1NbXCJyc1wiXSA9IE9fUkRPTkxZIHwgT19TWU5DXSA9IFwicnNcIjtcbiAgICBGTEFHU1tGTEFHU1tcInNyXCJdID0gRkxBR1MucnNdID0gXCJzclwiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgcmVhZGluZyBhbmQgd3JpdGluZywgdGVsbGluZyB0aGUgT1MgdG8gb3BlbiBpdCBzeW5jaHJvbm91c2x5LiBTZWUgbm90ZXMgZm9yICdycycgYWJvdXQgdXNpbmcgdGhpcyB3aXRoIGNhdXRpb24uXG4gICAgRkxBR1NbRkxBR1NbXCJycytcIl0gPSBPX1JEV1IgfCBPX1NZTkNdID0gXCJycytcIjtcbiAgICBGTEFHU1tGTEFHU1tcInNyK1wiXSA9IEZMQUdTWydycysnXV0gPSBcInNyK1wiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3Igd3JpdGluZy4gVGhlIGZpbGUgaXMgY3JlYXRlZCAoaWYgaXQgZG9lcyBub3QgZXhpc3QpIG9yIHRydW5jYXRlZCAoaWYgaXQgZXhpc3RzKS5cbiAgICBGTEFHU1tGTEFHU1tcIndcIl0gPSBPX1dST05MWSB8IE9fQ1JFQVQgfCBPX1RSVU5DXSA9IFwid1wiO1xuICAgIC8vIExpa2UgJ3cnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcInd4XCJdID0gT19XUk9OTFkgfCBPX0NSRUFUIHwgT19UUlVOQyB8IE9fRVhDTF0gPSBcInd4XCI7XG4gICAgRkxBR1NbRkxBR1NbXCJ4d1wiXSA9IEZMQUdTLnd4XSA9IFwieHdcIjtcbiAgICAvLyBPcGVuIGZpbGUgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgKGlmIGl0IGRvZXMgbm90IGV4aXN0KSBvciB0cnVuY2F0ZWQgKGlmIGl0IGV4aXN0cykuXG4gICAgRkxBR1NbRkxBR1NbXCJ3K1wiXSA9IE9fUkRXUiB8IE9fQ1JFQVQgfCBPX1RSVU5DXSA9IFwidytcIjtcbiAgICAvLyBMaWtlICd3KycgYnV0IGZhaWxzIGlmIHBhdGggZXhpc3RzLlxuICAgIEZMQUdTW0ZMQUdTW1wid3grXCJdID0gT19SRFdSIHwgT19DUkVBVCB8IE9fVFJVTkMgfCBPX0VYQ0xdID0gXCJ3eCtcIjtcbiAgICBGTEFHU1tGTEFHU1tcInh3K1wiXSA9IEZMQUdTWyd3eCsnXV0gPSBcInh3K1wiO1xuICAgIC8vIE9wZW4gZmlsZSBmb3IgYXBwZW5kaW5nLiBUaGUgZmlsZSBpcyBjcmVhdGVkIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgIEZMQUdTW0ZMQUdTW1wiYVwiXSA9IE9fV1JPTkxZIHwgT19BUFBFTkQgfCBPX0NSRUFUXSA9IFwiYVwiO1xuICAgIC8vIExpa2UgJ2EnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcImF4XCJdID0gT19XUk9OTFkgfCBPX0FQUEVORCB8IE9fQ1JFQVQgfCBPX0VYQ0xdID0gXCJheFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wieGFcIl0gPSBGTEFHUy5heF0gPSBcInhhXCI7XG4gICAgLy8gT3BlbiBmaWxlIGZvciByZWFkaW5nIGFuZCBhcHBlbmRpbmcuIFRoZSBmaWxlIGlzIGNyZWF0ZWQgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gICAgRkxBR1NbRkxBR1NbXCJhK1wiXSA9IE9fUkRXUiB8IE9fQVBQRU5EIHwgT19DUkVBVF0gPSBcImErXCI7XG4gICAgLy8gTGlrZSAnYSsnIGJ1dCBmYWlscyBpZiBwYXRoIGV4aXN0cy5cbiAgICBGTEFHU1tGTEFHU1tcImF4K1wiXSA9IE9fUkRXUiB8IE9fQVBQRU5EIHwgT19DUkVBVCB8IE9fRVhDTF0gPSBcImF4K1wiO1xuICAgIEZMQUdTW0ZMQUdTW1wieGErXCJdID0gRkxBR1NbJ2F4KyddXSA9IFwieGErXCI7XG59KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xuZnVuY3Rpb24gZmxhZ3NUb051bWJlcihmbGFncykge1xuICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGZsYWdzTnVtID0gRkxBR1NbZmxhZ3NdO1xuICAgICAgICBpZiAodHlwZW9mIGZsYWdzTnVtICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIHJldHVybiBmbGFnc051bTtcbiAgICB9XG4gICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihmb3JtYXRFcnJvcihFUlJTVFJfRkxBRyhmbGFncykpKTtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgJ2ZsYWdzJywgZmxhZ3MpO1xufVxuZXhwb3J0cy5mbGFnc1RvTnVtYmVyID0gZmxhZ3NUb051bWJlcjtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gT3B0aW9uc1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucykge1xuICAgIHZhciBvcHRzO1xuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGlwZW9mID0gdHlwZW9mIG9wdGlvbnM7XG4gICAgICAgIHN3aXRjaCAodGlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIG9wdHMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCB7IGVuY29kaW5nOiBvcHRpb25zIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBvcHRzID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFJfT1BUUyh0aXBlb2YpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gJ2J1ZmZlcicpXG4gICAgICAgIGVuY29kaW5nXzEuYXNzZXJ0RW5jb2Rpbmcob3B0cy5lbmNvZGluZyk7XG4gICAgcmV0dXJuIG9wdHM7XG59XG5mdW5jdGlvbiBvcHRzR2VuZXJhdG9yKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7IHJldHVybiBnZXRPcHRpb25zKGRlZmF1bHRzLCBvcHRpb25zKTsgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoRVJSU1RSLkNCKTtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0T3B0cykge1xuICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gW2dldE9wdHMoKSwgb3B0aW9uc10gOiBbZ2V0T3B0cyhvcHRpb25zKSwgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayldO1xuICAgIH07XG59XG52YXIgb3B0c0RlZmF1bHRzID0ge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG59O1xudmFyIGdldERlZmF1bHRPcHRzID0gb3B0c0dlbmVyYXRvcihvcHRzRGVmYXVsdHMpO1xudmFyIGdldERlZmF1bHRPcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0RGVmYXVsdE9wdHMpO1xudmFyIHJlYWRGaWxlT3B0c0RlZmF1bHRzID0ge1xuICAgIGZsYWc6ICdyJyxcbn07XG52YXIgZ2V0UmVhZEZpbGVPcHRpb25zID0gb3B0c0dlbmVyYXRvcihyZWFkRmlsZU9wdHNEZWZhdWx0cyk7XG52YXIgd3JpdGVGaWxlRGVmYXVsdHMgPSB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiA0MzggLyogREVGQVVMVCAqLyxcbiAgICBmbGFnOiBGTEFHU1tGTEFHUy53XSxcbn07XG52YXIgZ2V0V3JpdGVGaWxlT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3Iod3JpdGVGaWxlRGVmYXVsdHMpO1xudmFyIGFwcGVuZEZpbGVEZWZhdWx0cyA9IHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDQzOCAvKiBERUZBVUxUICovLFxuICAgIGZsYWc6IEZMQUdTW0ZMQUdTLmFdLFxufTtcbnZhciBnZXRBcHBlbmRGaWxlT3B0cyA9IG9wdHNHZW5lcmF0b3IoYXBwZW5kRmlsZURlZmF1bHRzKTtcbnZhciBnZXRBcHBlbmRGaWxlT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldEFwcGVuZEZpbGVPcHRzKTtcbnZhciByZWFscGF0aERlZmF1bHRzID0gb3B0c0RlZmF1bHRzO1xudmFyIGdldFJlYWxwYXRoT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3IocmVhbHBhdGhEZWZhdWx0cyk7XG52YXIgZ2V0UmVhbHBhdGhPcHRzQW5kQ2IgPSBvcHRzQW5kQ2JHZW5lcmF0b3IoZ2V0UmVhbHBhdGhPcHRpb25zKTtcbnZhciBta2RpckRlZmF1bHRzID0ge1xuICAgIG1vZGU6IDUxMSAvKiBESVIgKi8sXG4gICAgcmVjdXJzaXZlOiBmYWxzZSxcbn07XG52YXIgZ2V0TWtkaXJPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBta2RpckRlZmF1bHRzLCB7IG1vZGU6IG9wdGlvbnMgfSk7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgbWtkaXJEZWZhdWx0cywgb3B0aW9ucyk7XG59O1xudmFyIHJlYWRkaXJEZWZhdWx0cyA9IHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxufTtcbnZhciBnZXRSZWFkZGlyT3B0aW9ucyA9IG9wdHNHZW5lcmF0b3IocmVhZGRpckRlZmF1bHRzKTtcbnZhciBnZXRSZWFkZGlyT3B0c0FuZENiID0gb3B0c0FuZENiR2VuZXJhdG9yKGdldFJlYWRkaXJPcHRpb25zKTtcbnZhciBzdGF0RGVmYXVsdHMgPSB7XG4gICAgYmlnaW50OiBmYWxzZSxcbn07XG52YXIgZ2V0U3RhdE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgc3RhdERlZmF1bHRzLCBvcHRpb25zKTtcbn07XG52YXIgZ2V0U3RhdE9wdHNBbmRDYiA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyA/IFtnZXRTdGF0T3B0aW9ucygpLCBvcHRpb25zXSA6IFtnZXRTdGF0T3B0aW9ucyhvcHRpb25zKSwgdmFsaWRhdGVDYWxsYmFjayhjYWxsYmFjayldO1xufTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gVXRpbGl0eSBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldFBhdGhGcm9tVVJMUG9zaXgodXJsKSB7XG4gICAgaWYgKHVybC5ob3N0bmFtZSAhPT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5UeXBlRXJyb3IoJ0VSUl9JTlZBTElEX0ZJTEVfVVJMX0hPU1QnLCBwcm9jZXNzXzEuZGVmYXVsdC5wbGF0Zm9ybSk7XG4gICAgfVxuICAgIHZhciBwYXRobmFtZSA9IHVybC5wYXRobmFtZTtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBhdGhuYW1lLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGlmIChwYXRobmFtZVtuXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICB2YXIgdGhpcmQgPSBwYXRobmFtZS5jb2RlUG9pbnRBdChuICsgMikgfCAweDIwO1xuICAgICAgICAgICAgaWYgKHBhdGhuYW1lW24gKyAxXSA9PT0gJzInICYmIHRoaXJkID09PSAxMDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLlR5cGVFcnJvcignRVJSX0lOVkFMSURfRklMRV9VUkxfUEFUSCcsICdtdXN0IG5vdCBpbmNsdWRlIGVuY29kZWQgLyBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXRobmFtZSk7XG59XG5mdW5jdGlvbiBwYXRoVG9GaWxlbmFtZShwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyAmJiAhYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgcmVxdWlyZSgndXJsJykuVVJMKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUlNUUi5QQVRIX1NUUik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJTVFIuUEFUSF9TVFIpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBnZXRQYXRoRnJvbVVSTFBvc2l4KHBhdGgpO1xuICAgIH1cbiAgICB2YXIgcGF0aFN0cmluZyA9IFN0cmluZyhwYXRoKTtcbiAgICBudWxsQ2hlY2socGF0aFN0cmluZyk7XG4gICAgLy8gcmV0dXJuIHNsYXNoKHBhdGhTdHJpbmcpO1xuICAgIHJldHVybiBwYXRoU3RyaW5nO1xufVxuZXhwb3J0cy5wYXRoVG9GaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lO1xudmFyIHJlc29sdmUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGJhc2UpIHtcbiAgICBpZiAoYmFzZSA9PT0gdm9pZCAwKSB7IGJhc2UgPSBwcm9jZXNzXzEuZGVmYXVsdC5jd2QoKTsgfVxuICAgIHJldHVybiByZXNvbHZlQ3Jvc3NQbGF0Zm9ybShiYXNlLCBmaWxlbmFtZSk7XG59O1xuaWYgKGlzV2luKSB7XG4gICAgdmFyIF9yZXNvbHZlXzEgPSByZXNvbHZlO1xuICAgIHZhciB1bml4aWZ5XzEgPSByZXF1aXJlKCdmcy1tb25rZXkvbGliL2NvcnJlY3RQYXRoJykudW5peGlmeTtcbiAgICByZXNvbHZlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBiYXNlKSB7IHJldHVybiB1bml4aWZ5XzEoX3Jlc29sdmVfMShmaWxlbmFtZSwgYmFzZSkpOyB9O1xufVxuZnVuY3Rpb24gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lLCBiYXNlKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gcmVzb2x2ZShmaWxlbmFtZSwgYmFzZSk7XG4gICAgdmFyIGZ1bGxQYXRoU2Fuc1NsYXNoID0gZnVsbFBhdGguc3Vic3RyKDEpO1xuICAgIGlmICghZnVsbFBhdGhTYW5zU2xhc2gpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICByZXR1cm4gZnVsbFBhdGhTYW5zU2xhc2guc3BsaXQoc2VwKTtcbn1cbmV4cG9ydHMuZmlsZW5hbWVUb1N0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzO1xuZnVuY3Rpb24gcGF0aFRvU3RlcHMocGF0aCkge1xuICAgIHJldHVybiBmaWxlbmFtZVRvU3RlcHMocGF0aFRvRmlsZW5hbWUocGF0aCkpO1xufVxuZXhwb3J0cy5wYXRoVG9TdGVwcyA9IHBhdGhUb1N0ZXBzO1xuZnVuY3Rpb24gZGF0YVRvU3RyKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSBlbmNvZGluZ18xLkVOQ09ESU5HX1VURjg7IH1cbiAgICBpZiAoYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKGRhdGEpKVxuICAgICAgICByZXR1cm4gZGF0YS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBidWZmZXJfMS5idWZmZXJGcm9tKGRhdGEpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBTdHJpbmcoZGF0YSk7XG59XG5leHBvcnRzLmRhdGFUb1N0ciA9IGRhdGFUb1N0cjtcbmZ1bmN0aW9uIGRhdGFUb0J1ZmZlcihkYXRhLCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4OyB9XG4gICAgaWYgKGJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihkYXRhKSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBidWZmZXJfMS5idWZmZXJGcm9tKGRhdGEpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLmJ1ZmZlckZyb20oU3RyaW5nKGRhdGEpLCBlbmNvZGluZyk7XG59XG5leHBvcnRzLmRhdGFUb0J1ZmZlciA9IGRhdGFUb0J1ZmZlcjtcbmZ1bmN0aW9uIGJ1ZmZlclRvRW5jb2RpbmcoYnVmZmVyLCBlbmNvZGluZykge1xuICAgIGlmICghZW5jb2RpbmcgfHwgZW5jb2RpbmcgPT09ICdidWZmZXInKVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyhlbmNvZGluZyk7XG59XG5leHBvcnRzLmJ1ZmZlclRvRW5jb2RpbmcgPSBidWZmZXJUb0VuY29kaW5nO1xuZnVuY3Rpb24gbnVsbENoZWNrKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCgnJyArIHBhdGgpLmluZGV4T2YoJ1xcdTAwMDAnKSAhPT0gLTEpIHtcbiAgICAgICAgdmFyIGVyID0gbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzJyk7XG4gICAgICAgIGVyLmNvZGUgPSBFTk9FTlQ7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgcHJvY2Vzc18xLmRlZmF1bHQubmV4dFRpY2soY2FsbGJhY2ssIGVyKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9tb2RlVG9OdW1iZXIobW9kZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgaWYgKHR5cGVvZiBtb2RlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1vZGUsIDgpO1xuICAgIGlmIChkZWYpXG4gICAgICAgIHJldHVybiBtb2RlVG9OdW1iZXIoZGVmKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gbW9kZVRvTnVtYmVyKG1vZGUsIGRlZikge1xuICAgIHZhciByZXN1bHQgPSBfbW9kZVRvTnVtYmVyKG1vZGUsIGRlZik7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdudW1iZXInIHx8IGlzTmFOKHJlc3VsdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJSU1RSLk1PREVfSU5UKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNGZChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGggPj4+IDAgPT09IHBhdGg7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZkKGZkKSB7XG4gICAgaWYgKCFpc0ZkKGZkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKEVSUlNUUi5GRCk7XG59XG4vLyBjb252ZXJ0cyBEYXRlIG9yIG51bWJlciB0byBhIGZyYWN0aW9uYWwgVU5JWCB0aW1lc3RhbXBcbmZ1bmN0aW9uIHRvVW5peFRpbWVzdGFtcCh0aW1lKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIHRyaXBsZS1lcXVhbHNcbiAgICBpZiAodHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnICYmICt0aW1lID09IHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICt0aW1lO1xuICAgIH1cbiAgICBpZiAodGltZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlKHRpbWUpKSB7XG4gICAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSB0aW1lOiAnICsgdGltZSk7XG59XG5leHBvcnRzLnRvVW5peFRpbWVzdGFtcCA9IHRvVW5peFRpbWVzdGFtcDtcbi8qKlxuICogUmV0dXJucyBvcHRpb25hbCBhcmd1bWVudCBhbmQgY2FsbGJhY2tcbiAqIEBwYXJhbSBhcmcgQXJndW1lbnQgb3IgY2FsbGJhY2sgdmFsdWVcbiAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayBvciB1bmRlZmluZWRcbiAqIEBwYXJhbSBkZWYgRGVmYXVsdCBhcmd1bWVudCB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRBcmdBbmRDYihhcmcsIGNhbGxiYWNrLCBkZWYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IFtkZWYsIGFyZ10gOiBbYXJnLCBjYWxsYmFja107XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVVpZCh1aWQpIHtcbiAgICBpZiAodHlwZW9mIHVpZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihFUlJTVFIuVUlEKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlR2lkKGdpZCkge1xuICAgIGlmICh0eXBlb2YgZ2lkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKEVSUlNUUi5HSUQpO1xufVxuLyoqXG4gKiBgVm9sdW1lYCByZXByZXNlbnRzIGEgZmlsZSBzeXN0ZW0uXG4gKi9cbnZhciBWb2x1bWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVm9sdW1lKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7IHByb3BzID0ge307IH1cbiAgICAgICAgLy8gSS1ub2RlIG51bWJlciBjb3VudGVyLlxuICAgICAgICB0aGlzLmlubyA9IDA7XG4gICAgICAgIC8vIEEgbWFwcGluZyBmb3IgaS1ub2RlIG51bWJlcnMgdG8gaS1ub2RlcyAoYE5vZGVgKTtcbiAgICAgICAgdGhpcy5pbm9kZXMgPSB7fTtcbiAgICAgICAgLy8gTGlzdCBvZiByZWxlYXNlZCBpLW5vZGUgbnVtYmVycywgZm9yIHJldXNlLlxuICAgICAgICB0aGlzLnJlbGVhc2VkSW5vcyA9IFtdO1xuICAgICAgICAvLyBBIG1hcHBpbmcgZm9yIGZpbGUgZGVzY3JpcHRvcnMgdG8gYEZpbGVgcy5cbiAgICAgICAgdGhpcy5mZHMgPSB7fTtcbiAgICAgICAgLy8gQSBsaXN0IG9mIHJldXNhYmxlIChvcGVuZWQgYW5kIGNsb3NlZCkgZmlsZSBkZXNjcmlwdG9ycywgdGhhdCBzaG91bGQgYmVcbiAgICAgICAgLy8gdXNlZCBmaXJzdCBiZWZvcmUgY3JlYXRpbmcgYSBuZXcgZmlsZSBkZXNjcmlwdG9yLlxuICAgICAgICB0aGlzLnJlbGVhc2VkRmRzID0gW107XG4gICAgICAgIC8vIE1heCBudW1iZXIgb2Ygb3BlbiBmaWxlcy5cbiAgICAgICAgdGhpcy5tYXhGaWxlcyA9IDEwMDAwO1xuICAgICAgICAvLyBDdXJyZW50IG51bWJlciBvZiBvcGVuIGZpbGVzLlxuICAgICAgICB0aGlzLm9wZW5GaWxlcyA9IDA7XG4gICAgICAgIHRoaXMucHJvbWlzZXNBcGkgPSBwcm9taXNlc18xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIHRoaXMuc3RhdFdhdGNoZXJzID0ge307XG4gICAgICAgIHRoaXMucHJvcHMgPSBleHRlbmQoeyBOb2RlOiBub2RlXzEuTm9kZSwgTGluazogbm9kZV8xLkxpbmssIEZpbGU6IG5vZGVfMS5GaWxlIH0sIHByb3BzKTtcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmNyZWF0ZUxpbmsoKTtcbiAgICAgICAgcm9vdC5zZXROb2RlKHRoaXMuY3JlYXRlTm9kZSh0cnVlKSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICAgICAgdGhpcy5TdGF0V2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTdGF0V2F0Y2hlciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0YXRXYXRjaGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzZWxmKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0YXRXYXRjaGVyO1xuICAgICAgICB9KFN0YXRXYXRjaGVyKSk7XG4gICAgICAgIHZhciBfUmVhZFN0cmVhbSA9IEZzUmVhZFN0cmVhbTtcbiAgICAgICAgdGhpcy5SZWFkU3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXlzKFtzZWxmXSwgYXJncykpIHx8IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICAgICAgfShfUmVhZFN0cmVhbSkpO1xuICAgICAgICB2YXIgX1dyaXRlU3RyZWFtID0gRnNXcml0ZVN0cmVhbTtcbiAgICAgICAgdGhpcy5Xcml0ZVN0cmVhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhjbGFzc18yLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xhc3NfMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBfX3NwcmVhZEFycmF5cyhbc2VsZl0sIGFyZ3MpKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzI7XG4gICAgICAgIH0oX1dyaXRlU3RyZWFtKSk7XG4gICAgICAgIHRoaXMuRlNXYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEZTV2F0Y2hlciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZTV2F0Y2hlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgc2VsZikgfHwgdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGU1dhdGNoZXI7XG4gICAgICAgIH0oRlNXYXRjaGVyKSk7XG4gICAgICAgIC8vIHJvb3Quc2V0Q2hpbGQoJy4nLCByb290KTtcbiAgICAgICAgLy8gcm9vdC5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgLy8gcm9vdC5zZXRDaGlsZCgnLi4nLCByb290KTtcbiAgICAgICAgLy8gcm9vdC5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB9XG4gICAgVm9sdW1lLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24sIGN3ZCkge1xuICAgICAgICB2YXIgdm9sID0gbmV3IFZvbHVtZSgpO1xuICAgICAgICB2b2wuZnJvbUpTT04oanNvbiwgY3dkKTtcbiAgICAgICAgcmV0dXJuIHZvbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWb2x1bWUucHJvdG90eXBlLCBcInByb21pc2VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9taXNlc0FwaSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb21pc2UgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LicpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXNBcGk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY3JlYXRlTGluayA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIGlzRGlyZWN0b3J5LCBwZXJtKSB7XG4gICAgICAgIGlmIChpc0RpcmVjdG9yeSA9PT0gdm9pZCAwKSB7IGlzRGlyZWN0b3J5ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5jcmVhdGVDaGlsZChuYW1lLCB0aGlzLmNyZWF0ZU5vZGUoaXNEaXJlY3RvcnksIHBlcm0pKSA6IG5ldyB0aGlzLnByb3BzLkxpbmsodGhpcywgbnVsbCwgJycpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5kZWxldGVMaW5rID0gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxpbmsucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuZGVsZXRlQ2hpbGQobGluayk7XG4gICAgICAgICAgICBsaW5rLnZvbCA9IG51bGw7XG4gICAgICAgICAgICBsaW5rLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm5ld0lub051bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZWRJbm9zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGVhc2VkSW5vcy5wb3AoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlubyA9ICh0aGlzLmlubyArIDEpICUgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlubztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5uZXdGZE51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsZWFzZWRGZHMubGVuZ3RoID8gdGhpcy5yZWxlYXNlZEZkcy5wb3AoKSA6IFZvbHVtZS5mZC0tO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKGlzRGlyZWN0b3J5LCBwZXJtKSB7XG4gICAgICAgIGlmIChpc0RpcmVjdG9yeSA9PT0gdm9pZCAwKSB7IGlzRGlyZWN0b3J5ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgdGhpcy5wcm9wcy5Ob2RlKHRoaXMubmV3SW5vTnVtYmVyKCksIHBlcm0pO1xuICAgICAgICBpZiAoaXNEaXJlY3RvcnkpXG4gICAgICAgICAgICBub2RlLnNldElzRGlyZWN0b3J5KCk7XG4gICAgICAgIHRoaXMuaW5vZGVzW25vZGUuaW5vXSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKGlubykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm9kZXNbaW5vXTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZGVsZXRlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuZGVsKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmlub2Rlc1tub2RlLmlub107XG4gICAgICAgIHRoaXMucmVsZWFzZWRJbm9zLnB1c2gobm9kZS5pbm8pO1xuICAgIH07XG4gICAgLy8gR2VuZXJhdGVzIDYgY2hhcmFjdGVyIGxvbmcgcmFuZG9tIHN0cmluZywgdXNlZCBieSBgbWtkdGVtcGAuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZW5SbmRTdHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIgPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNik7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID09PSA2KVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuUm5kU3RyKCk7XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIGEgYExpbmtgIChoYXJkIGxpbmspIHJlZmVyZW5jZWQgYnkgcGF0aCBcInNwbGl0XCIgaW50byBzdGVwcy5cbiAgICBWb2x1bWUucHJvdG90eXBlLmdldExpbmsgPSBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC53YWxrKHN0ZXBzKTtcbiAgICB9O1xuICAgIC8vIEp1c3QgbGluayBgZ2V0TGlua2AsIGJ1dCB0aHJvd3MgYSBjb3JyZWN0IHVzZXIgZXJyb3IsIGlmIGxpbmsgdG8gZm91bmQuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRMaW5rT3JUaHJvdyA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZnVuY05hbWUpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldExpbmsoc3RlcHMpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgZnVuY05hbWUsIGZpbGVuYW1lKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfTtcbiAgICAvLyBKdXN0IGxpa2UgYGdldExpbmtgLCBidXQgYWxzbyBkZXJlZmVyZW5jZS9yZXNvbHZlcyBzeW1ib2xpYyBsaW5rcy5cbiAgICBWb2x1bWUucHJvdG90eXBlLmdldFJlc29sdmVkTGluayA9IGZ1bmN0aW9uIChmaWxlbmFtZU9yU3RlcHMpIHtcbiAgICAgICAgdmFyIHN0ZXBzID0gdHlwZW9mIGZpbGVuYW1lT3JTdGVwcyA9PT0gJ3N0cmluZycgPyBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWVPclN0ZXBzKSA6IGZpbGVuYW1lT3JTdGVwcztcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gc3RlcHNbaV07XG4gICAgICAgICAgICBsaW5rID0gbGluay5nZXRDaGlsZChzdGVwKTtcbiAgICAgICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1N5bWxpbmsoKSkge1xuICAgICAgICAgICAgICAgIHN0ZXBzID0gbm9kZS5zeW1saW5rLmNvbmNhdChzdGVwcy5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGxpbmsgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfTtcbiAgICAvLyBKdXN0IGxpa2UgYGdldExpbmtPclRocm93YCwgYnV0IGFsc28gZGVyZWZlcmVuY2UvcmVzb2x2ZXMgc3ltYm9saWMgbGlua3MuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRSZXNvbHZlZExpbmtPclRocm93ID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKGZpbGVuYW1lKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsIGZ1bmNOYW1lLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZXNvbHZlU3ltbGlua3MgPSBmdW5jdGlvbiAobGluaykge1xuICAgICAgICAvLyBsZXQgbm9kZTogTm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAvLyB3aGlsZShsaW5rICYmIG5vZGUuaXNTeW1saW5rKCkpIHtcbiAgICAgICAgLy8gICAgIGxpbmsgPSB0aGlzLmdldExpbmsobm9kZS5zeW1saW5rKTtcbiAgICAgICAgLy8gICAgIGlmKCFsaW5rKSByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gICAgIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyByZXR1cm4gbGluaztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKGxpbmsuc3RlcHMuc2xpY2UoMSkpO1xuICAgIH07XG4gICAgLy8gSnVzdCBsaWtlIGBnZXRMaW5rT3JUaHJvd2AsIGJ1dCBhbHNvIHZlcmlmaWVzIHRoYXQgdGhlIGxpbmsgaXMgYSBkaXJlY3RvcnkuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRMaW5rQXNEaXJPclRocm93ID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBmdW5jTmFtZSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGlua09yVGhyb3coZmlsZW5hbWUsIGZ1bmNOYW1lKTtcbiAgICAgICAgaWYgKCFsaW5rLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9URElSLCBmdW5jTmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9O1xuICAgIC8vIEdldCB0aGUgaW1tZWRpYXRlIHBhcmVudCBkaXJlY3Rvcnkgb2YgdGhlIGxpbmsuXG4gICAgVm9sdW1lLnByb3RvdHlwZS5nZXRMaW5rUGFyZW50ID0gZnVuY3Rpb24gKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Qud2FsayhzdGVwcywgc3RlcHMubGVuZ3RoIC0gMSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmdldExpbmtQYXJlbnRBc0Rpck9yVGhyb3cgPSBmdW5jdGlvbiAoZmlsZW5hbWVPclN0ZXBzLCBmdW5jTmFtZSkge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZU9yU3RlcHMgaW5zdGFuY2VvZiBBcnJheSA/IGZpbGVuYW1lT3JTdGVwcyA6IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZU9yU3RlcHMpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCBmdW5jTmFtZSwgc2VwICsgc3RlcHMuam9pbihzZXApKTtcbiAgICAgICAgaWYgKCFsaW5rLmdldE5vZGUoKS5pc0RpcmVjdG9yeSgpKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9URElSLCBmdW5jTmFtZSwgc2VwICsgc3RlcHMuam9pbihzZXApKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmdldEZpbGVCeUZkID0gZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZkc1tTdHJpbmcoZmQpXTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZ2V0RmlsZUJ5RmRPclRocm93ID0gZnVuY3Rpb24gKGZkLCBmdW5jTmFtZSkge1xuICAgICAgICBpZiAoIWlzRmQoZmQpKVxuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKEVSUlNUUi5GRCk7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZChmZCk7XG4gICAgICAgIGlmICghZmlsZSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUJBREYsIGZ1bmNOYW1lKTtcbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmdldE5vZGVCeUlkT3JDcmVhdGUgPSBmdW5jdGlvbiAoaWQsIGZsYWdzLCBwZXJtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmQoaWQpO1xuICAgICAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdGaWxlIG50byBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGUubm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGVwcyA9IHBhdGhUb1N0ZXBzKGlkKTtcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rKHN0ZXBzKTtcbiAgICAgICAgICAgIGlmIChsaW5rKVxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5vZGUgaWYgbm90IGZvdW5kLlxuICAgICAgICAgICAgaWYgKGZsYWdzICYgT19DUkVBVCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXJMaW5rID0gdGhpcy5nZXRMaW5rUGFyZW50KHN0ZXBzKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyTGluaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSB0aGlzLmNyZWF0ZUxpbmsoZGlyTGluaywgbmFtZV8xLCBmYWxzZSwgcGVybSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ2dldE5vZGVCeUlkT3JDcmVhdGUnLCBwYXRoVG9GaWxlbmFtZShpZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyYXBBc3luYyA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICBzZXRJbW1lZGlhdGVfMS5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0aG9kLmFwcGx5KF90aGlzLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLl90b0pTT04gPSBmdW5jdGlvbiAobGluaywganNvbiwgcGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChsaW5rID09PSB2b2lkIDApIHsgbGluayA9IHRoaXMucm9vdDsgfVxuICAgICAgICBpZiAoanNvbiA9PT0gdm9pZCAwKSB7IGpzb24gPSB7fTsgfVxuICAgICAgICB2YXIgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGxpbmsuY2hpbGRyZW47XG4gICAgICAgIGlmIChsaW5rLmdldE5vZGUoKS5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSAoX2EgPSB7fSwgX2FbbGluay5nZXROYW1lKCldID0gbGluay5wYXJlbnQuZ2V0Q2hpbGQobGluay5nZXROYW1lKCkpLCBfYSk7XG4gICAgICAgICAgICBsaW5rID0gbGluay5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBsaW5rLmdldENoaWxkKG5hbWVfMik7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gY2hpbGQuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlbGF0aXZlKHBhdGgsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBqc29uW2ZpbGVuYW1lXSA9IG5vZGUuZ2V0U3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b0pTT04oY2hpbGQsIGpzb24sIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJQYXRoID0gbGluay5nZXRQYXRoKCk7XG4gICAgICAgIGlmIChwYXRoKVxuICAgICAgICAgICAgZGlyUGF0aCA9IHJlbGF0aXZlKHBhdGgsIGRpclBhdGgpO1xuICAgICAgICBpZiAoZGlyUGF0aCAmJiBpc0VtcHR5KSB7XG4gICAgICAgICAgICBqc29uW2RpclBhdGhdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKHBhdGhzLCBqc29uLCBpc1JlbGF0aXZlKSB7XG4gICAgICAgIGlmIChqc29uID09PSB2b2lkIDApIHsganNvbiA9IHt9OyB9XG4gICAgICAgIGlmIChpc1JlbGF0aXZlID09PSB2b2lkIDApIHsgaXNSZWxhdGl2ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsaW5rcyA9IFtdO1xuICAgICAgICBpZiAocGF0aHMpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGhzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICAgICAgICAgIHBhdGhzID0gW3BhdGhzXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgcGF0aHNfMSA9IHBhdGhzOyBfaSA8IHBhdGhzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaW5rcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBsaW5rc18xID0gbGlua3M7IF9hIDwgbGlua3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBsaW5rID0gbGlua3NfMVtfYV07XG4gICAgICAgICAgICB0aGlzLl90b0pTT04obGluaywganNvbiwgaXNSZWxhdGl2ZSA/IGxpbmsuZ2V0UGF0aCgpIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH07XG4gICAgLy8gZnJvbUpTT04oanNvbjoge1tmaWxlbmFtZTogc3RyaW5nXTogc3RyaW5nfSwgY3dkOiBzdHJpbmcgPSAnLycpIHtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKGpzb24sIGN3ZCkge1xuICAgICAgICBpZiAoY3dkID09PSB2b2lkIDApIHsgY3dkID0gcHJvY2Vzc18xLmRlZmF1bHQuY3dkKCk7IH1cbiAgICAgICAgZm9yICh2YXIgZmlsZW5hbWUgaW4ganNvbikge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBqc29uW2ZpbGVuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSA9IHJlc29sdmUoZmlsZW5hbWUsIGN3ZCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlybmFtZSA9IHNlcCArIHN0ZXBzLnNsaWNlKDAsIHN0ZXBzLmxlbmd0aCAtIDEpLmpvaW4oc2VwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ta2RpcnBCYXNlKGRpcm5hbWUsIDUxMSAvKiBESVIgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRmlsZVN5bmMoZmlsZW5hbWUsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ta2RpcnBCYXNlKGZpbGVuYW1lLCA1MTEgLyogRElSICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm8gPSAwO1xuICAgICAgICB0aGlzLmlub2RlcyA9IHt9O1xuICAgICAgICB0aGlzLnJlbGVhc2VkSW5vcyA9IFtdO1xuICAgICAgICB0aGlzLmZkcyA9IHt9O1xuICAgICAgICB0aGlzLnJlbGVhc2VkRmRzID0gW107XG4gICAgICAgIHRoaXMub3BlbkZpbGVzID0gMDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5jcmVhdGVMaW5rKCk7XG4gICAgICAgIHRoaXMucm9vdC5zZXROb2RlKHRoaXMuY3JlYXRlTm9kZSh0cnVlKSk7XG4gICAgfTtcbiAgICAvLyBMZWdhY3kgaW50ZXJmYWNlXG4gICAgVm9sdW1lLnByb3RvdHlwZS5tb3VudFN5bmMgPSBmdW5jdGlvbiAobW91bnRwb2ludCwganNvbikge1xuICAgICAgICB0aGlzLmZyb21KU09OKGpzb24sIG1vdW50cG9pbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5vcGVuTGluayA9IGZ1bmN0aW9uIChsaW5rLCBmbGFnc051bSwgcmVzb2x2ZVN5bWxpbmtzKSB7XG4gICAgICAgIGlmIChyZXNvbHZlU3ltbGlua3MgPT09IHZvaWQgMCkgeyByZXNvbHZlU3ltbGlua3MgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5GaWxlcyA+PSB0aGlzLm1heEZpbGVzKSB7XG4gICAgICAgICAgICAvLyBUb28gbWFueSBvcGVuIGZpbGVzLlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoRU1GSUxFLCAnb3BlbicsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIHN5bWxpbmtzLlxuICAgICAgICB2YXIgcmVhbExpbmsgPSBsaW5rO1xuICAgICAgICBpZiAocmVzb2x2ZVN5bWxpbmtzKVxuICAgICAgICAgICAgcmVhbExpbmsgPSB0aGlzLnJlc29sdmVTeW1saW5rcyhsaW5rKTtcbiAgICAgICAgaWYgKCFyZWFsTGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnb3BlbicsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgdmFyIG5vZGUgPSByZWFsTGluay5nZXROb2RlKCk7XG4gICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkgJiYgZmxhZ3NOdW0gIT09IEZMQUdTLnIpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVJU0RJUiwgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgIC8vIENoZWNrIG5vZGUgcGVybWlzc2lvbnNcbiAgICAgICAgaWYgKCEoZmxhZ3NOdW0gJiBPX1dST05MWSkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5jYW5SZWFkKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKEVBQ0NFUywgJ29wZW4nLCBsaW5rLmdldFBhdGgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzTnVtICYgT19SRFdSKSB7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbGUgPSBuZXcgdGhpcy5wcm9wcy5GaWxlKGxpbmssIG5vZGUsIGZsYWdzTnVtLCB0aGlzLm5ld0ZkTnVtYmVyKCkpO1xuICAgICAgICB0aGlzLmZkc1tmaWxlLmZkXSA9IGZpbGU7XG4gICAgICAgIHRoaXMub3BlbkZpbGVzKys7XG4gICAgICAgIGlmIChmbGFnc051bSAmIE9fVFJVTkMpXG4gICAgICAgICAgICBmaWxlLnRydW5jYXRlKCk7XG4gICAgICAgIHJldHVybiBmaWxlO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5vcGVuRmlsZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0sIHJlc29sdmVTeW1saW5rcykge1xuICAgICAgICBpZiAocmVzb2x2ZVN5bWxpbmtzID09PSB2b2lkIDApIHsgcmVzb2x2ZVN5bWxpbmtzID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICB2YXIgbGluayA9IHJlc29sdmVTeW1saW5rcyA/IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzKSA6IHRoaXMuZ2V0TGluayhzdGVwcyk7XG4gICAgICAgIC8vIFRyeSBjcmVhdGluZyBhIG5ldyBmaWxlLCBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICAgICAgaWYgKCFsaW5rICYmIGZsYWdzTnVtICYgT19DUkVBVCkge1xuICAgICAgICAgICAgLy8gY29uc3QgZGlyTGluazogTGluayA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwcyk7XG4gICAgICAgICAgICB2YXIgZGlyTGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzLnNsaWNlKDAsIHN0ZXBzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIC8vIGlmKCFkaXJMaW5rKSB0aHJvd0Vycm9yKEVOT0VOVCwgJ29wZW4nLCBmaWxlbmFtZSk7XG4gICAgICAgICAgICBpZiAoIWRpckxpbmspXG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdvcGVuJywgc2VwICsgc3RlcHMuam9pbihzZXApKTtcbiAgICAgICAgICAgIGlmIChmbGFnc051bSAmIE9fQ1JFQVQgJiYgdHlwZW9mIG1vZGVOdW0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbGluayA9IHRoaXMuY3JlYXRlTGluayhkaXJMaW5rLCBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSwgZmFsc2UsIG1vZGVOdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5rKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbkxpbmsobGluaywgZmxhZ3NOdW0sIHJlc29sdmVTeW1saW5rcyk7XG4gICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnb3BlbicsIGZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlbkJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGZsYWdzTnVtLCBtb2RlTnVtLCByZXNvbHZlU3ltbGlua3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVTeW1saW5rcyA9PT0gdm9pZCAwKSB7IHJlc29sdmVTeW1saW5rcyA9IHRydWU7IH1cbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLm9wZW5GaWxlKGZpbGVuYW1lLCBmbGFnc051bSwgbW9kZU51bSwgcmVzb2x2ZVN5bWxpbmtzKTtcbiAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdvcGVuJywgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gZmlsZS5mZDtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUub3BlblN5bmMgPSBmdW5jdGlvbiAocGF0aCwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gNDM4IC8qIERFRkFVTFQgKi87IH1cbiAgICAgICAgLy8gVmFsaWRhdGUgKDEpIG1vZGU7ICgyKSBwYXRoOyAoMykgZmxhZ3MgLSBpbiB0aGF0IG9yZGVyLlxuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihtb2RlKTtcbiAgICAgICAgdmFyIGZpbGVOYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIoZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuQmFzZShmaWxlTmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKHBhdGgsIGZsYWdzLCBhLCBiKSB7XG4gICAgICAgIHZhciBtb2RlID0gYTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYjtcbiAgICAgICAgaWYgKHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtb2RlID0gNDM4IC8qIERFRkFVTFQgKi87XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgNDM4IC8qIERFRkFVTFQgKi87XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihmbGFncyk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMub3BlbkJhc2UsIFtmaWxlTmFtZSwgZmxhZ3NOdW0sIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNsb3NlRmlsZSA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgIGlmICghdGhpcy5mZHNbZmlsZS5mZF0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3BlbkZpbGVzLS07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZkc1tmaWxlLmZkXTtcbiAgICAgICAgdGhpcy5yZWxlYXNlZEZkcy5wdXNoKGZpbGUuZmQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jbG9zZVN5bmMgPSBmdW5jdGlvbiAoZmQpIHtcbiAgICAgICAgdmFsaWRhdGVGZChmZCk7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICdjbG9zZScpO1xuICAgICAgICB0aGlzLmNsb3NlRmlsZShmaWxlKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNsb3NlU3luYywgW2ZkXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5vcGVuRmlsZU9yR2V0QnlJZCA9IGZ1bmN0aW9uIChpZCwgZmxhZ3NOdW0sIG1vZGVOdW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBmaWxlID0gdGhpcy5mZHNbaWRdO1xuICAgICAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKEVOT0VOVCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5GaWxlKHBhdGhUb0ZpbGVuYW1lKGlkKSwgZmxhZ3NOdW0sIG1vZGVOdW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRCYXNlID0gZnVuY3Rpb24gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkKTtcbiAgICAgICAgcmV0dXJuIGZpbGUucmVhZChidWZmZXIsIE51bWJlcihvZmZzZXQpLCBOdW1iZXIobGVuZ3RoKSwgcG9zaXRpb24pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFsaWRhdGVGZChmZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRCYXNlKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgLy8gVGhpcyBgaWZgIGJyYW5jaCBpcyBmcm9tIE5vZGUuanNcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NfMS5kZWZhdWx0Lm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDAsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbW1lZGlhdGVfMS5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVzID0gX3RoaXMucmVhZEJhc2UoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZEZpbGVCYXNlID0gZnVuY3Rpb24gKGlkLCBmbGFnc051bSwgZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGlzVXNlckZkID0gdHlwZW9mIGlkID09PSAnbnVtYmVyJztcbiAgICAgICAgdmFyIHVzZXJPd25zRmQgPSBpc1VzZXJGZCAmJiBpc0ZkKGlkKTtcbiAgICAgICAgdmFyIGZkO1xuICAgICAgICBpZiAodXNlck93bnNGZClcbiAgICAgICAgICAgIGZkID0gaWQ7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoaWQpO1xuICAgICAgICAgICAgdmFyIHN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmsoc3RlcHMpO1xuICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoRUlTRElSLCAnb3BlbicsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZkID0gdGhpcy5vcGVuU3luYyhpZCwgZmxhZ3NOdW0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBidWZmZXJUb0VuY29kaW5nKHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkKS5nZXRCdWZmZXIoKSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCF1c2VyT3duc0ZkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRGaWxlU3luYyA9IGZ1bmN0aW9uIChmaWxlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRzID0gZ2V0UmVhZEZpbGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgZmxhZ3NOdW0gPSBmbGFnc1RvTnVtYmVyKG9wdHMuZmxhZyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRGaWxlQmFzZShmaWxlLCBmbGFnc051bSwgb3B0cy5lbmNvZGluZyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWRGaWxlID0gZnVuY3Rpb24gKGlkLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IG9wdHNBbmRDYkdlbmVyYXRvcihnZXRSZWFkRmlsZU9wdGlvbnMpKGEsIGIpLCBvcHRzID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHZhciBmbGFnc051bSA9IGZsYWdzVG9OdW1iZXIob3B0cy5mbGFnKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFkRmlsZUJhc2UsIFtpZCwgZmxhZ3NOdW0sIG9wdHMuZW5jb2RpbmddLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlQmFzZSA9IGZ1bmN0aW9uIChmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ3dyaXRlJyk7XG4gICAgICAgIHJldHVybiBmaWxlLndyaXRlKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUud3JpdGVTeW5jID0gZnVuY3Rpb24gKGZkLCBhLCBiLCBjLCBkKSB7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICB2YXIgZW5jb2Rpbmc7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgICAgdmFyIGlzQnVmZmVyID0gdHlwZW9mIGEgIT09ICdzdHJpbmcnO1xuICAgICAgICBpZiAoaXNCdWZmZXIpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGIgfCAwO1xuICAgICAgICAgICAgbGVuZ3RoID0gYztcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gYjtcbiAgICAgICAgICAgIGVuY29kaW5nID0gYztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gZGF0YVRvQnVmZmVyKGEsIGVuY29kaW5nKTtcbiAgICAgICAgaWYgKGlzQnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBidWYubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCYXNlKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGZkLCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhbGlkYXRlRmQoZmQpO1xuICAgICAgICB2YXIgb2Zmc2V0O1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgcG9zaXRpb247XG4gICAgICAgIHZhciBlbmNvZGluZztcbiAgICAgICAgdmFyIGNhbGxiYWNrO1xuICAgICAgICB2YXIgdGlwYSA9IHR5cGVvZiBhO1xuICAgICAgICB2YXIgdGlwYiA9IHR5cGVvZiBiO1xuICAgICAgICB2YXIgdGlwYyA9IHR5cGVvZiBjO1xuICAgICAgICB2YXIgdGlwZCA9IHR5cGVvZiBkO1xuICAgICAgICBpZiAodGlwYSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aXBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGIgfCAwO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpcGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBiIHwgMDtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBjO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGIgfCAwO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGM7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aXBiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGlwYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gYjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aXBkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBiO1xuICAgICAgICAgICAgICAgIGVuY29kaW5nID0gYztcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IGRhdGFUb0J1ZmZlcihhLCBlbmNvZGluZyk7XG4gICAgICAgIGlmICh0aXBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGVuZ3RoID0gYnVmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlXzEuZGVmYXVsdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlcyA9IF90aGlzLndyaXRlQmFzZShmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0aXBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBieXRlcywgYnVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJ5dGVzLCBhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlRmlsZUJhc2UgPSBmdW5jdGlvbiAoaWQsIGJ1ZiwgZmxhZ3NOdW0sIG1vZGVOdW0pIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3dyaXRlRmlsZUJhc2UnLCBpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgICAgIC8vIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGVCeUlkT3JDcmVhdGUoaWQsIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgLy8gbm9kZS5zZXRCdWZmZXIoYnVmKTtcbiAgICAgICAgdmFyIGlzVXNlckZkID0gdHlwZW9mIGlkID09PSAnbnVtYmVyJztcbiAgICAgICAgdmFyIGZkO1xuICAgICAgICBpZiAoaXNVc2VyRmQpXG4gICAgICAgICAgICBmZCA9IGlkO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZkID0gdGhpcy5vcGVuQmFzZShwYXRoVG9GaWxlbmFtZShpZCksIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgICAgIC8vIGZkID0gdGhpcy5vcGVuU3luYyhpZCBhcyBURmlsZVBhdGgsIGZsYWdzTnVtLCBtb2RlTnVtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGZsYWdzTnVtICYgT19BUFBFTkQgPyBudWxsIDogMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdyaXR0ZW4gPSB0aGlzLndyaXRlU3luYyhmZCwgYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB3cml0dGVuO1xuICAgICAgICAgICAgICAgIGxlbmd0aCAtPSB3cml0dGVuO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gd3JpdHRlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmICghaXNVc2VyRmQpXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlRmlsZVN5bmMgPSBmdW5jdGlvbiAoaWQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRXcml0ZUZpbGVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgZmxhZ3NOdW0gPSBmbGFnc1RvTnVtYmVyKG9wdHMuZmxhZyk7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG9wdHMubW9kZSk7XG4gICAgICAgIHZhciBidWYgPSBkYXRhVG9CdWZmZXIoZGF0YSwgb3B0cy5lbmNvZGluZyk7XG4gICAgICAgIHRoaXMud3JpdGVGaWxlQmFzZShpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLndyaXRlRmlsZSA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgYSwgYikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGE7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHdyaXRlRmlsZURlZmF1bHRzO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcHRzID0gZ2V0V3JpdGVGaWxlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIGZsYWdzTnVtID0gZmxhZ3NUb051bWJlcihvcHRzLmZsYWcpO1xuICAgICAgICB2YXIgbW9kZU51bSA9IG1vZGVUb051bWJlcihvcHRzLm1vZGUpO1xuICAgICAgICB2YXIgYnVmID0gZGF0YVRvQnVmZmVyKGRhdGEsIG9wdHMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLndyaXRlRmlsZUJhc2UsIFtpZCwgYnVmLCBmbGFnc051bSwgbW9kZU51bV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGlua0Jhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUxLCBmaWxlbmFtZTIpIHtcbiAgICAgICAgdmFyIHN0ZXBzMSA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZTEpO1xuICAgICAgICB2YXIgbGluazEgPSB0aGlzLmdldExpbmsoc3RlcHMxKTtcbiAgICAgICAgaWYgKCFsaW5rMSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnbGluaycsIGZpbGVuYW1lMSwgZmlsZW5hbWUyKTtcbiAgICAgICAgdmFyIHN0ZXBzMiA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZTIpO1xuICAgICAgICAvLyBDaGVjayBuZXcgbGluayBkaXJlY3RvcnkgZXhpc3RzLlxuICAgICAgICB2YXIgZGlyMiA9IHRoaXMuZ2V0TGlua1BhcmVudChzdGVwczIpO1xuICAgICAgICBpZiAoIWRpcjIpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ2xpbmsnLCBmaWxlbmFtZTEsIGZpbGVuYW1lMik7XG4gICAgICAgIHZhciBuYW1lID0gc3RlcHMyW3N0ZXBzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbmV3IGZpbGUgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIGlmIChkaXIyLmdldENoaWxkKG5hbWUpKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFRVhJU1QsICdsaW5rJywgZmlsZW5hbWUxLCBmaWxlbmFtZTIpO1xuICAgICAgICB2YXIgbm9kZSA9IGxpbmsxLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5ubGluaysrO1xuICAgICAgICBkaXIyLmNyZWF0ZUNoaWxkKG5hbWUsIG5vZGUpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jb3B5RmlsZUJhc2UgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncykge1xuICAgICAgICB2YXIgYnVmID0gdGhpcy5yZWFkRmlsZVN5bmMoc3JjKTtcbiAgICAgICAgaWYgKGZsYWdzICYgQ09QWUZJTEVfRVhDTCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhpc3RzU3luYyhkZXN0KSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoRUVYSVNULCAnY29weUZpbGUnLCBzcmMsIGRlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIENPUFlGSUxFX0ZJQ0xPTkVfRk9SQ0UpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PU1lTLCAnY29weUZpbGUnLCBzcmMsIGRlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVGaWxlQmFzZShkZXN0LCBidWYsIEZMQUdTLncsIDQzOCAvKiBERUZBVUxUICovKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY29weUZpbGVTeW5jID0gZnVuY3Rpb24gKHNyYywgZGVzdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHNyY0ZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoc3JjKTtcbiAgICAgICAgdmFyIGRlc3RGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKGRlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5RmlsZUJhc2Uoc3JjRmlsZW5hbWUsIGRlc3RGaWxlbmFtZSwgZmxhZ3MgfCAwKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY29weUZpbGUgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBhLCBiKSB7XG4gICAgICAgIHZhciBzcmNGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHNyYyk7XG4gICAgICAgIHZhciBkZXN0RmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShkZXN0KTtcbiAgICAgICAgdmFyIGZsYWdzO1xuICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZmxhZ3MgPSAwO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmxhZ3MgPSBhO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmNvcHlGaWxlQmFzZSwgW3NyY0ZpbGVuYW1lLCBkZXN0RmlsZW5hbWUsIGZsYWdzXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5saW5rU3luYyA9IGZ1bmN0aW9uIChleGlzdGluZ1BhdGgsIG5ld1BhdGgpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nUGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoZXhpc3RpbmdQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLmxpbmtCYXNlKGV4aXN0aW5nUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24gKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nUGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUoZXhpc3RpbmdQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmxpbmtCYXNlLCBbZXhpc3RpbmdQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudW5saW5rQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSkge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0TGluayhzdGVwcyk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAndW5saW5rJywgZmlsZW5hbWUpO1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiBpdCBpcyBmaWxlLCBkaXIsIG90aGVyLi4uXG4gICAgICAgIGlmIChsaW5rLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdEaXIgbm90IGVtcHR5Li4uJyk7XG4gICAgICAgIHRoaXMuZGVsZXRlTGluayhsaW5rKTtcbiAgICAgICAgdmFyIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5ubGluay0tO1xuICAgICAgICAvLyBXaGVuIGFsbCBoYXJkIGxpbmtzIHRvIGktbm9kZSBhcmUgZGVsZXRlZCwgcmVtb3ZlIHRoZSBpLW5vZGUsIHRvby5cbiAgICAgICAgaWYgKG5vZGUubmxpbmsgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnVubGlua1N5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy51bmxpbmtCYXNlKGZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnVubGlua0Jhc2UsIFtmaWxlbmFtZV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuc3ltbGlua0Jhc2UgPSBmdW5jdGlvbiAodGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZSkge1xuICAgICAgICB2YXIgcGF0aFN0ZXBzID0gZmlsZW5hbWVUb1N0ZXBzKHBhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIENoZWNrIGlmIGRpcmVjdG9yeSBleGlzdHMsIHdoZXJlIHdlIGFib3V0IHRvIGNyZWF0ZSBhIHN5bWxpbmsuXG4gICAgICAgIHZhciBkaXJMaW5rID0gdGhpcy5nZXRMaW5rUGFyZW50KHBhdGhTdGVwcyk7XG4gICAgICAgIGlmICghZGlyTGluaylcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PRU5ULCAnc3ltbGluaycsIHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpO1xuICAgICAgICB2YXIgbmFtZSA9IHBhdGhTdGVwc1twYXRoU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIENoZWNrIGlmIG5ldyBmaWxlIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICBpZiAoZGlyTGluay5nZXRDaGlsZChuYW1lKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUVYSVNULCAnc3ltbGluaycsIHRhcmdldEZpbGVuYW1lLCBwYXRoRmlsZW5hbWUpO1xuICAgICAgICAvLyBDcmVhdGUgc3ltbGluay5cbiAgICAgICAgdmFyIHN5bWxpbmsgPSBkaXJMaW5rLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICBzeW1saW5rLmdldE5vZGUoKS5tYWtlU3ltbGluayhmaWxlbmFtZVRvU3RlcHModGFyZ2V0RmlsZW5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHN5bWxpbms7XG4gICAgfTtcbiAgICAvLyBgdHlwZWAgYXJndW1lbnQgd29ya3Mgb25seSBvbiBXaW5kb3dzLlxuICAgIFZvbHVtZS5wcm90b3R5cGUuc3ltbGlua1N5bmMgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXRoLCB0eXBlKSB7XG4gICAgICAgIHZhciB0YXJnZXRGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5zeW1saW5rQmFzZSh0YXJnZXRGaWxlbmFtZSwgcGF0aEZpbGVuYW1lKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuc3ltbGluayA9IGZ1bmN0aW9uICh0YXJnZXQsIHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0QXJnQW5kQ2IoYSwgYiksIHR5cGUgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdmFyIHRhcmdldEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUodGFyZ2V0KTtcbiAgICAgICAgdmFyIHBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnN5bWxpbmtCYXNlLCBbdGFyZ2V0RmlsZW5hbWUsIHBhdGhGaWxlbmFtZV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhbHBhdGhCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBlbmNvZGluZykge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICB2YXIgcmVhbExpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhzdGVwcyk7XG4gICAgICAgIGlmICghcmVhbExpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ3JlYWxwYXRoJywgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKHJlYWxMaW5rLmdldFBhdGgoKSwgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFscGF0aFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFscGF0aEJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIGdldFJlYWxwYXRoT3B0aW9ucyhvcHRpb25zKS5lbmNvZGluZyk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJlYWxwYXRoID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0UmVhbHBhdGhPcHRzQW5kQ2IoYSwgYiksIG9wdHMgPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdmFyIHBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlYWxwYXRoQmFzZSwgW3BhdGhGaWxlbmFtZSwgb3B0cy5lbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubHN0YXRCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBiaWdpbnQpIHtcbiAgICAgICAgaWYgKGJpZ2ludCA9PT0gdm9pZCAwKSB7IGJpZ2ludCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rKGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSkpO1xuICAgICAgICBpZiAoIWxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ2xzdGF0JywgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGxpbmsuZ2V0Tm9kZSgpLCBiaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5sc3RhdFN5bmMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5sc3RhdEJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIGdldFN0YXRPcHRpb25zKG9wdGlvbnMpLmJpZ2ludCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxzdGF0ID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0U3RhdE9wdHNBbmRDYihhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLmxzdGF0QmFzZSwgW3BhdGhUb0ZpbGVuYW1lKHBhdGgpLCBvcHRzLmJpZ2ludF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuc3RhdEJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGJpZ2ludCkge1xuICAgICAgICBpZiAoYmlnaW50ID09PSB2b2lkIDApIHsgYmlnaW50ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldFJlc29sdmVkTGluayhmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdzdGF0JywgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKGxpbmsuZ2V0Tm9kZSgpLCBiaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5zdGF0U3luYyA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCBnZXRTdGF0T3B0aW9ucyhvcHRpb25zKS5iaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0U3RhdE9wdHNBbmRDYihhLCBiKSwgb3B0cyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnN0YXRCYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIG9wdHMuYmlnaW50XSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3RhdEJhc2UgPSBmdW5jdGlvbiAoZmQsIGJpZ2ludCkge1xuICAgICAgICBpZiAoYmlnaW50ID09PSB2b2lkIDApIHsgYmlnaW50ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmdldEZpbGVCeUZkKGZkKTtcbiAgICAgICAgaWYgKCFmaWxlKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFQkFERiwgJ2ZzdGF0Jyk7XG4gICAgICAgIHJldHVybiBTdGF0c18xLmRlZmF1bHQuYnVpbGQoZmlsZS5ub2RlLCBiaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3RhdFN5bmMgPSBmdW5jdGlvbiAoZmQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnN0YXRCYXNlKGZkLCBnZXRTdGF0T3B0aW9ucyhvcHRpb25zKS5iaWdpbnQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3RhdCA9IGZ1bmN0aW9uIChmZCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXRTdGF0T3B0c0FuZENiKGEsIGIpLCBvcHRzID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnN0YXRCYXNlLCBbZmQsIG9wdHMuYmlnaW50XSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZW5hbWVCYXNlID0gZnVuY3Rpb24gKG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rKGZpbGVuYW1lVG9TdGVwcyhvbGRQYXRoRmlsZW5hbWUpKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdyZW5hbWUnLCBvbGRQYXRoRmlsZW5hbWUsIG5ld1BhdGhGaWxlbmFtZSk7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIGl0IGlzIGRpcmVjdG9yeSwgaWYgbm9uLWVtcHR5LCB3ZSBjYW5ub3QgbW92ZSBpdCwgcmlnaHQ/XG4gICAgICAgIHZhciBuZXdQYXRoU3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMobmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gQ2hlY2sgZGlyZWN0b3J5IGV4aXN0cyBmb3IgdGhlIG5ldyBsb2NhdGlvbi5cbiAgICAgICAgdmFyIG5ld1BhdGhEaXJMaW5rID0gdGhpcy5nZXRMaW5rUGFyZW50KG5ld1BhdGhTdGVwcyk7XG4gICAgICAgIGlmICghbmV3UGF0aERpckxpbmspXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT0VOVCwgJ3JlbmFtZScsIG9sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lKTtcbiAgICAgICAgLy8gVE9ETzogQWxzbyB0cmVhdCBjYXNlcyB3aXRoIGRpcmVjdG9yaWVzIGFuZCBzeW1ib2xpYyBsaW5rcy5cbiAgICAgICAgLy8gVE9ETzogU2VlOiBodHRwOi8vbWFuNy5vcmcvbGludXgvbWFuLXBhZ2VzL21hbjIvcmVuYW1lLjIuaHRtbFxuICAgICAgICAvLyBSZW1vdmUgaGFyZCBsaW5rIGZyb20gb2xkIGZvbGRlci5cbiAgICAgICAgdmFyIG9sZExpbmtQYXJlbnQgPSBsaW5rLnBhcmVudDtcbiAgICAgICAgaWYgKG9sZExpbmtQYXJlbnQpIHtcbiAgICAgICAgICAgIG9sZExpbmtQYXJlbnQuZGVsZXRlQ2hpbGQobGluayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuYW1lIHNob3VsZCBvdmVyd3JpdGUgdGhlIG5ldyBwYXRoLCBpZiB0aGF0IGV4aXN0cy5cbiAgICAgICAgdmFyIG5hbWUgPSBuZXdQYXRoU3RlcHNbbmV3UGF0aFN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsaW5rLnN0ZXBzID0gX19zcHJlYWRBcnJheXMobmV3UGF0aERpckxpbmsuc3RlcHMsIFtuYW1lXSk7XG4gICAgICAgIG5ld1BhdGhEaXJMaW5rLnNldENoaWxkKGxpbmsuZ2V0TmFtZSgpLCBsaW5rKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVuYW1lU3luYyA9IGZ1bmN0aW9uIChvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICAgIHZhciBvbGRQYXRoRmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShvbGRQYXRoKTtcbiAgICAgICAgdmFyIG5ld1BhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG5ld1BhdGgpO1xuICAgICAgICB0aGlzLnJlbmFtZUJhc2Uob2xkUGF0aEZpbGVuYW1lLCBuZXdQYXRoRmlsZW5hbWUpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiAob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIG9sZFBhdGhGaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKG9sZFBhdGgpO1xuICAgICAgICB2YXIgbmV3UGF0aEZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUobmV3UGF0aCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMucmVuYW1lQmFzZSwgW29sZFBhdGhGaWxlbmFtZSwgbmV3UGF0aEZpbGVuYW1lXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5leGlzdHNCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RhdEJhc2UoZmlsZW5hbWUpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5leGlzdHNTeW5jID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4aXN0c0Jhc2UocGF0aFRvRmlsZW5hbWUocGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5leGlzdHMgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihFUlJTVFIuQ0IpO1xuICAgICAgICBzZXRJbW1lZGlhdGVfMS5kZWZhdWx0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soX3RoaXMuZXhpc3RzQmFzZShmaWxlbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmFjY2Vzc0Jhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIG1vZGUpIHtcbiAgICAgICAgdmFyIGxpbmsgPSB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCAnYWNjZXNzJyk7XG4gICAgICAgIC8vIFRPRE86IFZlcmlmeSBwZXJtaXNzaW9uc1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5hY2Nlc3NTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gRl9PSzsgfVxuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgbW9kZSA9IG1vZGUgfCAwO1xuICAgICAgICB0aGlzLmFjY2Vzc0Jhc2UoZmlsZW5hbWUsIG1vZGUpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5hY2Nlc3MgPSBmdW5jdGlvbiAocGF0aCwgYSwgYikge1xuICAgICAgICB2YXIgbW9kZSA9IGE7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGI7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbW9kZSA9IEZfT0s7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIG1vZGUgPSBtb2RlIHwgMDtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5hY2Nlc3NCYXNlLCBbZmlsZW5hbWUsIG1vZGVdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmFwcGVuZEZpbGVTeW5jID0gZnVuY3Rpb24gKGlkLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IGFwcGVuZEZpbGVEZWZhdWx0czsgfVxuICAgICAgICB2YXIgb3B0cyA9IGdldEFwcGVuZEZpbGVPcHRzKG9wdGlvbnMpO1xuICAgICAgICAvLyBmb3JjZSBhcHBlbmQgYmVoYXZpb3Igd2hlbiB1c2luZyBhIHN1cHBsaWVkIGZpbGUgZGVzY3JpcHRvclxuICAgICAgICBpZiAoIW9wdHMuZmxhZyB8fCBpc0ZkKGlkKSlcbiAgICAgICAgICAgIG9wdHMuZmxhZyA9ICdhJztcbiAgICAgICAgdGhpcy53cml0ZUZpbGVTeW5jKGlkLCBkYXRhLCBvcHRzKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuYXBwZW5kRmlsZSA9IGZ1bmN0aW9uIChpZCwgZGF0YSwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXRBcHBlbmRGaWxlT3B0c0FuZENiKGEsIGIpLCBvcHRzID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIC8vIGZvcmNlIGFwcGVuZCBiZWhhdmlvciB3aGVuIHVzaW5nIGEgc3VwcGxpZWQgZmlsZSBkZXNjcmlwdG9yXG4gICAgICAgIGlmICghb3B0cy5mbGFnIHx8IGlzRmQoaWQpKVxuICAgICAgICAgICAgb3B0cy5mbGFnID0gJ2EnO1xuICAgICAgICB0aGlzLndyaXRlRmlsZShpZCwgZGF0YSwgb3B0cywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkZGlyQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0UmVzb2x2ZWRMaW5rKHN0ZXBzKTtcbiAgICAgICAgaWYgKCFsaW5rKVxuICAgICAgICAgICAgdGhyb3dFcnJvcihFTk9FTlQsICdyZWFkZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICB2YXIgbm9kZSA9IGxpbmsuZ2V0Tm9kZSgpO1xuICAgICAgICBpZiAoIW5vZGUuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRU5PVERJUiwgJ3NjYW5kaXInLCBmaWxlbmFtZSk7XG4gICAgICAgIGlmIChvcHRpb25zLndpdGhGaWxlVHlwZXMpIHtcbiAgICAgICAgICAgIHZhciBsaXN0XzEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMyBpbiBsaW5rLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbGlzdF8xLnB1c2goRGlyZW50XzEuZGVmYXVsdC5idWlsZChsaW5rLmNoaWxkcmVuW25hbWVfM10sIG9wdGlvbnMuZW5jb2RpbmcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNXaW4gJiYgb3B0aW9ucy5lbmNvZGluZyAhPT0gJ2J1ZmZlcicpXG4gICAgICAgICAgICAgICAgbGlzdF8xLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEubmFtZSA8IGIubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEubmFtZSA+IGIubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0XzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV80IGluIGxpbmsuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxpc3QucHVzaChlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcobmFtZV80LCBvcHRpb25zLmVuY29kaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1dpbiAmJiBvcHRpb25zLmVuY29kaW5nICE9PSAnYnVmZmVyJylcbiAgICAgICAgICAgIGxpc3Quc29ydCgpO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGRpclN5bmMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IGdldFJlYWRkaXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGRpckJhc2UoZmlsZW5hbWUsIG9wdHMpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24gKHBhdGgsIGEsIGIpIHtcbiAgICAgICAgdmFyIF9hID0gZ2V0UmVhZGRpck9wdHNBbmRDYihhLCBiKSwgb3B0aW9ucyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5yZWFkZGlyQmFzZSwgW2ZpbGVuYW1lLCBvcHRpb25zXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkbGlua0Jhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIGVuY29kaW5nKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rT3JUaHJvdyhmaWxlbmFtZSwgJ3JlYWRsaW5rJyk7XG4gICAgICAgIHZhciBub2RlID0gbGluay5nZXROb2RlKCk7XG4gICAgICAgIGlmICghbm9kZS5pc1N5bWxpbmsoKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUlOVkFMLCAncmVhZGxpbmsnLCBmaWxlbmFtZSk7XG4gICAgICAgIHZhciBzdHIgPSBzZXAgKyBub2RlLnN5bWxpbmsuam9pbihzZXApO1xuICAgICAgICByZXR1cm4gZW5jb2RpbmdfMS5zdHJUb0VuY29kaW5nKHN0ciwgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5yZWFkbGlua1N5bmMgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0cyA9IGdldERlZmF1bHRPcHRzKG9wdGlvbnMpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZGxpbmtCYXNlKGZpbGVuYW1lLCBvcHRzLmVuY29kaW5nKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbiAocGF0aCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0T3B0c0FuZENiKGEsIGIpLCBvcHRzID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnJlYWRsaW5rQmFzZSwgW2ZpbGVuYW1lLCBvcHRzLmVuY29kaW5nXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3luY0Jhc2UgPSBmdW5jdGlvbiAoZmQpIHtcbiAgICAgICAgdGhpcy5nZXRGaWxlQnlGZE9yVGhyb3coZmQsICdmc3luYycpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3luY1N5bmMgPSBmdW5jdGlvbiAoZmQpIHtcbiAgICAgICAgdGhpcy5mc3luY0Jhc2UoZmQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mc3luYyA9IGZ1bmN0aW9uIChmZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mc3luY0Jhc2UsIFtmZF0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmRhdGFzeW5jQmFzZSA9IGZ1bmN0aW9uIChmZCkge1xuICAgICAgICB0aGlzLmdldEZpbGVCeUZkT3JUaHJvdyhmZCwgJ2ZkYXRhc3luYycpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mZGF0YXN5bmNTeW5jID0gZnVuY3Rpb24gKGZkKSB7XG4gICAgICAgIHRoaXMuZmRhdGFzeW5jQmFzZShmZCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZkYXRhc3luYyA9IGZ1bmN0aW9uIChmZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mZGF0YXN5bmNCYXNlLCBbZmRdLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZ0cnVuY2F0ZUJhc2UgPSBmdW5jdGlvbiAoZmQsIGxlbikge1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZnRydW5jYXRlJyk7XG4gICAgICAgIGZpbGUudHJ1bmNhdGUobGVuKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnRydW5jYXRlU3luYyA9IGZ1bmN0aW9uIChmZCwgbGVuKSB7XG4gICAgICAgIHRoaXMuZnRydW5jYXRlQmFzZShmZCwgbGVuKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnRydW5jYXRlID0gZnVuY3Rpb24gKGZkLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldEFyZ0FuZENiKGEsIGIpLCBsZW4gPSBfYVswXSwgY2FsbGJhY2sgPSBfYVsxXTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mdHJ1bmNhdGVCYXNlLCBbZmQsIGxlbl0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudHJ1bmNhdGVCYXNlID0gZnVuY3Rpb24gKHBhdGgsIGxlbikge1xuICAgICAgICB2YXIgZmQgPSB0aGlzLm9wZW5TeW5jKHBhdGgsICdyKycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mdHJ1bmNhdGVTeW5jKGZkLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnRydW5jYXRlU3luYyA9IGZ1bmN0aW9uIChpZCwgbGVuKSB7XG4gICAgICAgIGlmIChpc0ZkKGlkKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ0cnVuY2F0ZVN5bmMoaWQsIGxlbik7XG4gICAgICAgIHRoaXMudHJ1bmNhdGVCYXNlKGlkLCBsZW4pO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uIChpZCwgYSwgYikge1xuICAgICAgICBpZiAoaXNGZChpZCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdHJ1bmNhdGUoaWQsIGEsIGIpO1xuICAgICAgICB2YXIgX2EgPSBnZXRBcmdBbmRDYihhLCBiLCAwKSwgbGVuID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMudHJ1bmNhdGVCYXNlLCBbaWQsIGxlbl0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZnV0aW1lc0Jhc2UgPSBmdW5jdGlvbiAoZmQsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZnV0aW1lcycpO1xuICAgICAgICB2YXIgbm9kZSA9IGZpbGUubm9kZTtcbiAgICAgICAgbm9kZS5hdGltZSA9IG5ldyBEYXRlKGF0aW1lICogMTAwMCk7XG4gICAgICAgIG5vZGUubXRpbWUgPSBuZXcgRGF0ZShtdGltZSAqIDEwMDApO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mdXRpbWVzU3luYyA9IGZ1bmN0aW9uIChmZCwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHRoaXMuZnV0aW1lc0Jhc2UoZmQsIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSkpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mdXRpbWVzID0gZnVuY3Rpb24gKGZkLCBhdGltZSwgbXRpbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZnV0aW1lc0Jhc2UsIFtmZCwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudXRpbWVzQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgYXRpbWUsIG10aW1lKSB7XG4gICAgICAgIHZhciBmZCA9IHRoaXMub3BlblN5bmMoZmlsZW5hbWUsICdyKycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mdXRpbWVzQmFzZShmZCwgYXRpbWUsIG10aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS51dGltZXNTeW5jID0gZnVuY3Rpb24gKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAgICAgICB0aGlzLnV0aW1lc0Jhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIHRvVW5peFRpbWVzdGFtcChhdGltZSksIHRvVW5peFRpbWVzdGFtcChtdGltZSkpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS51dGltZXMgPSBmdW5jdGlvbiAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLnV0aW1lc0Jhc2UsIFtwYXRoVG9GaWxlbmFtZShwYXRoKSwgdG9Vbml4VGltZXN0YW1wKGF0aW1lKSwgdG9Vbml4VGltZXN0YW1wKG10aW1lKV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkaXJCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCBtb2RlTnVtKSB7XG4gICAgICAgIHZhciBzdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyhmaWxlbmFtZSk7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiB1c2VyIHRyaWVzIHRvIGNyZWF0ZSByb290IGRpciBgZnMubWtkaXJTeW5jKCcvJylgLlxuICAgICAgICBpZiAoIXN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihFSVNESVIsICdta2RpcicsIGZpbGVuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0gdGhpcy5nZXRMaW5rUGFyZW50QXNEaXJPclRocm93KGZpbGVuYW1lLCAnbWtkaXInKTtcbiAgICAgICAgLy8gQ2hlY2sgcGF0aCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgdmFyIG5hbWUgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGRpci5nZXRDaGlsZChuYW1lKSlcbiAgICAgICAgICAgIHRocm93RXJyb3IoRUVYSVNULCAnbWtkaXInLCBmaWxlbmFtZSk7XG4gICAgICAgIGRpci5jcmVhdGVDaGlsZChuYW1lLCB0aGlzLmNyZWF0ZU5vZGUodHJ1ZSwgbW9kZU51bSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBkaXJlY3RvcnkgdHJlZSByZWN1cnNpdmVseS5cbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gbW9kZU51bVxuICAgICAqL1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkaXJwQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICB2YXIgc3RlcHMgPSBmaWxlbmFtZVRvU3RlcHMoZmlsZW5hbWUpO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMucm9vdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tpXTtcbiAgICAgICAgICAgIGlmICghbGluay5nZXROb2RlKCkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKEVOT1RESVIsICdta2RpcicsIGxpbmsuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGxpbmsuZ2V0Q2hpbGQoc3RlcCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZ2V0Tm9kZSgpLmlzRGlyZWN0b3J5KCkpXG4gICAgICAgICAgICAgICAgICAgIGxpbmsgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoRU5PVERJUiwgJ21rZGlyJywgY2hpbGQuZ2V0UGF0aCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmsgPSBsaW5rLmNyZWF0ZUNoaWxkKHN0ZXAsIHRoaXMuY3JlYXRlTm9kZSh0cnVlLCBtb2RlTnVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkaXJTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG9wdHMgPSBnZXRNa2Rpck9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG9wdHMubW9kZSwgNTExKTtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIGlmIChvcHRzLnJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIHRoaXMubWtkaXJwQmFzZShmaWxlbmFtZSwgbW9kZU51bSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMubWtkaXJCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubWtkaXIgPSBmdW5jdGlvbiAocGF0aCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXRBcmdBbmRDYihhLCBiKSwgb3B0aW9ucyA9IF9hWzBdLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICB2YXIgb3B0cyA9IGdldE1rZGlyT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIob3B0cy5tb2RlLCA1MTEpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgaWYgKG9wdHMucmVjdXJzaXZlKVxuICAgICAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ta2RpcnBCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMubWtkaXJCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBsZWdhY3kgaW50ZXJmYWNlXG4gICAgVm9sdW1lLnByb3RvdHlwZS5ta2RpcnBTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgdGhpcy5ta2RpclN5bmMocGF0aCwgeyBtb2RlOiBtb2RlLCByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLm1rZGlycCA9IGZ1bmN0aW9uIChwYXRoLCBhLCBiKSB7XG4gICAgICAgIHZhciBfYSA9IGdldEFyZ0FuZENiKGEsIGIpLCBtb2RlID0gX2FbMF0sIGNhbGxiYWNrID0gX2FbMV07XG4gICAgICAgIHRoaXMubWtkaXIocGF0aCwgeyBtb2RlOiBtb2RlLCByZWN1cnNpdmU6IHRydWUgfSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5ta2R0ZW1wQmFzZSA9IGZ1bmN0aW9uIChwcmVmaXgsIGVuY29kaW5nLCByZXRyeSkge1xuICAgICAgICBpZiAocmV0cnkgPT09IHZvaWQgMCkgeyByZXRyeSA9IDU7IH1cbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcHJlZml4ICsgdGhpcy5nZW5SbmRTdHIoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubWtkaXJCYXNlKGZpbGVuYW1lLCA1MTEgLyogRElSICovKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGluZ18xLnN0clRvRW5jb2RpbmcoZmlsZW5hbWUsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IEVFWElTVCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeSA+IDEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWtkdGVtcEJhc2UocHJlZml4LCBlbmNvZGluZywgcmV0cnkgLSAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIHRlbXAgZGlyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5ta2R0ZW1wU3luYyA9IGZ1bmN0aW9uIChwcmVmaXgsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gZ2V0RGVmYXVsdE9wdHMob3B0aW9ucykuZW5jb2Rpbmc7XG4gICAgICAgIGlmICghcHJlZml4IHx8IHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmlsZW5hbWUgcHJlZml4IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIGlmICghbnVsbENoZWNrKHByZWZpeCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB0aGlzLm1rZHRlbXBCYXNlKHByZWZpeCwgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5ta2R0ZW1wID0gZnVuY3Rpb24gKHByZWZpeCwgYSwgYikge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0T3B0c0FuZENiKGEsIGIpLCBlbmNvZGluZyA9IF9hWzBdLmVuY29kaW5nLCBjYWxsYmFjayA9IF9hWzFdO1xuICAgICAgICBpZiAoIXByZWZpeCB8fCB0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGVuYW1lIHByZWZpeCBpcyByZXF1aXJlZCcpO1xuICAgICAgICBpZiAoIW51bGxDaGVjayhwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLndyYXBBc3luYyh0aGlzLm1rZHRlbXBCYXNlLCBbcHJlZml4LCBlbmNvZGluZ10sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucm1kaXJCYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRMaW5rQXNEaXJPclRocm93KGZpbGVuYW1lLCAncm1kaXInKTtcbiAgICAgICAgLy8gQ2hlY2sgZGlyZWN0b3J5IGlzIGVtcHR5LlxuICAgICAgICBpZiAobGluay5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvd0Vycm9yKEVOT1RFTVBUWSwgJ3JtZGlyJywgZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmRlbGV0ZUxpbmsobGluayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLnJtZGlyU3luYyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHRoaXMucm1kaXJCYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUucm1kaXIgPSBmdW5jdGlvbiAocGF0aCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5ybWRpckJhc2UsIFtwYXRoVG9GaWxlbmFtZShwYXRoKV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmNobW9kQmFzZSA9IGZ1bmN0aW9uIChmZCwgbW9kZU51bSkge1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZmNobW9kJyk7XG4gICAgICAgIGZpbGUuY2htb2QobW9kZU51bSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZjaG1vZFN5bmMgPSBmdW5jdGlvbiAoZmQsIG1vZGUpIHtcbiAgICAgICAgdGhpcy5mY2htb2RCYXNlKGZkLCBtb2RlVG9OdW1iZXIobW9kZSkpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mY2htb2QgPSBmdW5jdGlvbiAoZmQsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuZmNobW9kQmFzZSwgW2ZkLCBtb2RlVG9OdW1iZXIobW9kZSldLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNobW9kQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICB2YXIgZmQgPSB0aGlzLm9wZW5TeW5jKGZpbGVuYW1lLCAncisnKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZmNobW9kQmFzZShmZCwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2htb2RTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgdmFyIG1vZGVOdW0gPSBtb2RlVG9OdW1iZXIobW9kZSk7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLmNobW9kQmFzZShmaWxlbmFtZSwgbW9kZU51bSk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5jaG1vZEJhc2UsIFtmaWxlbmFtZSwgbW9kZU51bV0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGNobW9kQmFzZSA9IGZ1bmN0aW9uIChmaWxlbmFtZSwgbW9kZU51bSkge1xuICAgICAgICB2YXIgZmQgPSB0aGlzLm9wZW5CYXNlKGZpbGVuYW1lLCBPX1JEV1IsIDAsIGZhbHNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZmNobW9kQmFzZShmZCwgbW9kZU51bSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3luYyhmZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGNobW9kU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5sY2htb2RCYXNlKGZpbGVuYW1lLCBtb2RlTnVtKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBtb2RlTnVtID0gbW9kZVRvTnVtYmVyKG1vZGUpO1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sY2htb2RCYXNlLCBbZmlsZW5hbWUsIG1vZGVOdW1dLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmZjaG93bkJhc2UgPSBmdW5jdGlvbiAoZmQsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHRoaXMuZ2V0RmlsZUJ5RmRPclRocm93KGZkLCAnZmNob3duJykuY2hvd24odWlkLCBnaWQpO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5mY2hvd25TeW5jID0gZnVuY3Rpb24gKGZkLCB1aWQsIGdpZCkge1xuICAgICAgICB2YWxpZGF0ZVVpZCh1aWQpO1xuICAgICAgICB2YWxpZGF0ZUdpZChnaWQpO1xuICAgICAgICB0aGlzLmZjaG93bkJhc2UoZmQsIHVpZCwgZ2lkKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuZmNob3duID0gZnVuY3Rpb24gKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5mY2hvd25CYXNlLCBbZmQsIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jaG93bkJhc2UgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHVpZCwgZ2lkKSB7XG4gICAgICAgIHZhciBsaW5rID0gdGhpcy5nZXRSZXNvbHZlZExpbmtPclRocm93KGZpbGVuYW1lLCAnY2hvd24nKTtcbiAgICAgICAgdmFyIG5vZGUgPSBsaW5rLmdldE5vZGUoKTtcbiAgICAgICAgbm9kZS5jaG93bih1aWQsIGdpZCk7XG4gICAgICAgIC8vIGlmKG5vZGUuaXNGaWxlKCkgfHwgbm9kZS5pc1N5bWxpbmsoKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyB9IGVsc2UgaWYobm9kZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IFdoYXQgZG8gd2UgZG8gaGVyZT9cbiAgICAgICAgLy8gfVxuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5jaG93blN5bmMgPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy5jaG93bkJhc2UocGF0aFRvRmlsZW5hbWUocGF0aCksIHVpZCwgZ2lkKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlVWlkKHVpZCk7XG4gICAgICAgIHZhbGlkYXRlR2lkKGdpZCk7XG4gICAgICAgIHRoaXMud3JhcEFzeW5jKHRoaXMuY2hvd25CYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS5sY2hvd25CYXNlID0gZnVuY3Rpb24gKGZpbGVuYW1lLCB1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLmdldExpbmtPclRocm93KGZpbGVuYW1lLCAnbGNob3duJylcbiAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgIC5jaG93bih1aWQsIGdpZCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxjaG93blN5bmMgPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQpIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy5sY2hvd25CYXNlKHBhdGhUb0ZpbGVuYW1lKHBhdGgpLCB1aWQsIGdpZCk7XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmxjaG93biA9IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFsaWRhdGVVaWQodWlkKTtcbiAgICAgICAgdmFsaWRhdGVHaWQoZ2lkKTtcbiAgICAgICAgdGhpcy53cmFwQXN5bmModGhpcy5sY2hvd25CYXNlLCBbcGF0aFRvRmlsZW5hbWUocGF0aCksIHVpZCwgZ2lkXSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgVm9sdW1lLnByb3RvdHlwZS53YXRjaEZpbGUgPSBmdW5jdGlvbiAocGF0aCwgYSwgYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhO1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBiO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gYTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdcIndhdGNoRmlsZSgpXCIgcmVxdWlyZXMgYSBsaXN0ZW5lciBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDUwMDc7XG4gICAgICAgIHZhciBwZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW50ZXJ2YWwgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wZXJzaXN0ZW50ID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICAgICAgcGVyc2lzdGVudCA9IG9wdGlvbnMucGVyc2lzdGVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuc3RhdFdhdGNoZXJzW2ZpbGVuYW1lXTtcbiAgICAgICAgaWYgKCF3YXRjaGVyKSB7XG4gICAgICAgICAgICB3YXRjaGVyID0gbmV3IHRoaXMuU3RhdFdhdGNoZXIoKTtcbiAgICAgICAgICAgIHdhdGNoZXIuc3RhcnQoZmlsZW5hbWUsIHBlcnNpc3RlbnQsIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdFdhdGNoZXJzW2ZpbGVuYW1lXSA9IHdhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgICAgd2F0Y2hlci5hZGRMaXN0ZW5lcignY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gd2F0Y2hlcjtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUudW53YXRjaEZpbGUgPSBmdW5jdGlvbiAocGF0aCwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGZpbGVuYW1lID0gcGF0aFRvRmlsZW5hbWUocGF0aCk7XG4gICAgICAgIHZhciB3YXRjaGVyID0gdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICBpZiAoIXdhdGNoZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdhdGNoZXIucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhdGNoZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2F0Y2hlci5saXN0ZW5lckNvdW50KCdjaGFuZ2UnKSA9PT0gMCkge1xuICAgICAgICAgICAgd2F0Y2hlci5zdG9wKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdGF0V2F0Y2hlcnNbZmlsZW5hbWVdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWb2x1bWUucHJvdG90eXBlLmNyZWF0ZVJlYWRTdHJlYW0gPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFZvbHVtZS5wcm90b3R5cGUuY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvLyB3YXRjaChwYXRoOiBURmlsZVBhdGgpOiBGU1dhdGNoZXI7XG4gICAgLy8gd2F0Y2gocGF0aDogVEZpbGVQYXRoLCBvcHRpb25zPzogSVdhdGNoT3B0aW9ucyB8IHN0cmluZyk6IEZTV2F0Y2hlcjtcbiAgICBWb2x1bWUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdE9wdHMob3B0aW9ucyksIHBlcnNpc3RlbnQgPSBfYS5wZXJzaXN0ZW50LCByZWN1cnNpdmUgPSBfYS5yZWN1cnNpdmUsIGVuY29kaW5nID0gX2EuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChwZXJzaXN0ZW50ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwZXJzaXN0ZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVjdXJzaXZlID0gZmFsc2U7XG4gICAgICAgIHZhciB3YXRjaGVyID0gbmV3IHRoaXMuRlNXYXRjaGVyKCk7XG4gICAgICAgIHdhdGNoZXIuc3RhcnQoZmlsZW5hbWUsIHBlcnNpc3RlbnQsIHJlY3Vyc2l2ZSwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdhdGNoZXIuYWRkTGlzdGVuZXIoJ2NoYW5nZScsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdsb2JhbCBmaWxlIGRlc2NyaXB0b3IgY291bnRlci4gVU5JWCBmaWxlIGRlc2NyaXB0b3JzIHN0YXJ0IGZyb20gMCBhbmQgZ28gc2VxdWVudGlhbGx5XG4gICAgICogdXAsIHNvIGhlcmUsIGluIG9yZGVyIG5vdCB0byBjb25mbGljdCB3aXRoIHRoZW0sIHdlIGNob29zZSBzb21lIGJpZyBudW1iZXIgYW5kIGRlc2NyZWFzZVxuICAgICAqIHRoZSBmaWxlIGRlc2NyaXB0b3Igb2YgZXZlcnkgbmV3IG9wZW5lZCBmaWxlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHRvZG8gVGhpcyBzaG91bGQgbm90IGJlIHN0YXRpYywgcmlnaHQ/XG4gICAgICovXG4gICAgVm9sdW1lLmZkID0gMHg3ZmZmZmZmZjtcbiAgICByZXR1cm4gVm9sdW1lO1xufSgpKTtcbmV4cG9ydHMuVm9sdW1lID0gVm9sdW1lO1xuZnVuY3Rpb24gZW1pdFN0b3Aoc2VsZikge1xuICAgIHNlbGYuZW1pdCgnc3RvcCcpO1xufVxudmFyIFN0YXRXYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdGF0V2F0Y2hlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdGF0V2F0Y2hlcih2b2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudm9sID0gbnVsbDtcbiAgICAgICAgX3RoaXMudGltZW91dFJlZiA9IG51bGw7XG4gICAgICAgIF90aGlzLnByZXYgPSBudWxsO1xuICAgICAgICBfdGhpcy5vbkludGVydmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHMgPSBfdGhpcy52b2wuc3RhdFN5bmMoX3RoaXMuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5oYXNDaGFuZ2VkKHN0YXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjaGFuZ2UnLCBzdGF0cywgX3RoaXMucHJldik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXYgPSBzdGF0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnZvbCA9IHZvbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdGF0V2F0Y2hlci5wcm90b3R5cGUubG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0UmVmID0gdGhpcy5zZXRUaW1lb3V0KHRoaXMub25JbnRlcnZhbCwgdGhpcy5pbnRlcnZhbCk7XG4gICAgfTtcbiAgICBTdGF0V2F0Y2hlci5wcm90b3R5cGUuaGFzQ2hhbmdlZCA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICAvLyBpZighdGhpcy5wcmV2KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0cy5tdGltZU1zID4gdGhpcy5wcmV2Lm10aW1lTXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHN0YXRzLm5saW5rICE9PSB0aGlzLnByZXYubmxpbmspXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RhdFdhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBhdGgsIHBlcnNpc3RlbnQsIGludGVydmFsKSB7XG4gICAgICAgIGlmIChwZXJzaXN0ZW50ID09PSB2b2lkIDApIHsgcGVyc2lzdGVudCA9IHRydWU7IH1cbiAgICAgICAgaWYgKGludGVydmFsID09PSB2b2lkIDApIHsgaW50ZXJ2YWwgPSA1MDA3OyB9XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0ID0gcGVyc2lzdGVudCA/IHNldFRpbWVvdXQgOiBzZXRUaW1lb3V0VW5yZWZfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMucHJldiA9IHRoaXMudm9sLnN0YXRTeW5jKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICB0aGlzLmxvb3AoKTtcbiAgICB9O1xuICAgIFN0YXRXYXRjaGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgICAgICAgcHJvY2Vzc18xLmRlZmF1bHQubmV4dFRpY2soZW1pdFN0b3AsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRXYXRjaGVyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuU3RhdFdhdGNoZXIgPSBTdGF0V2F0Y2hlcjtcbnZhciBwb29sO1xuZnVuY3Rpb24gYWxsb2NOZXdQb29sKHBvb2xTaXplKSB7XG4gICAgcG9vbCA9IGJ1ZmZlcl8xLmJ1ZmZlckFsbG9jVW5zYWZlKHBvb2xTaXplKTtcbiAgICBwb29sLnVzZWQgPSAwO1xufVxudXRpbC5pbmhlcml0cyhGc1JlYWRTdHJlYW0sIHN0cmVhbV8xLlJlYWRhYmxlKTtcbmV4cG9ydHMuUmVhZFN0cmVhbSA9IEZzUmVhZFN0cmVhbTtcbmZ1bmN0aW9uIEZzUmVhZFN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRnNSZWFkU3RyZWFtKSlcbiAgICAgICAgcmV0dXJuIG5ldyBGc1JlYWRTdHJlYW0odm9sLCBwYXRoLCBvcHRpb25zKTtcbiAgICB0aGlzLl92b2wgPSB2b2w7XG4gICAgLy8gYSBsaXR0bGUgYml0IGJpZ2dlciBidWZmZXIgYW5kIHdhdGVyIG1hcmtzIGJ5IGRlZmF1bHRcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBnZXRPcHRpb25zKG9wdGlvbnMsIHt9KSk7XG4gICAgaWYgKG9wdGlvbnMuaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBvcHRpb25zLmhpZ2hXYXRlck1hcmsgPSA2NCAqIDEwMjQ7XG4gICAgc3RyZWFtXzEuUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICB0aGlzLmZkID0gb3B0aW9ucy5mZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZmQ7XG4gICAgdGhpcy5mbGFncyA9IG9wdGlvbnMuZmxhZ3MgPT09IHVuZGVmaW5lZCA/ICdyJyA6IG9wdGlvbnMuZmxhZ3M7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQgPyA0MzggOiBvcHRpb25zLm1vZGU7XG4gICAgdGhpcy5zdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBvcHRpb25zLmVuZDtcbiAgICB0aGlzLmF1dG9DbG9zZSA9IG9wdGlvbnMuYXV0b0Nsb3NlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5hdXRvQ2xvc2U7XG4gICAgdGhpcy5wb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwO1xuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuZW5kICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmRcIiBvcHRpb24gbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIDw9IFwiZW5kXCIgb3B0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICB0aGlzLl92b2wub3Blbih0aGlzLnBhdGgsIHRoaXMuZmxhZ3MsIHRoaXMubW9kZSwgZnVuY3Rpb24gKGVyLCBmZCkge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmF1dG9DbG9zZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZkID0gZmQ7XG4gICAgICAgIHNlbGYuZW1pdCgnb3BlbicsIGZkKTtcbiAgICAgICAgLy8gc3RhcnQgdGhlIGZsb3cgb2YgZGF0YS5cbiAgICAgICAgc2VsZi5yZWFkKCk7XG4gICAgfSk7XG59O1xuRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZChuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghcG9vbCB8fCBwb29sLmxlbmd0aCAtIHBvb2wudXNlZCA8IGtNaW5Qb29sU3BhY2UpIHtcbiAgICAgICAgLy8gZGlzY2FyZCB0aGUgb2xkIHBvb2wuXG4gICAgICAgIGFsbG9jTmV3UG9vbCh0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIH1cbiAgICAvLyBHcmFiIGFub3RoZXIgcmVmZXJlbmNlIHRvIHRoZSBwb29sIGluIHRoZSBjYXNlIHRoYXQgd2hpbGUgd2UncmVcbiAgICAvLyBpbiB0aGUgdGhyZWFkIHBvb2wgYW5vdGhlciByZWFkKCkgZmluaXNoZXMgdXAgdGhlIHBvb2wsIGFuZFxuICAgIC8vIGFsbG9jYXRlcyBhIG5ldyBvbmUuXG4gICAgdmFyIHRoaXNQb29sID0gcG9vbDtcbiAgICB2YXIgdG9SZWFkID0gTWF0aC5taW4ocG9vbC5sZW5ndGggLSBwb29sLnVzZWQsIG4pO1xuICAgIHZhciBzdGFydCA9IHBvb2wudXNlZDtcbiAgICBpZiAodGhpcy5wb3MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdG9SZWFkID0gTWF0aC5taW4odGhpcy5lbmQgLSB0aGlzLnBvcyArIDEsIHRvUmVhZCk7XG4gICAgLy8gYWxyZWFkeSByZWFkIGV2ZXJ5dGhpbmcgd2Ugd2VyZSBzdXBwb3NlZCB0byByZWFkIVxuICAgIC8vIHRyZWF0IGFzIEVPRi5cbiAgICBpZiAodG9SZWFkIDw9IDApXG4gICAgICAgIHJldHVybiB0aGlzLnB1c2gobnVsbCk7XG4gICAgLy8gdGhlIGFjdHVhbCByZWFkLlxuICAgIHZhciBzZWxmID0gdGhpczsgLy8gdHNsaW50OmRpc2FibGUtbGluZSBuby10aGlzLWFzc2lnbm1lbnRcbiAgICB0aGlzLl92b2wucmVhZCh0aGlzLmZkLCBwb29sLCBwb29sLnVzZWQsIHRvUmVhZCwgdGhpcy5wb3MsIG9ucmVhZCk7XG4gICAgLy8gbW92ZSB0aGUgcG9vbCBwb3NpdGlvbnMsIGFuZCBpbnRlcm5hbCBwb3NpdGlvbiBmb3IgcmVhZGluZy5cbiAgICBpZiAodGhpcy5wb3MgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5wb3MgKz0gdG9SZWFkO1xuICAgIHBvb2wudXNlZCArPSB0b1JlYWQ7XG4gICAgZnVuY3Rpb24gb25yZWFkKGVyLCBieXRlc1JlYWQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5hdXRvQ2xvc2UgJiYgc2VsZi5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJ5dGVzUmVhZCArPSBieXRlc1JlYWQ7XG4gICAgICAgICAgICAgICAgYiA9IHRoaXNQb29sLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzUmVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gICAgdGhpcy5jbG9zZShmdW5jdGlvbiAoZXJyMikge1xuICAgICAgICBjYihlcnIgfHwgZXJyMik7XG4gICAgfSk7XG59O1xuRnNSZWFkU3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGNiKVxuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgY2IpO1xuICAgIGlmICh0aGlzLmNsb3NlZCB8fCB0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmZkICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2VPbk9wZW4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9jZXNzXzEuZGVmYXVsdC5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5lbWl0KCdjbG9zZScpOyB9KTtcbiAgICB9XG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX3ZvbC5jbG9zZSh0aGlzLmZkLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfSk7XG4gICAgdGhpcy5mZCA9IG51bGw7XG59O1xuLy8gbmVlZGVkIGJlY2F1c2UgYXMgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHNcbi8vIHRoYXQgZG9lcyBub3QgbWF0Y2ggdGhpcy5jbG9zZSgpIHNpZ25hdHVyZVxuZnVuY3Rpb24gY2xvc2VPbk9wZW4oZmQpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG59XG51dGlsLmluaGVyaXRzKEZzV3JpdGVTdHJlYW0sIHN0cmVhbV8xLldyaXRhYmxlKTtcbmV4cG9ydHMuV3JpdGVTdHJlYW0gPSBGc1dyaXRlU3RyZWFtO1xuZnVuY3Rpb24gRnNXcml0ZVN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRnNXcml0ZVN0cmVhbSkpXG4gICAgICAgIHJldHVybiBuZXcgRnNXcml0ZVN0cmVhbSh2b2wsIHBhdGgsIG9wdGlvbnMpO1xuICAgIHRoaXMuX3ZvbCA9IHZvbDtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBnZXRPcHRpb25zKG9wdGlvbnMsIHt9KSk7XG4gICAgc3RyZWFtXzEuV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoVG9GaWxlbmFtZShwYXRoKTtcbiAgICB0aGlzLmZkID0gb3B0aW9ucy5mZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZmQ7XG4gICAgdGhpcy5mbGFncyA9IG9wdGlvbnMuZmxhZ3MgPT09IHVuZGVmaW5lZCA/ICd3JyA6IG9wdGlvbnMuZmxhZ3M7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlID09PSB1bmRlZmluZWQgPyA0MzggOiBvcHRpb25zLm1vZGU7XG4gICAgdGhpcy5zdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgdGhpcy5hdXRvQ2xvc2UgPSBvcHRpb25zLmF1dG9DbG9zZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0aW9ucy5hdXRvQ2xvc2U7XG4gICAgdGhpcy5wb3MgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwO1xuICAgIGlmICh0aGlzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXJ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzdGFydFwiIG9wdGlvbiBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic3RhcnRcIiBtdXN0IGJlID49IHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nKVxuICAgICAgICB0aGlzLnNldERlZmF1bHRFbmNvZGluZyhvcHRpb25zLmVuY29kaW5nKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAvLyBkaXNwb3NlIG9uIGZpbmlzaC5cbiAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0Nsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdm9sLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvQ2xvc2UgJiYgdGhpcy5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmQgPSBmZDtcbiAgICAgICAgdGhpcy5lbWl0KCdvcGVuJywgZmQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBidWZmZXJfMS5CdWZmZXIpKVxuICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBkYXRhJykpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5mZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25jZSgnb3BlbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlKGRhdGEsIGVuY29kaW5nLCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIHRzbGludDpkaXNhYmxlLWxpbmUgbm8tdGhpcy1hc3NpZ25tZW50XG4gICAgdGhpcy5fdm9sLndyaXRlKHRoaXMuZmQsIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCB0aGlzLnBvcywgZnVuY3Rpb24gKGVyLCBieXRlcykge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmF1dG9DbG9zZSAmJiBzZWxmLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ieXRlc1dyaXR0ZW4gKz0gYnl0ZXM7XG4gICAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMucG9zICs9IGRhdGEubGVuZ3RoO1xufTtcbkZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLl93cml0ZXYgPSBmdW5jdGlvbiAoZGF0YSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZmQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZXYoZGF0YSwgY2IpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lIG5vLXRoaXMtYXNzaWdubWVudFxuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICB2YXIgY2h1bmtzID0gbmV3IEFycmF5KGxlbik7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNodW5rID0gZGF0YVtpXS5jaHVuaztcbiAgICAgICAgY2h1bmtzW2ldID0gY2h1bms7XG4gICAgICAgIHNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgIHRoaXMuX3ZvbC53cml0ZSh0aGlzLmZkLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXMucG9zLCBmdW5jdGlvbiAoZXIsIGJ5dGVzKSB7XG4gICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVzdHJveSlcbiAgICAgICAgICAgICAgICBzZWxmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5ieXRlc1dyaXR0ZW4gKz0gYnl0ZXM7XG4gICAgICAgIGNiKCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMucG9zICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMucG9zICs9IHNpemU7XG59O1xuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBGc1JlYWRTdHJlYW0ucHJvdG90eXBlLl9kZXN0cm95O1xuRnNXcml0ZVN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBGc1JlYWRTdHJlYW0ucHJvdG90eXBlLmNsb3NlO1xuLy8gVGhlcmUgaXMgbm8gc2h1dGRvd24oKSBmb3IgZmlsZXMuXG5Gc1dyaXRlU3RyZWFtLnByb3RvdHlwZS5kZXN0cm95U29vbiA9IEZzV3JpdGVTdHJlYW0ucHJvdG90eXBlLmVuZDtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRlNXYXRjaGVyXG52YXIgRlNXYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGU1dhdGNoZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRlNXYXRjaGVyKHZvbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fZmlsZW5hbWUgPSAnJztcbiAgICAgICAgX3RoaXMuX3N0ZXBzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX2ZpbGVuYW1lRW5jb2RlZCA9ICcnO1xuICAgICAgICAvLyBfcGVyc2lzdGVudDogYm9vbGVhbiA9IHRydWU7XG4gICAgICAgIF90aGlzLl9yZWN1cnNpdmUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2VuY29kaW5nID0gZW5jb2RpbmdfMS5FTkNPRElOR19VVEY4O1xuICAgICAgICBfdGhpcy5fbGluayA9IG51bGw7XG4gICAgICAgIF90aGlzLl9vbk5vZGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9vblBhcmVudENoaWxkID0gZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgIGlmIChsaW5rLmdldE5hbWUoKSA9PT0gX3RoaXMuX2dldE5hbWUoKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9lbWl0KCdyZW5hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX2VtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2hhbmdlJywgdHlwZSwgX3RoaXMuX2ZpbGVuYW1lRW5jb2RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9wZXJzaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3RpbWVyID0gc2V0VGltZW91dChfdGhpcy5fcGVyc2lzdCwgMWU2KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3ZvbCA9IHZvbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAvLyBUT0RPOiBFbWl0IFwiZXJyb3JcIiBtZXNzYWdlcyB3aGVuIHdhdGNoaW5nLlxuICAgICAgICAvLyB0aGlzLl9oYW5kbGUub25jaGFuZ2UgPSBmdW5jdGlvbihzdGF0dXMsIGV2ZW50VHlwZSwgZmlsZW5hbWUpIHtcbiAgICAgICAgLy8gICAgIGlmIChzdGF0dXMgPCAwKSB7XG4gICAgICAgIC8vICAgICAgICAgc2VsZi5faGFuZGxlLmNsb3NlKCk7XG4gICAgICAgIC8vICAgICAgICAgY29uc3QgZXJyb3IgPSAhZmlsZW5hbWUgP1xuICAgICAgICAvLyAgICAgICAgICAgICBlcnJub0V4Y2VwdGlvbihzdGF0dXMsICdFcnJvciB3YXRjaGluZyBmaWxlIGZvciBjaGFuZ2VzOicpIDpcbiAgICAgICAgLy8gICAgICAgICAgICAgZXJybm9FeGNlcHRpb24oc3RhdHVzLCBgRXJyb3Igd2F0Y2hpbmcgZmlsZSAke2ZpbGVuYW1lfSBmb3IgY2hhbmdlczpgKTtcbiAgICAgICAgLy8gICAgICAgICBlcnJvci5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgIHNlbGYuZW1pdCgnY2hhbmdlJywgZXZlbnRUeXBlLCBmaWxlbmFtZSk7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH07XG4gICAgfVxuICAgIEZTV2F0Y2hlci5wcm90b3R5cGUuX2dldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwc1t0aGlzLl9zdGVwcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIEZTV2F0Y2hlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAocGF0aCwgcGVyc2lzdGVudCwgcmVjdXJzaXZlLCBlbmNvZGluZykge1xuICAgICAgICBpZiAocGVyc2lzdGVudCA9PT0gdm9pZCAwKSB7IHBlcnNpc3RlbnQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChyZWN1cnNpdmUgPT09IHZvaWQgMCkgeyByZWN1cnNpdmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IGVuY29kaW5nXzEuRU5DT0RJTkdfVVRGODsgfVxuICAgICAgICB0aGlzLl9maWxlbmFtZSA9IHBhdGhUb0ZpbGVuYW1lKHBhdGgpO1xuICAgICAgICB0aGlzLl9zdGVwcyA9IGZpbGVuYW1lVG9TdGVwcyh0aGlzLl9maWxlbmFtZSk7XG4gICAgICAgIHRoaXMuX2ZpbGVuYW1lRW5jb2RlZCA9IGVuY29kaW5nXzEuc3RyVG9FbmNvZGluZyh0aGlzLl9maWxlbmFtZSk7XG4gICAgICAgIC8vIHRoaXMuX3BlcnNpc3RlbnQgPSBwZXJzaXN0ZW50O1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmUgPSByZWN1cnNpdmU7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9saW5rID0gdGhpcy5fdm9sLmdldExpbmtPclRocm93KHRoaXMuX2ZpbGVuYW1lLCAnRlNXYXRjaGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwid2F0Y2ggXCIgKyB0aGlzLl9maWxlbmFtZSArIFwiIFwiICsgZXJyLmNvZGUpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IGVyci5jb2RlO1xuICAgICAgICAgICAgZXJyb3IuZXJybm8gPSBlcnIuY29kZTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpbmsuZ2V0Tm9kZSgpLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk5vZGVDaGFuZ2UpO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fbGluay5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIHBhcmVudC5vbignY2hpbGQ6YWRkJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgICAgICBwYXJlbnQub24oJ2NoaWxkOmRlbGV0ZScsIHRoaXMuX29uUGFyZW50Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0ZW50KVxuICAgICAgICAgICAgdGhpcy5fcGVyc2lzdCgpO1xuICAgIH07XG4gICAgRlNXYXRjaGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICAgICAgdGhpcy5fbGluay5nZXROb2RlKCkucmVtb3ZlTGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uTm9kZUNoYW5nZSk7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLl9saW5rLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgLy8gcGFyZW50LnJlbW92ZUxpc3RlbmVyKCdjaGlsZDphZGQnLCB0aGlzLl9vblBhcmVudENoaWxkKTtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVMaXN0ZW5lcignY2hpbGQ6ZGVsZXRlJywgdGhpcy5fb25QYXJlbnRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGU1dhdGNoZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5GU1dhdGNoZXIgPSBGU1dhdGNoZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3ZvbHVtZS5qcyIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcm9jZXNzXzEgPSByZXF1aXJlKFwiLi9wcm9jZXNzXCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnVmZmVyXCIpO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBTdGF0c18xID0gcmVxdWlyZShcIi4vU3RhdHNcIik7XG52YXIgU19JRk1UID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZNVCwgU19JRkRJUiA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGRElSLCBTX0lGUkVHID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZSRUcsIFNfSUZCTEsgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRkJMSywgU19JRkNIUiA9IGNvbnN0YW50c18xLmNvbnN0YW50cy5TX0lGQ0hSLCBTX0lGTE5LID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLlNfSUZMTkssIFNfSUZJRk8gPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRklGTywgU19JRlNPQ0sgPSBjb25zdGFudHNfMS5jb25zdGFudHMuU19JRlNPQ0ssIE9fQVBQRU5EID0gY29uc3RhbnRzXzEuY29uc3RhbnRzLk9fQVBQRU5EO1xuZXhwb3J0cy5TRVAgPSAnLyc7XG4vKipcbiAqIE5vZGUgaW4gYSBmaWxlIHN5c3RlbSAobGlrZSBpLW5vZGUsIHYtbm9kZSkuXG4gKi9cbnZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE5vZGUoaW5vLCBwZXJtKSB7XG4gICAgICAgIGlmIChwZXJtID09PSB2b2lkIDApIHsgcGVybSA9IDQzODsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBVc2VyIElEIGFuZCBncm91cCBJRC5cbiAgICAgICAgX3RoaXMudWlkID0gcHJvY2Vzc18xLmRlZmF1bHQuZ2V0dWlkKCk7XG4gICAgICAgIF90aGlzLmdpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldGdpZCgpO1xuICAgICAgICBfdGhpcy5hdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIF90aGlzLm10aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgX3RoaXMuY3RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvLyBkYXRhOiBzdHJpbmcgPSAnJztcbiAgICAgICAgX3RoaXMuYnVmID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVybSA9IDQzODsgLy8gUGVybWlzc2lvbnMgYGNobW9kYCwgYGZjaG1vZGBcbiAgICAgICAgX3RoaXMubW9kZSA9IFNfSUZSRUc7IC8vIFNfSUZESVIsIFNfSUZSRUcsIGV0Yy4uIChmaWxlIGJ5IGRlZmF1bHQ/KVxuICAgICAgICAvLyBOdW1iZXIgb2YgaGFyZCBsaW5rcyBwb2ludGluZyBhdCB0aGlzIE5vZGUuXG4gICAgICAgIF90aGlzLm5saW5rID0gMTtcbiAgICAgICAgLy8gU3RlcHMgdG8gYW5vdGhlciBub2RlLCBpZiB0aGlzIG5vZGUgaXMgYSBzeW1saW5rLlxuICAgICAgICBfdGhpcy5zeW1saW5rID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVybSA9IHBlcm07XG4gICAgICAgIF90aGlzLm1vZGUgfD0gcGVybTtcbiAgICAgICAgX3RoaXMuaW5vID0gaW5vO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5vZGUucHJvdG90eXBlLmdldFN0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9ICd1dGY4JzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKS50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRTdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIHRoaXMuc2V0QnVmZmVyKGJ1ZmZlckZyb20oc3RyLCAndXRmOCcpKTtcbiAgICAgICAgdGhpcy5idWYgPSBidWZmZXJfMS5idWZmZXJGcm9tKHN0ciwgJ3V0ZjgnKTtcbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIoYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCkpO1xuICAgICAgICByZXR1cm4gYnVmZmVyXzEuYnVmZmVyRnJvbSh0aGlzLmJ1Zik7IC8vIFJldHVybiBhIGNvcHkuXG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5zZXRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyRnJvbShidWYpOyAvLyBDcmVhdGVzIGEgY29weSBvZiBkYXRhLlxuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYgPyB0aGlzLmJ1Zi5sZW5ndGggOiAwO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuc2V0TW9kZVByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHRoaXMubW9kZSA9ICh0aGlzLm1vZGUgJiB+U19JRk1UKSB8IHByb3BlcnR5O1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuc2V0SXNGaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE1vZGVQcm9wZXJ0eShTX0lGUkVHKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnNldElzRGlyZWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldE1vZGVQcm9wZXJ0eShTX0lGRElSKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLnNldElzU3ltbGluayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRNb2RlUHJvcGVydHkoU19JRkxOSyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pc0ZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RlICYgU19JRk1UKSA9PT0gU19JRlJFRztcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmlzRGlyZWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIFNfSUZNVCkgPT09IFNfSUZESVI7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5pc1N5bWxpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHJldHVybiAhIXRoaXMuc3ltbGluaztcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiBTX0lGTVQpID09PSBTX0lGTE5LO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUubWFrZVN5bWxpbmsgPSBmdW5jdGlvbiAoc3RlcHMpIHtcbiAgICAgICAgdGhpcy5zeW1saW5rID0gc3RlcHM7XG4gICAgICAgIHRoaXMuc2V0SXNTeW1saW5rKCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYsIG9mZiwgbGVuLCBwb3MpIHtcbiAgICAgICAgaWYgKG9mZiA9PT0gdm9pZCAwKSB7IG9mZiA9IDA7IH1cbiAgICAgICAgaWYgKGxlbiA9PT0gdm9pZCAwKSB7IGxlbiA9IGJ1Zi5sZW5ndGg7IH1cbiAgICAgICAgaWYgKHBvcyA9PT0gdm9pZCAwKSB7IHBvcyA9IDA7IH1cbiAgICAgICAgaWYgKCF0aGlzLmJ1ZilcbiAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIGlmIChwb3MgKyBsZW4gPiB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdCdWYgPSBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZShwb3MgKyBsZW4pO1xuICAgICAgICAgICAgdGhpcy5idWYuY29weShuZXdCdWYsIDAsIDAsIHRoaXMuYnVmLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IG5ld0J1ZjtcbiAgICAgICAgfVxuICAgICAgICBidWYuY29weSh0aGlzLmJ1ZiwgcG9zLCBvZmYsIG9mZiArIGxlbik7XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICAgICAgcmV0dXJuIGxlbjtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgIE5vZGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoYnVmLCBvZmYsIGxlbiwgcG9zKSB7XG4gICAgICAgIGlmIChvZmYgPT09IHZvaWQgMCkgeyBvZmYgPSAwOyB9XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSBidWYuYnl0ZUxlbmd0aDsgfVxuICAgICAgICBpZiAocG9zID09PSB2b2lkIDApIHsgcG9zID0gMDsgfVxuICAgICAgICBpZiAoIXRoaXMuYnVmKVxuICAgICAgICAgICAgdGhpcy5idWYgPSBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgdmFyIGFjdHVhbExlbiA9IGxlbjtcbiAgICAgICAgaWYgKGFjdHVhbExlbiA+IGJ1Zi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSBidWYuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0dWFsTGVuICsgcG9zID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBhY3R1YWxMZW4gPSB0aGlzLmJ1Zi5sZW5ndGggLSBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWYuY29weShidWYsIG9mZiwgcG9zLCBwb3MgKyBhY3R1YWxMZW4pO1xuICAgICAgICByZXR1cm4gYWN0dWFsTGVuO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIGlmIChsZW4gPT09IHZvaWQgMCkgeyBsZW4gPSAwOyB9XG4gICAgICAgIGlmICghbGVuKVxuICAgICAgICAgICAgdGhpcy5idWYgPSBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYnVmKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmID0gYnVmZmVyXzEuYnVmZmVyQWxsb2NVbnNhZmUoMCk7XG4gICAgICAgICAgICBpZiAobGVuIDw9IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmID0gdGhpcy5idWYuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXJfMS5idWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1Zi5jb3B5KGJ1Zik7XG4gICAgICAgICAgICAgICAgYnVmLmZpbGwoMCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdWNoKCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5jaG1vZCA9IGZ1bmN0aW9uIChwZXJtKSB7XG4gICAgICAgIHRoaXMucGVybSA9IHBlcm07XG4gICAgICAgIHRoaXMubW9kZSA9ICh0aGlzLm1vZGUgJiB+NTExKSB8IHBlcm07XG4gICAgICAgIHRoaXMudG91Y2goKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmNob3duID0gZnVuY3Rpb24gKHVpZCwgZ2lkKSB7XG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgICAgICB0aGlzLmdpZCA9IGdpZDtcbiAgICAgICAgdGhpcy50b3VjaCgpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubXRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHRoaXMpO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuY2FuUmVhZCA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICBpZiAodWlkID09PSB2b2lkIDApIHsgdWlkID0gcHJvY2Vzc18xLmRlZmF1bHQuZ2V0dWlkKCk7IH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdm9pZCAwKSB7IGdpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldGdpZCgpOyB9XG4gICAgICAgIGlmICh0aGlzLnBlcm0gJiA0IC8qIElST1RIICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2lkID09PSB0aGlzLmdpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDMyIC8qIElSR1JQICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAyNTYgLyogSVJVU1IgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5jYW5Xcml0ZSA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICBpZiAodWlkID09PSB2b2lkIDApIHsgdWlkID0gcHJvY2Vzc18xLmRlZmF1bHQuZ2V0dWlkKCk7IH1cbiAgICAgICAgaWYgKGdpZCA9PT0gdm9pZCAwKSB7IGdpZCA9IHByb2Nlc3NfMS5kZWZhdWx0LmdldGdpZCgpOyB9XG4gICAgICAgIGlmICh0aGlzLnBlcm0gJiAyIC8qIElXT1RIICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2lkID09PSB0aGlzLmdpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVybSAmIDE2IC8qIElXR1JQICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVpZCA9PT0gdGhpcy51aWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlcm0gJiAxMjggLyogSVdVU1IgKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVsZXRlJywgdGhpcyk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbm86IHRoaXMuaW5vLFxuICAgICAgICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgICAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICAgICAgICBhdGltZTogdGhpcy5hdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtdGltZTogdGhpcy5tdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBjdGltZTogdGhpcy5jdGltZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBwZXJtOiB0aGlzLnBlcm0sXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICBubGluazogdGhpcy5ubGluayxcbiAgICAgICAgICAgIHN5bWxpbms6IHRoaXMuc3ltbGluayxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZ2V0U3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLk5vZGUgPSBOb2RlO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgaGFyZCBsaW5rIHRoYXQgcG9pbnRzIHRvIGFuIGktbm9kZSBgbm9kZWAuXG4gKi9cbnZhciBMaW5rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmsodm9sLCBwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgLy8gUGF0aCB0byB0aGlzIG5vZGUgYXMgQXJyYXk6IFsndXNyJywgJ2JpbicsICdub2RlJ10uXG4gICAgICAgIF90aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8vIFwiaS1ub2RlXCIgb2YgdGhpcyBoYXJkIGxpbmsuXG4gICAgICAgIF90aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICAvLyBcImktbm9kZVwiIG51bWJlciBvZiB0aGUgbm9kZS5cbiAgICAgICAgX3RoaXMuaW5vID0gMDtcbiAgICAgICAgLy8gTnVtYmVyIG9mIGNoaWxkcmVuLlxuICAgICAgICBfdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICBfdGhpcy52b2wgPSB2b2w7XG4gICAgICAgIF90aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgX3RoaXMuc3RlcHMgPSBwYXJlbnQgPyBwYXJlbnQuc3RlcHMuY29uY2F0KFtuYW1lXSkgOiBbbmFtZV07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTGluay5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuaW5vID0gbm9kZS5pbm87XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuY3JlYXRlQ2hpbGQgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKSB7IG5vZGUgPSB0aGlzLnZvbC5jcmVhdGVOb2RlKCk7IH1cbiAgICAgICAgdmFyIGxpbmsgPSBuZXcgTGluayh0aGlzLnZvbCwgdGhpcywgbmFtZSk7XG4gICAgICAgIGxpbmsuc2V0Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKG5vZGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgLy8gbGluay5zZXRDaGlsZCgnLicsIGxpbmspO1xuICAgICAgICAgICAgLy8gbGluay5nZXROb2RlKCkubmxpbmsrKztcbiAgICAgICAgICAgIC8vIGxpbmsuc2V0Q2hpbGQoJy4uJywgdGhpcyk7XG4gICAgICAgICAgICAvLyB0aGlzLmdldE5vZGUoKS5ubGluaysrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0Q2hpbGQobmFtZSwgbGluayk7XG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuc2V0Q2hpbGQgPSBmdW5jdGlvbiAobmFtZSwgbGluaykge1xuICAgICAgICBpZiAobGluayA9PT0gdm9pZCAwKSB7IGxpbmsgPSBuZXcgTGluayh0aGlzLnZvbCwgdGhpcywgbmFtZSk7IH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbltuYW1lXSA9IGxpbms7XG4gICAgICAgIGxpbmsucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgdGhpcy5lbWl0KCdjaGlsZDphZGQnLCBsaW5rLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxpbms7XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5kZWxldGVDaGlsZCA9IGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkcmVuW2xpbmsuZ2V0TmFtZSgpXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGlsZDpkZWxldGUnLCBsaW5rLCB0aGlzKTtcbiAgICB9O1xuICAgIExpbmsucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY2hpbGRyZW4sIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltuYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTGluay5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMuam9pbihleHBvcnRzLlNFUCk7XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwc1t0aGlzLnN0ZXBzLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgLy8gZGVsKCkge1xuICAgIC8vICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAvLyAgICAgaWYocGFyZW50KSB7XG4gICAgLy8gICAgICAgICBwYXJlbnQuZGVsZXRlQ2hpbGQobGluayk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIC8vICAgICB0aGlzLnZvbCA9IG51bGw7XG4gICAgLy8gfVxuICAgIC8qKlxuICAgICAqIFdhbGsgdGhlIHRyZWUgcGF0aCBhbmQgcmV0dXJuIHRoZSBgTGlua2AgYXQgdGhhdCBsb2NhdGlvbiwgaWYgYW55LlxuICAgICAqIEBwYXJhbSBzdGVwcyB7c3RyaW5nW119IERlc2lyZWQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHN0b3Age251bWJlcn0gTWF4IHN0ZXBzIHRvIGdvIGludG8uXG4gICAgICogQHBhcmFtIGkge251bWJlcn0gQ3VycmVudCBzdGVwIGluIHRoZSBgc3RlcHNgIGFycmF5LlxuICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICovXG4gICAgTGluay5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIChzdGVwcywgc3RvcCwgaSkge1xuICAgICAgICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7IHN0b3AgPSBzdGVwcy5sZW5ndGg7IH1cbiAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMDsgfVxuICAgICAgICBpZiAoaSA+PSBzdGVwcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKGkgPj0gc3RvcClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgc3RlcCA9IHN0ZXBzW2ldO1xuICAgICAgICB2YXIgbGluayA9IHRoaXMuZ2V0Q2hpbGQoc3RlcCk7XG4gICAgICAgIGlmICghbGluaylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbGluay53YWxrKHN0ZXBzLCBzdG9wLCBpICsgMSk7XG4gICAgfTtcbiAgICBMaW5rLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGVwczogdGhpcy5zdGVwcyxcbiAgICAgICAgICAgIGlubzogdGhpcy5pbm8sXG4gICAgICAgICAgICBjaGlsZHJlbjogT2JqZWN0LmtleXModGhpcy5jaGlsZHJlbiksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gTGluaztcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLkxpbmsgPSBMaW5rO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIG9wZW4gZmlsZSAoZmlsZSBkZXNjcmlwdG9yKSB0aGF0IHBvaW50cyB0byBhIGBMaW5rYCAoSGFyZC1saW5rKSBhbmQgYSBgTm9kZWAuXG4gKi9cbnZhciBGaWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIE9wZW4gYSBMaW5rLU5vZGUgcGFpci4gYG5vZGVgIGlzIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgdGhhdCBtaWdodCBiZSBhIGRpZmZlcmVudCBub2RlXG4gICAgICogcmF0aGVyIHRoZSBvbmUgYGxpbmtgIHBvaW50cyB0bywgYmVjYXVzZSBpdCBtaWdodCBiZSBhIHN5bWxpbmsuXG4gICAgICogQHBhcmFtIGxpbmtcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSBmbGFnc1xuICAgICAqIEBwYXJhbSBmZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEZpbGUobGluaywgbm9kZSwgZmxhZ3MsIGZkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYXJkIGxpbmsgdGhhdCB0aGlzIGZpbGUgb3BlbmVkLlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5rID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byBhIGBOb2RlYC5cbiAgICAgICAgICogQHR5cGUge05vZGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjdXJzb3Ivb2Zmc2V0IHBvc2l0aW9uIGluIGEgZmlsZSwgd2hlcmUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4gb24gd3JpdGUuXG4gICAgICAgICAqIFVzZXIgY2FuIFwic2Vla1wiIHRoaXMgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgfVxuICAgIEZpbGUucHJvdG90eXBlLmdldFN0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9ICd1dGY4JzsgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmdldFN0cmluZygpO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuc2V0U3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0aGlzLm5vZGUuc2V0U3RyaW5nKHN0cik7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0QnVmZmVyKCk7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5zZXRCdWZmZXIgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIHRoaXMubm9kZS5zZXRCdWZmZXIoYnVmKTtcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0U2l6ZSgpO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUudHJ1bmNhdGUgPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgICAgIHRoaXMubm9kZS50cnVuY2F0ZShsZW4pO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuc2Vla1RvID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9O1xuICAgIEZpbGUucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RhdHNfMS5kZWZhdWx0LmJ1aWxkKHRoaXMubm9kZSk7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gYnVmLmxlbmd0aDsgfVxuICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MgJiBPX0FQUEVORClcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgIHZhciBieXRlcyA9IHRoaXMubm9kZS53cml0ZShidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbiArIGJ5dGVzO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSBidWYuYnl0ZUxlbmd0aDsgfVxuICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ub2RlLnJlYWQoYnVmLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb24gKyBieXRlcztcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH07XG4gICAgRmlsZS5wcm90b3R5cGUuY2htb2QgPSBmdW5jdGlvbiAocGVybSkge1xuICAgICAgICB0aGlzLm5vZGUuY2htb2QocGVybSk7XG4gICAgfTtcbiAgICBGaWxlLnByb3RvdHlwZS5jaG93biA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICB0aGlzLm5vZGUuY2hvd24odWlkLCBnaWQpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbGU7XG59KCkpO1xuZXhwb3J0cy5GaWxlID0gRmlsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9tZW1mcy9saWIvbm9kZS5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGBzZXRUaW1lb3V0VW5yZWZgIGlzIGp1c3QgbGlrZSBgc2V0VGltZW91dGAsXG4gKiBvbmx5IGluIE5vZGUncyBlbnZpcm9ubWVudCBpdCB3aWxsIFwidW5yZWZcIiBpdHMgbWFjcm8gdGFzay5cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dFVucmVmKGNhbGxiYWNrLCB0aW1lLCBhcmdzKSB7XG4gICAgdmFyIHJlZiA9IHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVmICYmIHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZWYudW5yZWYgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJlZi51bnJlZigpO1xuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzZXRUaW1lb3V0VW5yZWY7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbWVtZnMvbGliL3NldFRpbWVvdXRVbnJlZi5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiLyogKGlnbm9yZWQpICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gdXRpbCAoaWdub3JlZClcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwiXG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvcih2YXIga2V5IGluIGIpIGFba2V5XSA9IGJba2V5XTtcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgM1xuICAgICAgICA/IGFcbiAgICAgICAgOiBleHRlbmQuYXBwbHkobnVsbCwgW2FdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMikpKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmFzdC1leHRlbmQvaW5kZXguanMiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcHJvbWlzaWZ5KHZvbCwgZm4sIGdldFJlc3VsdCkge1xuICAgIGlmIChnZXRSZXN1bHQgPT09IHZvaWQgMCkgeyBnZXRSZXN1bHQgPSBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIGlucHV0OyB9OyB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdm9sW2ZuXS5iaW5kKHZvbCkuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5cyhhcmdzLCBbZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdldFJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxudmFyIEZpbGVIYW5kbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsZUhhbmRsZSh2b2wsIGZkKSB7XG4gICAgICAgIHRoaXMudm9sID0gdm9sO1xuICAgICAgICB0aGlzLmZkID0gZmQ7XG4gICAgfVxuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLmFwcGVuZEZpbGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnYXBwZW5kRmlsZScpKHRoaXMuZmQsIGRhdGEsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuY2htb2QgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZmNobW9kJykodGhpcy5mZCwgbW9kZSk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5jaG93biA9IGZ1bmN0aW9uICh1aWQsIGdpZCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZmNob3duJykodGhpcy5mZCwgdWlkLCBnaWQpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsICdjbG9zZScpKHRoaXMuZmQpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUuZGF0YXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNpZnkodGhpcy52b2wsICdmZGF0YXN5bmMnKSh0aGlzLmZkKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3JlYWQnLCBmdW5jdGlvbiAoYnl0ZXNSZWFkKSB7IHJldHVybiAoeyBieXRlc1JlYWQ6IGJ5dGVzUmVhZCwgYnVmZmVyOiBidWZmZXIgfSk7IH0pKHRoaXMuZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnJlYWRGaWxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3JlYWRGaWxlJykodGhpcy5mZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5zdGF0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ2ZzdGF0JykodGhpcy5mZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZnN5bmMnKSh0aGlzLmZkKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnZnRydW5jYXRlJykodGhpcy5mZCwgbGVuKTtcbiAgICB9O1xuICAgIEZpbGVIYW5kbGUucHJvdG90eXBlLnV0aW1lcyA9IGZ1bmN0aW9uIChhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ2Z1dGltZXMnKSh0aGlzLmZkLCBhdGltZSwgbXRpbWUpO1xuICAgIH07XG4gICAgRmlsZUhhbmRsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2lmeSh0aGlzLnZvbCwgJ3dyaXRlJywgZnVuY3Rpb24gKGJ5dGVzV3JpdHRlbikgeyByZXR1cm4gKHsgYnl0ZXNXcml0dGVuOiBieXRlc1dyaXR0ZW4sIGJ1ZmZlcjogYnVmZmVyIH0pOyB9KSh0aGlzLmZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gICAgfTtcbiAgICBGaWxlSGFuZGxlLnByb3RvdHlwZS53cml0ZUZpbGUgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHRoaXMudm9sLCAnd3JpdGVGaWxlJykodGhpcy5mZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZUhhbmRsZTtcbn0oKSk7XG5leHBvcnRzLkZpbGVIYW5kbGUgPSBGaWxlSGFuZGxlO1xuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZXNBcGkodm9sKSB7XG4gICAgaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgRmlsZUhhbmRsZTogRmlsZUhhbmRsZSxcbiAgICAgICAgYWNjZXNzOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdhY2Nlc3MnKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZW5kRmlsZTogZnVuY3Rpb24gKHBhdGgsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnYXBwZW5kRmlsZScpKHBhdGggaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gcGF0aC5mZCA6IHBhdGgsIGRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnY2htb2QnKShwYXRoLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hvd246IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdjaG93bicpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29weUZpbGU6IGZ1bmN0aW9uIChzcmMsIGRlc3QsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2NvcHlGaWxlJykoc3JjLCBkZXN0LCBmbGFncyk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnbGNobW9kJykocGF0aCwgbW9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxjaG93bjogZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2xjaG93bicpKHBhdGgsIHVpZCwgZ2lkKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluazogZnVuY3Rpb24gKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdsaW5rJykoZXhpc3RpbmdQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbHN0YXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ2xzdGF0JykocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIG1rZGlyOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdta2RpcicpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBta2R0ZW1wOiBmdW5jdGlvbiAocHJlZml4LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ21rZHRlbXAnKShwcmVmaXgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBvcGVuOiBmdW5jdGlvbiAocGF0aCwgZmxhZ3MsIG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnb3BlbicsIGZ1bmN0aW9uIChmZCkgeyByZXR1cm4gbmV3IEZpbGVIYW5kbGUodm9sLCBmZCk7IH0pKHBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAncmVhZGRpcicpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkRmlsZTogZnVuY3Rpb24gKGlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3JlYWRGaWxlJykoaWQgaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gaWQuZmQgOiBpZCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRsaW5rOiBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdyZWFkbGluaycpKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICByZWFscGF0aDogZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAncmVhbHBhdGgnKShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdyZW5hbWUnKShvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcm1kaXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3JtZGlyJykocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXQ6IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3N0YXQnKShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3ltbGluazogZnVuY3Rpb24gKHRhcmdldCwgcGF0aCwgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2lmeSh2b2wsICdzeW1saW5rJykodGFyZ2V0LCBwYXRoLCB0eXBlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJ1bmNhdGU6IGZ1bmN0aW9uIChwYXRoLCBsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAndHJ1bmNhdGUnKShwYXRoLCBsZW4pO1xuICAgICAgICB9LFxuICAgICAgICB1bmxpbms6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzaWZ5KHZvbCwgJ3VubGluaycpKHBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICB1dGltZXM6IGZ1bmN0aW9uIChwYXRoLCBhdGltZSwgbXRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAndXRpbWVzJykocGF0aCwgYXRpbWUsIG10aW1lKTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVGaWxlOiBmdW5jdGlvbiAoaWQsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNpZnkodm9sLCAnd3JpdGVGaWxlJykoaWQgaW5zdGFuY2VvZiBGaWxlSGFuZGxlID8gaWQuZmQgOiBpZCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVByb21pc2VzQXBpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL21lbWZzL2xpYi9wcm9taXNlcy5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVuaXhpZnkgPSB1bml4aWZ5O1xuZXhwb3J0cy5jb3JyZWN0UGF0aCA9IGNvcnJlY3RQYXRoO1xudmFyIGlzV2luID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcblxuZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3Ioc3RyKSB7XG4gIHZhciBpID0gc3RyLmxlbmd0aCAtIDE7XG4gIGlmIChpIDwgMikge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgd2hpbGUgKGlzU2VwYXJhdG9yKHN0ciwgaSkpIHtcbiAgICBpLS07XG4gIH1cbiAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgaSArIDEpO1xufVxuXG5mdW5jdGlvbiBpc1NlcGFyYXRvcihzdHIsIGkpIHtcbiAgdmFyIGNoYXIgPSBzdHJbaV07XG4gIHJldHVybiBpID4gMCAmJiAoY2hhciA9PT0gJy8nIHx8IGlzV2luICYmIGNoYXIgPT09ICdcXFxcJyk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgoc3RyLCBzdHJpcFRyYWlsaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXFxcXFwvXSsvZywgJy8nKTtcbiAgaWYgKHN0cmlwVHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgc3RyID0gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3Ioc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiB1bml4aWZ5KGZpbGVwYXRoKSB7XG4gIHZhciBzdHJpcFRyYWlsaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gIGlmIChpc1dpbikge1xuICAgIGZpbGVwYXRoID0gbm9ybWFsaXplUGF0aChmaWxlcGF0aCwgc3RyaXBUcmFpbGluZyk7XG4gICAgcmV0dXJuIGZpbGVwYXRoLnJlcGxhY2UoL14oW2EtekEtWl0rOnxcXC5cXC8pLywgJycpO1xuICB9XG4gIHJldHVybiBmaWxlcGF0aDtcbn1cblxuZnVuY3Rpb24gY29ycmVjdFBhdGgoZmlsZXBhdGgpIHtcbiAgcmV0dXJuIHVuaXhpZnkoZmlsZXBhdGgucmVwbGFjZSgvXlxcXFxcXFxcXFw/XFxcXC46XFxcXC8sICdcXFxcJykpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mcy1tb25rZXkvbGliL2NvcnJlY3RQYXRoLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZnNQcm9wcyA9IGV4cG9ydHMuZnNQcm9wcyA9IFsnY29uc3RhbnRzJywgJ0ZfT0snLCAnUl9PSycsICdXX09LJywgJ1hfT0snLCAnU3RhdHMnXTtcblxudmFyIGZzU3luY01ldGhvZHMgPSBleHBvcnRzLmZzU3luY01ldGhvZHMgPSBbJ3JlbmFtZVN5bmMnLCAnZnRydW5jYXRlU3luYycsICd0cnVuY2F0ZVN5bmMnLCAnY2hvd25TeW5jJywgJ2ZjaG93blN5bmMnLCAnbGNob3duU3luYycsICdjaG1vZFN5bmMnLCAnZmNobW9kU3luYycsICdsY2htb2RTeW5jJywgJ3N0YXRTeW5jJywgJ2xzdGF0U3luYycsICdmc3RhdFN5bmMnLCAnbGlua1N5bmMnLCAnc3ltbGlua1N5bmMnLCAncmVhZGxpbmtTeW5jJywgJ3JlYWxwYXRoU3luYycsICd1bmxpbmtTeW5jJywgJ3JtZGlyU3luYycsICdta2RpclN5bmMnLCAnbWtkaXJwU3luYycsICdyZWFkZGlyU3luYycsICdjbG9zZVN5bmMnLCAnb3BlblN5bmMnLCAndXRpbWVzU3luYycsICdmdXRpbWVzU3luYycsICdmc3luY1N5bmMnLCAnd3JpdGVTeW5jJywgJ3JlYWRTeW5jJywgJ3JlYWRGaWxlU3luYycsICd3cml0ZUZpbGVTeW5jJywgJ2FwcGVuZEZpbGVTeW5jJywgJ2V4aXN0c1N5bmMnLCAnYWNjZXNzU3luYycsICdmZGF0YXN5bmNTeW5jJywgJ21rZHRlbXBTeW5jJywgJ2NvcHlGaWxlU3luYycsICdjcmVhdGVSZWFkU3RyZWFtJywgJ2NyZWF0ZVdyaXRlU3RyZWFtJ107XG5cbnZhciBmc0FzeW5jTWV0aG9kcyA9IGV4cG9ydHMuZnNBc3luY01ldGhvZHMgPSBbJ3JlbmFtZScsICdmdHJ1bmNhdGUnLCAndHJ1bmNhdGUnLCAnY2hvd24nLCAnZmNob3duJywgJ2xjaG93bicsICdjaG1vZCcsICdmY2htb2QnLCAnbGNobW9kJywgJ3N0YXQnLCAnbHN0YXQnLCAnZnN0YXQnLCAnbGluaycsICdzeW1saW5rJywgJ3JlYWRsaW5rJywgJ3JlYWxwYXRoJywgJ3VubGluaycsICdybWRpcicsICdta2RpcicsICdta2RpcnAnLCAncmVhZGRpcicsICdjbG9zZScsICdvcGVuJywgJ3V0aW1lcycsICdmdXRpbWVzJywgJ2ZzeW5jJywgJ3dyaXRlJywgJ3JlYWQnLCAncmVhZEZpbGUnLCAnd3JpdGVGaWxlJywgJ2FwcGVuZEZpbGUnLCAnZXhpc3RzJywgJ2FjY2VzcycsICdmZGF0YXN5bmMnLCAnbWtkdGVtcCcsICdjb3B5RmlsZScsICd3YXRjaEZpbGUnLCAndW53YXRjaEZpbGUnLCAnd2F0Y2gnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZnMtbW9ua2V5L2xpYi91dGlsL2xpc3RzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==